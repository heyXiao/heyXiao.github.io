{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery-master/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.png","path":"medias/avatar.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"1a029a492861cf92cd5f267fadd2322bb7f9c70d","modified":1603440099030},{"_id":"source/_posts/LeetCode 70 Climb Stairs.md","hash":"6b1bfcac0edaa2b442f4fa93ab4cd0d5b817a654","modified":1610087752455},{"_id":"source/_posts/使用CSDN-markdown编辑器.md","hash":"1373c0c5db2a4ccdd757e413eb183a05d2d96476","modified":1604734149539},{"_id":"source/_posts/LeetCode 64 Minimum Path Sum.md","hash":"2eaab8e2bb7c128349dbfa49b86afcfb23f0e2e3","modified":1610082065073},{"_id":"source/_posts/彻底理解Promise原理及全功能实现.md","hash":"906a96518503adb22a549ba65636900d84105cc3","modified":1605842503971},{"_id":"source/_posts/无博客无心情.md","hash":"16c3c1a1406ca54f1264ce970b5ddc3f0fe10c56","modified":1612329184498},{"_id":"source/_posts/一篇来自2018年4月17日的Git笔记.md","hash":"92c6cd7aab3988159ceebd4f41f3681f501d12c5","modified":1605602296685},{"_id":"source/about/index.md","hash":"9105689fa67a906e190688bdbee17b211677fbe6","modified":1603440099035},{"_id":"source/categories/index.md","hash":"6b6ac2b912947667f3e6ec4091975f7d343e2818","modified":1603440099037},{"_id":"source/_posts/这个Blog还有我.md","hash":"e5c534989513e81a8c8879b1a92c1af5a99a6aa5","modified":1609902961088},{"_id":"source/tags/index.md","hash":"c04e8cf7ca8aa9a79c958b427bce614c17e39691","modified":1603440099042},{"_id":"source/contact/index.md","hash":"8055bf0d0de9a37f5ab589d2a00d5bcb8f0099cb","modified":1603440099039},{"_id":"source/_posts/提上日程的几件事.md","hash":"3a9444587095254bb8fa4b9cd1283b27f8028d30","modified":1609903987797},{"_id":"source/_posts/Promise V8 源码分析(二).md","hash":"d9f3b6354d27ea456039ea84254bd1c333ecd7dc","modified":1607926876078},{"_id":"source/_posts/理解 JavaScript 的 async&await.md","hash":"af0667041245e7437d25c3d832aff57b9a3c80f6","modified":1605228553088},{"_id":"themes/hexo-theme-matery-master/.gitignore","hash":"5340c994462c7345373e075529f40e60c1952f00","modified":1603440099045},{"_id":"themes/hexo-theme-matery-master/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1603440099046},{"_id":"themes/hexo-theme-matery-master/README_CN.md","hash":"938e40cfb109501bf487c808e5670db3011431b9","modified":1603440099049},{"_id":"themes/hexo-theme-matery-master/README.md","hash":"bbc201f264ea3fca4ec3738728d4236626cd698a","modified":1603440099048},{"_id":"themes/hexo-theme-matery-master/languages/default.yml","hash":"9baf9370d0d7494e8575934e4bd0fa6d24484052","modified":1603440099054},{"_id":"themes/hexo-theme-matery-master/_config.yml","hash":"222b6fdf844dcd6c3cf228c6e99b73e2e1fa402a","modified":1611892342023},{"_id":"themes/hexo-theme-matery-master/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1603440099130},{"_id":"themes/hexo-theme-matery-master/languages/zh-CN.yml","hash":"13ce732a54ce08b0ca01f14fd09cbe8fc418de21","modified":1603440099055},{"_id":"themes/hexo-theme-matery-master/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1603440099057},{"_id":"themes/hexo-theme-matery-master/layout/archive.ejs","hash":"57733d52d17361e735fcc95f875e0b1b9ebdcbd8","modified":1603440099129},{"_id":"themes/hexo-theme-matery-master/layout/404.ejs","hash":"162136ceca6c95928c90a1adef8fabc2161d5c0e","modified":1603440099059},{"_id":"themes/hexo-theme-matery-master/layout/about.ejs","hash":"88e23163aae5dff7a2e7050f55c3754f0e76ae68","modified":1603440099128},{"_id":"themes/hexo-theme-matery-master/layout/category.ejs","hash":"4ac716d15d84e7c37f07308a5ec008a2ac090c9b","modified":1603440099132},{"_id":"themes/hexo-theme-matery-master/layout/contact.ejs","hash":"72fb5af3fc2f8955e2eb10926bbe4532a04ccd1b","modified":1603440099134},{"_id":"themes/hexo-theme-matery-master/layout/friends.ejs","hash":"e9716a948172e6ad46c18cc7e78770cdc46f1857","modified":1603440099135},{"_id":"themes/hexo-theme-matery-master/layout/index.ejs","hash":"3cabb8e3680858c1412277def37bdef73981be0f","modified":1603440099137},{"_id":"themes/hexo-theme-matery-master/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1603440099143},{"_id":"themes/hexo-theme-matery-master/layout/layout.ejs","hash":"e179c72cb4eef88e5168cadafa2e1c3b46fd1486","modified":1603440099138},{"_id":"themes/hexo-theme-matery-master/layout/tag.ejs","hash":"058eb27ff10f5314d8b9e334c54419b9a6572315","modified":1603440099141},{"_id":"themes/hexo-theme-matery-master/layout/post.ejs","hash":"3783bb4d7807e3a3701d67499a878c69a0a872d6","modified":1603440099140},{"_id":"themes/hexo-theme-matery-master/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1603440099152},{"_id":"themes/hexo-theme-matery-master/layout/_widget/dream.ejs","hash":"d6692f8c81013191fce59f47df1b6171649181ca","modified":1603440099110},{"_id":"themes/hexo-theme-matery-master/layout/_widget/category-cloud.ejs","hash":"3ef458166041a8a12e493cc5963a5af5d98c1dfc","modified":1603440099107},{"_id":"themes/hexo-theme-matery-master/layout/_widget/category-radar.ejs","hash":"131e2eabf6b216210efd0746300889adfee357be","modified":1603440099109},{"_id":"themes/hexo-theme-matery-master/layout/_widget/my-gallery.ejs","hash":"f5259f18a906f2862fe72b90c28125b5f6b7d0b1","modified":1603440099113},{"_id":"themes/hexo-theme-matery-master/layout/_widget/my-projects.ejs","hash":"141f19a8aa41b7a21436f23ce114bd5fda932512","modified":1603440099114},{"_id":"themes/hexo-theme-matery-master/layout/_widget/music.ejs","hash":"8fc0e6172abbed7084b06e3ed637ad37e2752c48","modified":1603440099112},{"_id":"themes/hexo-theme-matery-master/layout/_widget/my-skills.ejs","hash":"9edbeb1ec6212762d597ae7a05b5a219f72c8f98","modified":1603440099116},{"_id":"themes/hexo-theme-matery-master/layout/_widget/post-calendar.ejs","hash":"fb5ee7674070956d134ddca6890a9bd3f398cc0f","modified":1603440099117},{"_id":"themes/hexo-theme-matery-master/layout/_widget/post-charts.ejs","hash":"20f0b6155eee348276dd91790f6a52b1005a0518","modified":1603440099119},{"_id":"themes/hexo-theme-matery-master/layout/_widget/recommend.ejs","hash":"ba6f8992c44cd44585af25a283c09403b4fc0aca","modified":1603440099121},{"_id":"themes/hexo-theme-matery-master/layout/_partial/baidu-analytics.ejs","hash":"4b01030b7136192bdbd704e29a0fe12f92767551","modified":1603440099063},{"_id":"themes/hexo-theme-matery-master/layout/_partial/back-top.ejs","hash":"be527741c39c9dc4a13ad712b49fe8db0147fe1e","modified":1603440099062},{"_id":"themes/hexo-theme-matery-master/layout/_partial/baidu-push.ejs","hash":"2841870e0c625787de348221e5ddb7bbe99ec5a2","modified":1603440099064},{"_id":"themes/hexo-theme-matery-master/layout/_widget/tag-cloud.ejs","hash":"d32898104477acef56c33d00a68b48db15dcf2e6","modified":1603440099122},{"_id":"themes/hexo-theme-matery-master/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1603440099068},{"_id":"themes/hexo-theme-matery-master/layout/_widget/tag-wordcloud.ejs","hash":"03dcd0a7a9fdbcc2bc38a99a8fad96ae17a340fa","modified":1603440099124},{"_id":"themes/hexo-theme-matery-master/layout/_widget/video.ejs","hash":"6eaab5fccff9ad69d1d877a0f0585e2fcb89ba52","modified":1603440099126},{"_id":"themes/hexo-theme-matery-master/layout/_partial/bg-cover-content.ejs","hash":"58a7a07f8ab81ecc19a78d897955ca1ad73defb3","modified":1603440099066},{"_id":"themes/hexo-theme-matery-master/layout/_partial/disqus.ejs","hash":"1b392f2160f962f62f3ddf5e1155c7f2f4888e1d","modified":1603440099069},{"_id":"themes/hexo-theme-matery-master/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1603440099076},{"_id":"themes/hexo-theme-matery-master/layout/_partial/footer.ejs","hash":"78228c5e91fc2e6fed6949d971bf78a1f5081812","modified":1603440099071},{"_id":"themes/hexo-theme-matery-master/layout/_partial/gitalk.ejs","hash":"27764936791ce36b527bea63689435346bbfb425","modified":1603440099072},{"_id":"themes/hexo-theme-matery-master/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1603440099073},{"_id":"themes/hexo-theme-matery-master/layout/_partial/gitment.ejs","hash":"90888c945384aa1ee4650bd43bd7ea670f25828c","modified":1603440099075},{"_id":"themes/hexo-theme-matery-master/layout/_partial/head.ejs","hash":"adaeca6ae9064c41047c3fb4f8bd046b736ae457","modified":1603440099078},{"_id":"themes/hexo-theme-matery-master/layout/_partial/header.ejs","hash":"4bcdbd27273dd1b7098d4cfa6479b5d6b138cd12","modified":1603440099080},{"_id":"themes/hexo-theme-matery-master/layout/_partial/index-cover.ejs","hash":"6dc2522bc03b65d0b421a643b21a78a59c8213c1","modified":1603440099081},{"_id":"themes/hexo-theme-matery-master/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1603440099083},{"_id":"themes/hexo-theme-matery-master/layout/_partial/minivaline.ejs","hash":"e1264587db510ae1885405aed433592291ae74c4","modified":1603440099084},{"_id":"themes/hexo-theme-matery-master/layout/_partial/mobile-nav.ejs","hash":"8ce2974b19765e1f05d935a4f18abf7c84a980da","modified":1603440099085},{"_id":"themes/hexo-theme-matery-master/layout/_partial/navigation.ejs","hash":"5a2179a9a3de6f56b0aaa154a11919b8f34fcbf9","modified":1603440099087},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-cover.ejs","hash":"7f583c935253e2bf6421791715ee9de4989add6e","modified":1603440099090},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-detail-toc.ejs","hash":"ea50a5669847740894d5737a6330bf1013ae2e65","modified":1603440099091},{"_id":"themes/hexo-theme-matery-master/layout/_partial/paging.ejs","hash":"d8773abab5d0b672b70a9df20a8f9f7f6b0a2dae","modified":1603440099089},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-statis.ejs","hash":"de0d5763ddd64463f43135678b64c044884b8406","modified":1603440099094},{"_id":"themes/hexo-theme-matery-master/layout/_partial/share.ejs","hash":"e50fae64b6cfdbed18861eb49eca5018a920c7a4","modified":1603440099102},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-detail.ejs","hash":"8ad8a7ec3f6438af496c51fd6bef1684e158a9ef","modified":1603440099093},{"_id":"themes/hexo-theme-matery-master/layout/_partial/reprint-statement.ejs","hash":"f67bc52bc5a2464ebe30f42c65c0ee38eeec2fda","modified":1603440099097},{"_id":"themes/hexo-theme-matery-master/layout/_partial/prev-next.ejs","hash":"908ddab5b5d5662c50b46ada0e03e06fe0a6c310","modified":1603440099096},{"_id":"themes/hexo-theme-matery-master/layout/_partial/search.ejs","hash":"c5f1a2de30363f370c8c37994140d6ef4fd0c4b7","modified":1603440099101},{"_id":"themes/hexo-theme-matery-master/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1603440099146},{"_id":"themes/hexo-theme-matery-master/source/css/matery.css","hash":"3d1d884dd41b54bf39142b565a3ca5bdfdd1775f","modified":1607561851373},{"_id":"themes/hexo-theme-matery-master/source/css/my.css","hash":"b3c32b573a4a9ef3dfeffbd544a9c3f451e67a54","modified":1603440099151},{"_id":"themes/hexo-theme-matery-master/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1603440099149},{"_id":"themes/hexo-theme-matery-master/layout/_partial/reward.ejs","hash":"90c2ab31492f8226454537d6b987e9399119047d","modified":1603440099099},{"_id":"themes/hexo-theme-matery-master/layout/_partial/social-link.ejs","hash":"f640583d45179abc1ef57951e7f61fb9e10f44c9","modified":1603440099103},{"_id":"themes/hexo-theme-matery-master/layout/_partial/valine.ejs","hash":"ef335be75e3f26580583af8699b8497f350ae200","modified":1603440099105},{"_id":"themes/hexo-theme-matery-master/source/js/matery.js","hash":"ddfef10e80a09b8efb48c52ede773e71d5890c78","modified":1603440099154},{"_id":"themes/hexo-theme-matery-master/source/js/search.js","hash":"b4e7a09c79aecaa859032a7f39c25d2f6692e75a","modified":1603441088246},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1609127654394},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.png","hash":"d7a23545057457fd2b18a8be4043bd85c7fa133f","modified":1605253551274},{"_id":"themes/hexo-theme-matery-master/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1603440099387},{"_id":"themes/hexo-theme-matery-master/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1603440099465},{"_id":"themes/hexo-theme-matery-master/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1603440099464},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1609127654381},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1609127654381},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1609127654377},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/10.jpg","hash":"1ff884e3490fd62df03d8105ceb1909fd37cdf13","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/11.jpg","hash":"69a08011a66b1c99326fb620d3cf40037339b4f4","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/13.jpg","hash":"5ce6744e22001ea3ae92ffe02e98f4c089154062","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/16.jpg","hash":"646bc66b15a68bf64a9903badd955496032a08ee","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/15.jpg","hash":"4554279261a8c6f82d05870f64508a415f45ca3f","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1609127654377},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/20.jpg","hash":"3b85e9a6c2b9603f78e98b894d93f73c3a7c3930","modified":1609127654381},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/21.jpg","hash":"54c2c4f4a15b36338ad9a476659746769132c1e5","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/23.jpg","hash":"3faaa5e369131266816dc5b3997ca89daca14f1e","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/22.jpg","hash":"e05e65785ebde483efd5d5b651a7a66b924cd0e5","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1603440099158},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/7.jpg","hash":"7deaceeb3fe6bd548b44f1e8e78f50ed492fa8c4","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/6.jpg","hash":"921658d29cfd2f6124e51782725e36da6cc21c23","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1603440099161},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1603440099164},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/8.jpg","hash":"afb00784bdf0f820f9734880565de6a35a4696db","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/alipay.jpg","hash":"9cfc1f6338bc41f1c38c84702fad893810c8b9ae","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1603440099470},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1603440099163},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1603440099166},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-dynamic.js","hash":"8f53dbd5f9a40c377664bf8ca0d5d5ed75b91757","modified":1603440099238},{"_id":"themes/hexo-theme-matery-master/source/libs/background/canvas-nest.js","hash":"d2569ef80127ed2f4af7ef4d9f82b037794eec69","modified":1603440099236},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1603440099256},{"_id":"themes/hexo-theme-matery-master/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1603440099254},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.css","hash":"9c0bacfbd4519d3859e3bbb06128ba241804d8b1","modified":1603440099270},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1603440099243},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1603440099242},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1603440099280},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1603440099290},{"_id":"themes/hexo-theme-matery-master/source/libs/instantpage/instantpage.js","hash":"043eba3c85c2e2009a9fabf3c4fc55537852fd86","modified":1603440099286},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeBlockFuction.js","hash":"a8133367d48199e7505c2d831ca848b4202b9ba6","modified":1603440099245},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeShrink.js","hash":"3edbe498f7bb9e7daa77f9db30e1b5eeab40e067","modified":1603440099251},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeLang.js","hash":"066d2c89ad429e44f6467b9267da782ccaad57de","modified":1603440099250},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1603440099288},{"_id":"themes/hexo-theme-matery-master/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1603440099315},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.css","hash":"9783581bec83e6bd6cd279f0af23a2862f46a587","modified":1603440099344},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeCopy.js","hash":"6ab7871d36cab438bbd4d781bc1fe7618b46b6e7","modified":1603440099248},{"_id":"themes/hexo-theme-matery-master/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1603440099326},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1603440099345},{"_id":"themes/hexo-theme-matery-master/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1603440099322},{"_id":"themes/hexo-theme-matery-master/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1603440099324},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1603440099195},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1603440099202},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1603440099203},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1603440099295},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1603440099200},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1603440099306},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1603440099305},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1603440099308},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1603440099309},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1603440099298},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1603440099301},{"_id":"themes/hexo-theme-matery-master/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1603440099329},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1603440099302},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1603440099332},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.svg","hash":"67d261ac428761389c895e1da73664e633e14a72","modified":1603440099299},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1603440099312},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/social-share.min.js","hash":"ba635a17a9d9d132369f9fe4b1fbcaf001ea6ac9","modified":1603440099341},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1603440099335},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/jquery.share.min.js","hash":"de34668d902ec082d17ddb6dd7ad24255fb547c5","modified":1603440099339},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1603440099334},{"_id":"themes/hexo-theme-matery-master/source/medias/cover.jpg","hash":"3c672af6b05588eda34fc0b07c0f24754713fbd9","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1609127654393},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/14.jpg","hash":"7ec0b8c6f4ffabe4c0c71face3b4a6964bc55c39","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/17.jpg","hash":"699bc6439f799b0e3648a1e0300beead8df29bd1","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/12.jpg","hash":"6c6d964c076c9beedcc57a238fc263810e34b841","modified":1609127654393},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/19.jpg","hash":"ec6e0a03fb1f482723fb3be891f6107e04431e26","modified":1609127654394},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1603440099336},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1603440099258},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1603440099282},{"_id":"themes/hexo-theme-matery-master/source/libs/jquery/jquery.min.js","hash":"a8927ac2830b2fdd4a729eb0eb7f80923539ceb9","modified":1603440099293},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/css/all.css","hash":"6390d0a6e6211ebbd68b49759b4dec8b2a9f04c9","modified":1603440099170},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/Valine.min.js","hash":"d6c03e8c3e547b5f48878081d10559b80f626948","modified":1603440099349},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1603440099175},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1603440099190},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1603440099187},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1603440099234},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1603440099193},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1603440099227},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/6.jpg","hash":"0544de7906cae1d501bdb54da24cdebf526036a0","modified":1610180828519},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.min.js","hash":"7a3534269fd922d722a76c3affefc68e21246898","modified":1603440099278},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1603440099317},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1603440099320},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/av-min.js","hash":"9cb4babc20eb8fb5a86c4b0cc894fdb0f3cd9534","modified":1603440099352},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1603440099198},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1603440099224},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1603440099209},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1603440099183},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1603440099219},{"_id":"themes/hexo-theme-matery-master/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1603440099268},{"_id":"public/search.xml","hash":"118979428e0a1824d82e84ad1d8c9c1db31379df","modified":1612329203306},{"_id":"public/404.html","hash":"3a28386afac809cb7b97b507cfbbc488d31e42d3","modified":1612329203306},{"_id":"public/contact/index.html","hash":"4b4c6f2fc6c299fe15ffdc50711b99b294c47c80","modified":1612329203306},{"_id":"public/categories/index.html","hash":"9c02ff6392c77291fa9db90faf72dcd6554ead42","modified":1612329203306},{"_id":"public/about/index.html","hash":"8f4fff6f59c7982595e4b2f9d1de963629d5c7dd","modified":1612329203306},{"_id":"public/tags/index.html","hash":"2f4574eb7281e80a42909ca18908bdf56b9b35b9","modified":1612329203306},{"_id":"public/2021/01/28/无博客无心情/index.html","hash":"2e713d7f2b9ae8dac1f6ac2d2406687cee9c36e3","modified":1612329203306},{"_id":"public/2021/01/08/LeetCode 70 Climb Stairs/index.html","hash":"3d464e41e08c4df1e7e027388a973692d780dff6","modified":1612329203306},{"_id":"public/2021/01/08/LeetCode 64 Minimum Path Sum/index.html","hash":"1431b16f90a851685bc757bbf770c6834c1a8863","modified":1612329203306},{"_id":"public/2020/12/14/Promise V8 源码分析(二)/index.html","hash":"42a10939c32b1751d86869f2bc7e41f542f573a2","modified":1612329203306},{"_id":"public/2020/11/20/彻底理解Promise原理及全功能实现/index.html","hash":"f8d94e993e7882ee0616080f8e71d768a46b633e","modified":1612329203306},{"_id":"public/2020/11/17/提上日程的几件事/index.html","hash":"cfc65906fe8e976f0eedf92e31ad2bde4c553998","modified":1612329203306},{"_id":"public/2020/11/13/理解 JavaScript 的 async&await/index.html","hash":"63788057294c0ed93bdc0171dc6599c462b75ed7","modified":1612329203306},{"_id":"public/2020/11/09/一篇来自2018年4月17日的Git笔记/index.html","hash":"a2917b674282f00c0cfde671160f5bc59d157537","modified":1612329203306},{"_id":"public/2020/11/07/这个Blog还有我/index.html","hash":"e0b027b30aae26e2cf75d5261d0a9a505aa807e9","modified":1612329203306},{"_id":"public/2020/10/22/使用CSDN-markdown编辑器/index.html","hash":"b0a3349038ceb91308617034e89118196005c4bf","modified":1612329203306},{"_id":"public/archives/index.html","hash":"16857ed675a4a0a5976ad11bcfe56be571ac5238","modified":1612329203306},{"_id":"public/archives/2020/index.html","hash":"6cb0c3f1f415fa2060f59bffa0890f4f02b61bfb","modified":1612329203306},{"_id":"public/archives/2020/10/index.html","hash":"89892f73b89d7c5213df26b14f6db003b00a33c7","modified":1612329203306},{"_id":"public/archives/2020/11/index.html","hash":"4b158834512ad20c4f8c955a929230a87a6c9c04","modified":1612329203306},{"_id":"public/archives/2020/12/index.html","hash":"1763c14b7a2b01d001eb9651759a80d5d6b69639","modified":1612329203306},{"_id":"public/archives/2021/index.html","hash":"06a1c46cbd0f9d877a25c14eb196405dcd9d4e43","modified":1612329203306},{"_id":"public/archives/2021/01/index.html","hash":"a533c21b7b302a483479e072fa2c999907dcf6b1","modified":1612329203306},{"_id":"public/categories/技术/index.html","hash":"8bb7c9d0776c7e43ae481a77ceac1c3cf3320e63","modified":1612329203306},{"_id":"public/categories/Markdown/index.html","hash":"c186aa2120fc9c1b1b915afc12540067bcbda3c8","modified":1612329203306},{"_id":"public/categories/Git/index.html","hash":"5c7606da0fd86d95f3e63fc579a7d5eef8e25ccc","modified":1612329203306},{"_id":"public/categories/随笔/index.html","hash":"2533ef4e824c8c640facb3e0cec195d2ea114f58","modified":1612329203306},{"_id":"public/categories/致来访者/index.html","hash":"b41a3809e9b1435a6f35fa7903ac839df858d7b5","modified":1612329203306},{"_id":"public/index.html","hash":"22a3e7ad4222c993e99143f9f64299601892ba56","modified":1612329203306},{"_id":"public/tags/JavaScript/index.html","hash":"92da153f089898a65b9fb88cbcf2ea487351c089","modified":1612329203306},{"_id":"public/tags/LeetCode/index.html","hash":"7dded5ba2eb3f220f2a3a0aa115df89454fe48a4","modified":1612329203306},{"_id":"public/tags/学习总结/index.html","hash":"e78bf0095cd915f70e01cc8e584ac25e46dcc863","modified":1612329203306},{"_id":"public/tags/Typora/index.html","hash":"2671c4309c36aa191c76dce41975b7cc38b89213","modified":1612329203306},{"_id":"public/tags/Markdown/index.html","hash":"81a61f08d365e7f05fde675db9b23aa2318fb62c","modified":1612329203306},{"_id":"public/tags/Git/index.html","hash":"ffc3cace0aa400eafb4b2f35865fee3752f9084a","modified":1612329203306},{"_id":"public/tags/随笔/index.html","hash":"b0c55fad04b01b2919b320c67fceb2311ad7398a","modified":1612329203306},{"_id":"public/tags/个人简介/index.html","hash":"1a9c16aaf674940c3b959eb4a60fb86e86f9fe95","modified":1612329203306},{"_id":"public/tags/博客简介/index.html","hash":"4e820d943d141032fe00b708357b5332e5f9b5bc","modified":1612329203306},{"_id":"public/tags/转载/index.html","hash":"e1933853d3103716a0792dac45a0cac0e5f547dd","modified":1612329203306},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1612329203306},{"_id":"public/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1612329203306},{"_id":"public/medias/avatar.png","hash":"d7a23545057457fd2b18a8be4043bd85c7fa133f","modified":1612329203306},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1612329203306},{"_id":"public/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1612329203306},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1612329203306},{"_id":"public/medias/banner/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1612329203306},{"_id":"public/medias/banner/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1612329203306},{"_id":"public/medias/banner/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1612329203306},{"_id":"public/medias/banner/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1612329203306},{"_id":"public/medias/featureimages/10.jpg","hash":"1ff884e3490fd62df03d8105ceb1909fd37cdf13","modified":1612329203306},{"_id":"public/medias/featureimages/13.jpg","hash":"5ce6744e22001ea3ae92ffe02e98f4c089154062","modified":1612329203306},{"_id":"public/medias/featureimages/16.jpg","hash":"646bc66b15a68bf64a9903badd955496032a08ee","modified":1612329203306},{"_id":"public/medias/reward/alipay.jpg","hash":"9cfc1f6338bc41f1c38c84702fad893810c8b9ae","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1612329203306},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1612329203306},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1612329203306},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1612329203306},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1612329203306},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1612329203306},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1612329203306},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1612329203306},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"67d261ac428761389c895e1da73664e633e14a72","modified":1612329203306},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1612329203306},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1612329203306},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1612329203306},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1612329203306},{"_id":"public/css/prism-tomorrow.css","hash":"733208631ad1ebf0ba27f7e6f02eb11414d4e284","modified":1612329203306},{"_id":"public/medias/banner/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1612329203306},{"_id":"public/medias/featureimages/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1612329203306},{"_id":"public/medias/banner/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1612329203306},{"_id":"public/medias/featureimages/17.jpg","hash":"699bc6439f799b0e3648a1e0300beead8df29bd1","modified":1612329203306},{"_id":"public/medias/featureimages/15.jpg","hash":"4554279261a8c6f82d05870f64508a415f45ca3f","modified":1612329203306},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1612329203306},{"_id":"public/medias/featureimages/19.jpg","hash":"ec6e0a03fb1f482723fb3be891f6107e04431e26","modified":1612329203306},{"_id":"public/medias/featureimages/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1612329203306},{"_id":"public/medias/featureimages/20.jpg","hash":"3b85e9a6c2b9603f78e98b894d93f73c3a7c3930","modified":1612329203306},{"_id":"public/medias/featureimages/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1612329203306},{"_id":"public/medias/featureimages/21.jpg","hash":"54c2c4f4a15b36338ad9a476659746769132c1e5","modified":1612329203306},{"_id":"public/medias/featureimages/23.jpg","hash":"3faaa5e369131266816dc5b3997ca89daca14f1e","modified":1612329203306},{"_id":"public/medias/featureimages/22.jpg","hash":"e05e65785ebde483efd5d5b651a7a66b924cd0e5","modified":1612329203306},{"_id":"public/medias/featureimages/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1612329203306},{"_id":"public/medias/featureimages/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1612329203306},{"_id":"public/medias/featureimages/7.jpg","hash":"7deaceeb3fe6bd548b44f1e8e78f50ed492fa8c4","modified":1612329203306},{"_id":"public/medias/featureimages/6.jpg","hash":"921658d29cfd2f6124e51782725e36da6cc21c23","modified":1612329203306},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1612329203306},{"_id":"public/medias/featureimages/8.jpg","hash":"afb00784bdf0f820f9734880565de6a35a4696db","modified":1612329203306},{"_id":"public/medias/featureimages/11.jpg","hash":"69a08011a66b1c99326fb620d3cf40037339b4f4","modified":1612329203306},{"_id":"public/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1612329203306},{"_id":"public/medias/cover.jpg","hash":"3c672af6b05588eda34fc0b07c0f24754713fbd9","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1612329203306},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1612329203306},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1612329203306},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1612329203306},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1612329203306},{"_id":"public/js/search.js","hash":"f49c329e6b1f98a228426876356c945e8dce7e8e","modified":1612329203306},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1612329203306},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1612329203306},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1612329203306},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1612329203306},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1612329203306},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1612329203306},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1612329203306},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1612329203306},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1612329203306},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1612329203306},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1612329203306},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1612329203306},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1612329203306},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1612329203306},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1612329203306},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1612329203306},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1612329203306},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1612329203306},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1612329203306},{"_id":"public/medias/featureimages/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1612329203306},{"_id":"public/medias/featureimages/14.jpg","hash":"7ec0b8c6f4ffabe4c0c71face3b4a6964bc55c39","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1612329203306},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1612329203306},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1612329203306},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1612329203306},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1612329203306},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1612329203306},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1612329203306},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1612329203306},{"_id":"public/medias/featureimages/12.jpg","hash":"6c6d964c076c9beedcc57a238fc263810e34b841","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1612329203306},{"_id":"public/css/matery.css","hash":"104b1b2582d2cd9321e4a9d529e6854f8bd91ff5","modified":1612329203306},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1612329203306},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1612329203306},{"_id":"public/medias/banner/6.jpg","hash":"0544de7906cae1d501bdb54da24cdebf526036a0","modified":1612329203306},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1612329203306},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1612329203306},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1612329203306},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1612329203306},{"_id":"public/libs/valine/Valine.min.js","hash":"6cbdbf91e1f046dd41267a5ff0691a1fccba99df","modified":1612329203306},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1612329203306},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1612329203306},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1612329203306},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1612329203306},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1612329203306},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1612329203306},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1612329203306},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1612329203306},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1612329203306}],"Category":[{"name":"技术","_id":"ckkoz6g6l0004bwr4gk057ldy"},{"name":"Markdown","_id":"ckkoz6g6u000gbwr44kvjdhdl"},{"name":"Git","_id":"ckkoz6g6w000lbwr422l21fu7"},{"name":"随笔","_id":"ckkoz6g6x000qbwr4fyls0nz6"},{"name":"致来访者","_id":"ckkoz6g6z000ybwr4go2yh89k"}],"Data":[],"Page":[{"title":"404","date":"2020-10-22T08:47:30.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2020-10-22 16:47:30\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---","updated":"2020-10-23T08:01:39.030Z","path":"404.html","comments":1,"_id":"ckkoz6g6f0000bwr46ekz08yw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2020-10-22T08:35:24.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-10-22 16:35:24\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2020-10-23T08:01:39.037Z","path":"categories/index.html","comments":1,"_id":"ckkoz6g6k0002bwr43upu2a52","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2020-10-22T08:42:02.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-10-22 16:42:02\ntype: \"about\"\nlayout: \"about\"\n---","updated":"2020-10-23T08:01:39.035Z","path":"about/index.html","comments":1,"_id":"ckkoz6g6n0006bwr4fgbe2qe3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-10-22T08:41:08.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-10-22 16:41:08\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2020-10-23T08:01:39.042Z","path":"tags/index.html","comments":1,"_id":"ckkoz6g6p0008bwr401klc23b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"contact","date":"2020-10-22T08:44:33.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-10-22 16:44:33\ntype: \"contact\"\nlayout: \"contact\"\n---","updated":"2020-10-23T08:01:39.039Z","path":"contact/index.html","comments":1,"_id":"ckkoz6g6q000abwr484prayao","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"LeetCode 70 Climb Stairs","date":"2021-01-08T06:32:27.000Z","author":"heyXiao","summary":"LeetCode 题目总结","_content":"\n## 代码\n\n### [LeetCode 70](https://leetcode.com/problems/climbing-stairs/) ###\n    var climbStairs = function(n) {\n    \tif (n >= 1 && n <= 3) {\n    \t\treturn n\n    \t}\n    \t// 第一种 递归\n    \tlet arr = [0, 1, 2, 3]\n    \tfor (let i = 4; i <= n; i++) {\n    \t\tarr.push(arr[i - 1] + arr[i - 2])\n    \t}\n    \treturn arr[n]\n\n    \t// 第二种 斐波那契优化\n    \tvar a = 1,\n    \t\tb = 1;\n    \twhile (--n > 0) {\n    \t\tb = b + a;\n    \t\ta = b - a;\n    \t}\n    \treturn b;\n\n    \t// 第三种 不知道为什么...\n    \tvar sqrt5 = Math.sqrt(5);\n    \tvar fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    \treturn (fibn / sqrt5);\n    }\n    climbStairs(10)\n","source":"_posts/LeetCode 70 Climb Stairs.md","raw":"---\ntitle: LeetCode 70 Climb Stairs\ndate: 2021-01-08 14:32:27\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: LeetCode 题目总结\ncategories: 技术\ntags:\n  - JavaScript\n  - LeetCode\n  - 学习总结\n---\n\n## 代码\n\n### [LeetCode 70](https://leetcode.com/problems/climbing-stairs/) ###\n    var climbStairs = function(n) {\n    \tif (n >= 1 && n <= 3) {\n    \t\treturn n\n    \t}\n    \t// 第一种 递归\n    \tlet arr = [0, 1, 2, 3]\n    \tfor (let i = 4; i <= n; i++) {\n    \t\tarr.push(arr[i - 1] + arr[i - 2])\n    \t}\n    \treturn arr[n]\n\n    \t// 第二种 斐波那契优化\n    \tvar a = 1,\n    \t\tb = 1;\n    \twhile (--n > 0) {\n    \t\tb = b + a;\n    \t\ta = b - a;\n    \t}\n    \treturn b;\n\n    \t// 第三种 不知道为什么...\n    \tvar sqrt5 = Math.sqrt(5);\n    \tvar fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    \treturn (fibn / sqrt5);\n    }\n    climbStairs(10)\n","slug":"LeetCode 70 Climb Stairs","published":1,"updated":"2021-01-08T06:35:52.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6i0001bwr4869j5y1i","content":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-70\"><a href=\"#LeetCode-70\" class=\"headerlink\" title=\"LeetCode 70\"></a><a href=\"https://leetcode.com/problems/climbing-stairs/\">LeetCode 70</a></h3><pre><code>var climbStairs = function(n) &#123;\n    if (n &gt;= 1 &amp;&amp; n &lt;= 3) &#123;\n        return n\n    &#125;\n    // 第一种 递归\n    let arr = [0, 1, 2, 3]\n    for (let i = 4; i &lt;= n; i++) &#123;\n        arr.push(arr[i - 1] + arr[i - 2])\n    &#125;\n    return arr[n]\n\n    // 第二种 斐波那契优化\n    var a = 1,\n        b = 1;\n    while (--n &gt; 0) &#123;\n        b = b + a;\n        a = b - a;\n    &#125;\n    return b;\n\n    // 第三种 不知道为什么...\n    var sqrt5 = Math.sqrt(5);\n    var fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    return (fibn / sqrt5);\n&#125;\nclimbStairs(10)</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-70\"><a href=\"#LeetCode-70\" class=\"headerlink\" title=\"LeetCode 70\"></a><a href=\"https://leetcode.com/problems/climbing-stairs/\">LeetCode 70</a></h3><pre><code>var climbStairs = function(n) &#123;\n    if (n &gt;= 1 &amp;&amp; n &lt;= 3) &#123;\n        return n\n    &#125;\n    // 第一种 递归\n    let arr = [0, 1, 2, 3]\n    for (let i = 4; i &lt;= n; i++) &#123;\n        arr.push(arr[i - 1] + arr[i - 2])\n    &#125;\n    return arr[n]\n\n    // 第二种 斐波那契优化\n    var a = 1,\n        b = 1;\n    while (--n &gt; 0) &#123;\n        b = b + a;\n        a = b - a;\n    &#125;\n    return b;\n\n    // 第三种 不知道为什么...\n    var sqrt5 = Math.sqrt(5);\n    var fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    return (fibn / sqrt5);\n&#125;\nclimbStairs(10)</code></pre>\n"},{"title":"LeetCode 64 Minimum Path Sum","date":"2021-01-08T03:50:22.000Z","author":"heyXiao","summary":"LeetCode 题目总结","_content":"## 代码 ##\n\n### [LeetCode 64](https://leetcode.com/problems/minimum-path-sum/) ###\n\tvar minPathSum = function(grid) {\n\t\t// 如果阵列长度为0\n\t\tif (!grid.length) {\n\t\t\treturn 0\n\t\t}\n\t\t// grid 为\n\t\t// [1, 3, 1],\n\t\t// [1, 5, 6],\n\t\t// [4, 2, 1],\n\t\n\t\t// 初始化一个二维数组,存储路径和\n\t\tlet dp = [[]];\n\t\n\t\t// dp[0] 赋值 grid[0] 路径和 (第一行)\n\t\t// grid[0] == [1, 3, 1];\n\t\t// dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n\t\t// dp[0] == [1, 4, 5];\n\t\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < grid[0].length; i++) {\n\t\t\tsum += grid[0][i]\n\t\t\tdp[0].push(sum)\n\t\t}\n\t\n\t\t// dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n\t\t// 赋值过后 dp 为 \n\t\t// [1, 4, 5],\n\t\t// [2, A, B],\n\t\t// [6, C, D]\n\t\t// 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n\t\tlet sum2 = dp[0][0];\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tsum2 += grid[i][0];\n\t\t\tdp[i] = [];\n\t\t\tdp[i].push(sum2);\n\t\t}\n\t\t// dp\t\t\t\t//grid\n\t\t// [1, 4, 5],\t\t// [1, 3, 1],\n\t\t// [2, A, B],\t\t// [1, 5, 6],\n\t\t// [6, C, D]\t\t// [4, 2, 1]\n\t\t// 计算 A, B, C, D 四个点的路径和\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tfor (let j = 1; j < grid[0].length; j++) {\n\t\t\t\t// 比较右和下两个方向路径和的值,取最小\n\t\t\t\t// 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2, \n\t\t\t\t// 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\t\t\t}\n\t\t}\n\t\t// 最终结果\n\t\t// [1, 4, 5],\n\t\t// [2, 7, 11],\n\t\t// [6, 8, 9]\n\t\t// 取右下角值 结果为 9\n\t\treturn dp[dp.length - 1][dp[0].length - 1]\n\t}\n\tminPathSum([\n\t\t[1, 3, 1],\n\t\t[1, 5, 6],\n\t\t[4, 2, 1],\n\t])\n### 做什么 ###\n一开始只是写LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。","source":"_posts/LeetCode 64 Minimum Path Sum.md","raw":"---\ntitle: LeetCode 64 Minimum Path Sum\ndate: 2021-01-08 11:50:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: LeetCode 题目总结\ncategories: 技术\ntags:\n  - JavaScript\n  - LeetCode\n  - 学习总结\n---\n## 代码 ##\n\n### [LeetCode 64](https://leetcode.com/problems/minimum-path-sum/) ###\n\tvar minPathSum = function(grid) {\n\t\t// 如果阵列长度为0\n\t\tif (!grid.length) {\n\t\t\treturn 0\n\t\t}\n\t\t// grid 为\n\t\t// [1, 3, 1],\n\t\t// [1, 5, 6],\n\t\t// [4, 2, 1],\n\t\n\t\t// 初始化一个二维数组,存储路径和\n\t\tlet dp = [[]];\n\t\n\t\t// dp[0] 赋值 grid[0] 路径和 (第一行)\n\t\t// grid[0] == [1, 3, 1];\n\t\t// dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n\t\t// dp[0] == [1, 4, 5];\n\t\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < grid[0].length; i++) {\n\t\t\tsum += grid[0][i]\n\t\t\tdp[0].push(sum)\n\t\t}\n\t\n\t\t// dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n\t\t// 赋值过后 dp 为 \n\t\t// [1, 4, 5],\n\t\t// [2, A, B],\n\t\t// [6, C, D]\n\t\t// 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n\t\tlet sum2 = dp[0][0];\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tsum2 += grid[i][0];\n\t\t\tdp[i] = [];\n\t\t\tdp[i].push(sum2);\n\t\t}\n\t\t// dp\t\t\t\t//grid\n\t\t// [1, 4, 5],\t\t// [1, 3, 1],\n\t\t// [2, A, B],\t\t// [1, 5, 6],\n\t\t// [6, C, D]\t\t// [4, 2, 1]\n\t\t// 计算 A, B, C, D 四个点的路径和\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tfor (let j = 1; j < grid[0].length; j++) {\n\t\t\t\t// 比较右和下两个方向路径和的值,取最小\n\t\t\t\t// 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2, \n\t\t\t\t// 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\t\t\t}\n\t\t}\n\t\t// 最终结果\n\t\t// [1, 4, 5],\n\t\t// [2, 7, 11],\n\t\t// [6, 8, 9]\n\t\t// 取右下角值 结果为 9\n\t\treturn dp[dp.length - 1][dp[0].length - 1]\n\t}\n\tminPathSum([\n\t\t[1, 3, 1],\n\t\t[1, 5, 6],\n\t\t[4, 2, 1],\n\t])\n### 做什么 ###\n一开始只是写LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。","slug":"LeetCode 64 Minimum Path Sum","published":1,"updated":"2021-01-08T05:01:05.073Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6k0003bwr4623oedfu","content":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-64\"><a href=\"#LeetCode-64\" class=\"headerlink\" title=\"LeetCode 64\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\">LeetCode 64</a></h3><pre><code>var minPathSum = function(grid) &#123;\n    // 如果阵列长度为0\n    if (!grid.length) &#123;\n        return 0\n    &#125;\n    // grid 为\n    // [1, 3, 1],\n    // [1, 5, 6],\n    // [4, 2, 1],\n\n    // 初始化一个二维数组,存储路径和\n    let dp = [[]];\n\n    // dp[0] 赋值 grid[0] 路径和 (第一行)\n    // grid[0] == [1, 3, 1];\n    // dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n    // dp[0] == [1, 4, 5];\n\n    let sum = 0;\n    for (let i = 0; i &lt; grid[0].length; i++) &#123;\n        sum += grid[0][i]\n        dp[0].push(sum)\n    &#125;\n\n    // dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n    // 赋值过后 dp 为 \n    // [1, 4, 5],\n    // [2, A, B],\n    // [6, C, D]\n    // 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n    let sum2 = dp[0][0];\n    for (let i = 1; i &lt; grid.length; i++) &#123;\n        sum2 += grid[i][0];\n        dp[i] = [];\n        dp[i].push(sum2);\n    &#125;\n    // dp                //grid\n    // [1, 4, 5],        // [1, 3, 1],\n    // [2, A, B],        // [1, 5, 6],\n    // [6, C, D]        // [4, 2, 1]\n    // 计算 A, B, C, D 四个点的路径和\n    for (let i = 1; i &lt; grid.length; i++) &#123;\n        for (let j = 1; j &lt; grid[0].length; j++) &#123;\n            // 比较右和下两个方向路径和的值,取最小\n            // 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2, \n            // 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        &#125;\n    &#125;\n    // 最终结果\n    // [1, 4, 5],\n    // [2, 7, 11],\n    // [6, 8, 9]\n    // 取右下角值 结果为 9\n    return dp[dp.length - 1][dp[0].length - 1]\n&#125;\nminPathSum([\n    [1, 3, 1],\n    [1, 5, 6],\n    [4, 2, 1],\n])</code></pre>\n<h3 id=\"做什么\"><a href=\"#做什么\" class=\"headerlink\" title=\"做什么\"></a>做什么</h3><p>一开始只是写LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-64\"><a href=\"#LeetCode-64\" class=\"headerlink\" title=\"LeetCode 64\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\">LeetCode 64</a></h3><pre><code>var minPathSum = function(grid) &#123;\n    // 如果阵列长度为0\n    if (!grid.length) &#123;\n        return 0\n    &#125;\n    // grid 为\n    // [1, 3, 1],\n    // [1, 5, 6],\n    // [4, 2, 1],\n\n    // 初始化一个二维数组,存储路径和\n    let dp = [[]];\n\n    // dp[0] 赋值 grid[0] 路径和 (第一行)\n    // grid[0] == [1, 3, 1];\n    // dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n    // dp[0] == [1, 4, 5];\n\n    let sum = 0;\n    for (let i = 0; i &lt; grid[0].length; i++) &#123;\n        sum += grid[0][i]\n        dp[0].push(sum)\n    &#125;\n\n    // dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n    // 赋值过后 dp 为 \n    // [1, 4, 5],\n    // [2, A, B],\n    // [6, C, D]\n    // 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n    let sum2 = dp[0][0];\n    for (let i = 1; i &lt; grid.length; i++) &#123;\n        sum2 += grid[i][0];\n        dp[i] = [];\n        dp[i].push(sum2);\n    &#125;\n    // dp                //grid\n    // [1, 4, 5],        // [1, 3, 1],\n    // [2, A, B],        // [1, 5, 6],\n    // [6, C, D]        // [4, 2, 1]\n    // 计算 A, B, C, D 四个点的路径和\n    for (let i = 1; i &lt; grid.length; i++) &#123;\n        for (let j = 1; j &lt; grid[0].length; j++) &#123;\n            // 比较右和下两个方向路径和的值,取最小\n            // 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2, \n            // 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n        &#125;\n    &#125;\n    // 最终结果\n    // [1, 4, 5],\n    // [2, 7, 11],\n    // [6, 8, 9]\n    // 取右下角值 结果为 9\n    return dp[dp.length - 1][dp[0].length - 1]\n&#125;\nminPathSum([\n    [1, 3, 1],\n    [1, 5, 6],\n    [4, 2, 1],\n])</code></pre>\n<h3 id=\"做什么\"><a href=\"#做什么\" class=\"headerlink\" title=\"做什么\"></a>做什么</h3><p>一开始只是写LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。</p>\n"},{"title":"这是我的第一篇博客","date":"2020-10-22T05:25:00.000Z","author":"heyXiao","summary":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。","_content":"# 这是我的第一篇博客\n\n- **Markdown和扩展Markdown简洁的语法**\n- **代码块高亮**\n- **图片链接和图片上传**\n- ***LaTex*数学公式**\n- **UML序列图和流程图**\n- **离线写博客**\n- **导入导出Markdown文件**\n- **丰富的快捷键**\n\n-------------------\n\n## 快捷键\n\n - 加粗    `Ctrl + B` \n - 斜体    `Ctrl + I` \n - 引用    `Ctrl + Q`\n - 插入链接    `Ctrl + L`\n - 插入代码    `Ctrl + K`\n - 插入图片    `Ctrl + G`\n - 提升标题    `Ctrl + H`\n - 有序列表    `Ctrl + O`\n - 无序列表    `Ctrl + U`\n - 横线    `Ctrl + R`\n - 撤销    `Ctrl + Z`\n - 重做    `Ctrl + Y`\n\n## Markdown及扩展\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]\n\n使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.csdn.net)等，详细语法参考帮助？。\n\n本编辑器支持 **Markdown Extra** , 　扩展了很多好用的功能。具体请参考[Github][2].  \n\n### 表格\n\n**Markdown　Extra**　表格语法：\n\n项目     | 价格\n-------- | ---\nComputer | $1600\nPhone    | $12\nPipe     | $1\n\n可以使用冒号来定义对齐方式：\n\n| 项目      |    价格 | 数量  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 元 |  5   |\n| Phone     |   12 元 |  12  |\n| Pipe      |    1 元 | 234  |\n\n###定义列表\n\n**Markdown　Extra**　定义列表语法：\n项目１\n项目２\n:   定义 A\n:   定义 B\n\n项目３\n:   定义 C\n\n:   定义 D\n\n\t> 定义D内容\n\n### 代码块\n代码块语法遵循标准markdown代码，例如：\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n>>> message = '''interpreter\n... prompt'''\n```\n\n###脚注\n生成一个脚注[^footnote].\n  [^footnote]: 这里是 **脚注** 的 *内容*.\n  \n### 目录\n用 `[TOC]`来生成目录：\n\n@[toc]\n### 数学公式\n使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].\n\n - 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。\n - 块级公式：\n\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n更多LaTex语法请参考 [这儿][3].\n\n### UML 图:\n\n可以渲染序列图：\n\n```mermaid\nsequenceDiagram\n张三->>李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->>张三: 忙得吐血，哪有时间写。\n```\n\n或者流程图：\n\n```mermaid\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n- 关于 **序列图** 语法，参考 [这儿][4],\n- 关于 **流程图** 语法，参考 [这儿][5].\n\n## 离线写博客\n\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入[write.blog.csdn.net/mdeditor](http://write.blog.csdn.net/mdeditor)即可。**Markdown编辑器**使用浏览器离线存储将内容保存在本地。\n\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\n\n博客发表后，本地缓存将被删除。　\n\n用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\n\n> **注意：**虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，**请务必及时发表或者保存到服务器草稿箱**。\n\n##浏览器兼容\n\n 1. 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。\n 3. IE９以下不支持\n 4. IE９，１０，１１存在以下问题\n    1. 不支持离线功能\n    1. IE9不支持文件导入导出\n    1. IE10不支持拖拽文件导入\n\n---------\n\n[1]: http://math.stackexchange.com/\n[2]: https://github.com/jmcmanus/pagedown-extra \"Pagedown Extra\"\n[3]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n[4]: http://bramp.github.io/js-sequence-diagrams/\n[5]: http://adrai.github.io/flowchart.js/\n[6]: https://github.com/benweet/stackedit\n","source":"_posts/使用CSDN-markdown编辑器.md","raw":"---\ntitle: 这是我的第一篇博客\ndate: 2020-10-22 13:25:00\nauthor: heyXiao\nsummary: Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。\ncategories: Markdown\ntags:\n  - Typora\n  - Markdown\n---\n# 这是我的第一篇博客\n\n- **Markdown和扩展Markdown简洁的语法**\n- **代码块高亮**\n- **图片链接和图片上传**\n- ***LaTex*数学公式**\n- **UML序列图和流程图**\n- **离线写博客**\n- **导入导出Markdown文件**\n- **丰富的快捷键**\n\n-------------------\n\n## 快捷键\n\n - 加粗    `Ctrl + B` \n - 斜体    `Ctrl + I` \n - 引用    `Ctrl + Q`\n - 插入链接    `Ctrl + L`\n - 插入代码    `Ctrl + K`\n - 插入图片    `Ctrl + G`\n - 提升标题    `Ctrl + H`\n - 有序列表    `Ctrl + O`\n - 无序列表    `Ctrl + U`\n - 横线    `Ctrl + R`\n - 撤销    `Ctrl + Z`\n - 重做    `Ctrl + Y`\n\n## Markdown及扩展\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]\n\n使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.csdn.net)等，详细语法参考帮助？。\n\n本编辑器支持 **Markdown Extra** , 　扩展了很多好用的功能。具体请参考[Github][2].  \n\n### 表格\n\n**Markdown　Extra**　表格语法：\n\n项目     | 价格\n-------- | ---\nComputer | $1600\nPhone    | $12\nPipe     | $1\n\n可以使用冒号来定义对齐方式：\n\n| 项目      |    价格 | 数量  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 元 |  5   |\n| Phone     |   12 元 |  12  |\n| Pipe      |    1 元 | 234  |\n\n###定义列表\n\n**Markdown　Extra**　定义列表语法：\n项目１\n项目２\n:   定义 A\n:   定义 B\n\n项目３\n:   定义 C\n\n:   定义 D\n\n\t> 定义D内容\n\n### 代码块\n代码块语法遵循标准markdown代码，例如：\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n>>> message = '''interpreter\n... prompt'''\n```\n\n###脚注\n生成一个脚注[^footnote].\n  [^footnote]: 这里是 **脚注** 的 *内容*.\n  \n### 目录\n用 `[TOC]`来生成目录：\n\n@[toc]\n### 数学公式\n使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].\n\n - 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。\n - 块级公式：\n\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n更多LaTex语法请参考 [这儿][3].\n\n### UML 图:\n\n可以渲染序列图：\n\n```mermaid\nsequenceDiagram\n张三->>李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->>张三: 忙得吐血，哪有时间写。\n```\n\n或者流程图：\n\n```mermaid\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n- 关于 **序列图** 语法，参考 [这儿][4],\n- 关于 **流程图** 语法，参考 [这儿][5].\n\n## 离线写博客\n\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入[write.blog.csdn.net/mdeditor](http://write.blog.csdn.net/mdeditor)即可。**Markdown编辑器**使用浏览器离线存储将内容保存在本地。\n\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\n\n博客发表后，本地缓存将被删除。　\n\n用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\n\n> **注意：**虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，**请务必及时发表或者保存到服务器草稿箱**。\n\n##浏览器兼容\n\n 1. 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。\n 3. IE９以下不支持\n 4. IE９，１０，１１存在以下问题\n    1. 不支持离线功能\n    1. IE9不支持文件导入导出\n    1. IE10不支持拖拽文件导入\n\n---------\n\n[1]: http://math.stackexchange.com/\n[2]: https://github.com/jmcmanus/pagedown-extra \"Pagedown Extra\"\n[3]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n[4]: http://bramp.github.io/js-sequence-diagrams/\n[5]: http://adrai.github.io/flowchart.js/\n[6]: https://github.com/benweet/stackedit\n","slug":"使用CSDN-markdown编辑器","published":1,"updated":"2020-11-07T07:29:09.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6o0007bwr4bm2c1tq5","content":"<h1 id=\"这是我的第一篇博客\"><a href=\"#这是我的第一篇博客\" class=\"headerlink\" title=\"这是我的第一篇博客\"></a>这是我的第一篇博客</h1><ul>\n<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>\n<li><strong>代码块高亮</strong></li>\n<li><strong>图片链接和图片上传</strong></li>\n<li><strong><em>LaTex</em>数学公式</strong></li>\n<li><strong>UML序列图和流程图</strong></li>\n<li><strong>离线写博客</strong></li>\n<li><strong>导入导出Markdown文件</strong></li>\n<li><strong>丰富的快捷键</strong></li>\n</ul>\n<hr>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><ul>\n<li>加粗    <code>Ctrl + B</code> </li>\n<li>斜体    <code>Ctrl + I</code> </li>\n<li>引用    <code>Ctrl + Q</code></li>\n<li>插入链接    <code>Ctrl + L</code></li>\n<li>插入代码    <code>Ctrl + K</code></li>\n<li>插入图片    <code>Ctrl + G</code></li>\n<li>提升标题    <code>Ctrl + H</code></li>\n<li>有序列表    <code>Ctrl + O</code></li>\n<li>无序列表    <code>Ctrl + U</code></li>\n<li>横线    <code>Ctrl + R</code></li>\n<li>撤销    <code>Ctrl + Z</code></li>\n<li>重做    <code>Ctrl + Y</code></li>\n</ul>\n<h2 id=\"Markdown及扩展\"><a href=\"#Markdown及扩展\" class=\"headerlink\" title=\"Markdown及扩展\"></a>Markdown及扩展</h2><blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]</p>\n</blockquote>\n<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.csdn.net/\">链接</a>等，详细语法参考帮助？。</p>\n<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href=\"https://github.com/jmcmanus/pagedown-extra\" title=\"Pagedown Extra\">Github</a>.  </p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Computer</td>\n<td>$1600</td>\n</tr>\n<tr>\n<td>Phone</td>\n<td>$12</td>\n</tr>\n<tr>\n<td>Pipe</td>\n<td>$1</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Computer</td>\n<td align=\"right\">1600 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">Phone</td>\n<td align=\"right\">12 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">Pipe</td>\n<td align=\"right\">1 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<p>###定义列表</p>\n<dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p>\n<pre><code>&gt; 定义D内容</code></pre>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>\n<pre class=\" language-python\"><code class=\"language-python\">@requires_authorization\n<span class=\"token keyword\">def</span> <span class=\"token function\">somefunc</span><span class=\"token punctuation\">(</span>param1<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> param2<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">'''A docstring'''</span>\n    <span class=\"token keyword\">if</span> param1 <span class=\"token operator\">></span> param2<span class=\"token punctuation\">:</span> <span class=\"token comment\" spellcheck=\"true\"># interesting</span>\n        <span class=\"token keyword\">print</span> <span class=\"token string\">'Greater'</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>param2 <span class=\"token operator\">-</span> param1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> None\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> message <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">'''interpreter\n... prompt'''</span></code></pre>\n<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>\n<p>@[toc]</p>\n<h3 id=\"数学公式\"><a href=\"#数学公式\" class=\"headerlink\" title=\"数学公式\"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href=\"http://math.stackexchange.com/\">math.stackexchange.com</a>.</p>\n<ul>\n<li>行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。</li>\n<li>块级公式：</li>\n</ul>\n<p>$$    x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p>\n<p>更多LaTex语法请参考 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">这儿</a>.</p>\n<h3 id=\"UML-图\"><a href=\"#UML-图\" class=\"headerlink\" title=\"UML 图:\"></a>UML 图:</h3><p>可以渲染序列图：</p>\n<pre class=\" language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n张三->>李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->>张三: 忙得吐血，哪有时间写。</code></pre>\n<p>或者流程图：</p>\n<pre class=\" language-mermaid\"><code class=\"language-mermaid\">flowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op</code></pre>\n<ul>\n<li>关于 <strong>序列图</strong> 语法，参考 <a href=\"http://bramp.github.io/js-sequence-diagrams/\">这儿</a>,</li>\n<li>关于 <strong>流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"离线写博客\"><a href=\"#离线写博客\" class=\"headerlink\" title=\"离线写博客\"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href=\"http://write.blog.csdn.net/mdeditor\">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>\n<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>\n<p>博客发表后，本地缓存将被删除。　</p>\n<p>用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>\n<blockquote>\n<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>\n</blockquote>\n<p>##浏览器兼容</p>\n<ol>\n<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>\n<li>IE９以下不支持</li>\n<li>IE９，１０，１１存在以下问题<ol>\n<li>不支持离线功能</li>\n<li>IE9不支持文件导入导出</li>\n<li>IE10不支持拖拽文件导入</li>\n</ol>\n</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是我的第一篇博客\"><a href=\"#这是我的第一篇博客\" class=\"headerlink\" title=\"这是我的第一篇博客\"></a>这是我的第一篇博客</h1><ul>\n<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>\n<li><strong>代码块高亮</strong></li>\n<li><strong>图片链接和图片上传</strong></li>\n<li><strong><em>LaTex</em>数学公式</strong></li>\n<li><strong>UML序列图和流程图</strong></li>\n<li><strong>离线写博客</strong></li>\n<li><strong>导入导出Markdown文件</strong></li>\n<li><strong>丰富的快捷键</strong></li>\n</ul>\n<hr>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><ul>\n<li>加粗    <code>Ctrl + B</code> </li>\n<li>斜体    <code>Ctrl + I</code> </li>\n<li>引用    <code>Ctrl + Q</code></li>\n<li>插入链接    <code>Ctrl + L</code></li>\n<li>插入代码    <code>Ctrl + K</code></li>\n<li>插入图片    <code>Ctrl + G</code></li>\n<li>提升标题    <code>Ctrl + H</code></li>\n<li>有序列表    <code>Ctrl + O</code></li>\n<li>无序列表    <code>Ctrl + U</code></li>\n<li>横线    <code>Ctrl + R</code></li>\n<li>撤销    <code>Ctrl + Z</code></li>\n<li>重做    <code>Ctrl + Y</code></li>\n</ul>\n<h2 id=\"Markdown及扩展\"><a href=\"#Markdown及扩展\" class=\"headerlink\" title=\"Markdown及扩展\"></a>Markdown及扩展</h2><blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]</p>\n</blockquote>\n<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.csdn.net/\">链接</a>等，详细语法参考帮助？。</p>\n<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href=\"https://github.com/jmcmanus/pagedown-extra\" title=\"Pagedown Extra\">Github</a>.  </p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Computer</td>\n<td>$1600</td>\n</tr>\n<tr>\n<td>Phone</td>\n<td>$12</td>\n</tr>\n<tr>\n<td>Pipe</td>\n<td>$1</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Computer</td>\n<td align=\"right\">1600 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">Phone</td>\n<td align=\"right\">12 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">Pipe</td>\n<td align=\"right\">1 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<p>###定义列表</p>\n<dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p>\n<pre><code>&gt; 定义D内容</code></pre>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>\n<pre><code class=\"python\">@requires_authorization\ndef somefunc(param1=&#39;&#39;, param2=0):\n    &#39;&#39;&#39;A docstring&#39;&#39;&#39;\n    if param1 &gt; param2: # interesting\n        print &#39;Greater&#39;\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter\n... prompt&#39;&#39;&#39;</code></pre>\n<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>\n<p>@[toc]</p>\n<h3 id=\"数学公式\"><a href=\"#数学公式\" class=\"headerlink\" title=\"数学公式\"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href=\"http://math.stackexchange.com/\">math.stackexchange.com</a>.</p>\n<ul>\n<li>行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。</li>\n<li>块级公式：</li>\n</ul>\n<p>$$    x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p>\n<p>更多LaTex语法请参考 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">这儿</a>.</p>\n<h3 id=\"UML-图\"><a href=\"#UML-图\" class=\"headerlink\" title=\"UML 图:\"></a>UML 图:</h3><p>可以渲染序列图：</p>\n<pre><code class=\"mermaid\">sequenceDiagram\n张三-&gt;&gt;李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四--&gt;&gt;张三: 忙得吐血，哪有时间写。</code></pre>\n<p>或者流程图：</p>\n<pre><code class=\"mermaid\">flowchat\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op</code></pre>\n<ul>\n<li>关于 <strong>序列图</strong> 语法，参考 <a href=\"http://bramp.github.io/js-sequence-diagrams/\">这儿</a>,</li>\n<li>关于 <strong>流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"离线写博客\"><a href=\"#离线写博客\" class=\"headerlink\" title=\"离线写博客\"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href=\"http://write.blog.csdn.net/mdeditor\">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>\n<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>\n<p>博客发表后，本地缓存将被删除。　</p>\n<p>用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>\n<blockquote>\n<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>\n</blockquote>\n<p>##浏览器兼容</p>\n<ol>\n<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>\n<li>IE９以下不支持</li>\n<li>IE９，１０，１１存在以下问题<ol>\n<li>不支持离线功能</li>\n<li>IE9不支持文件导入导出</li>\n<li>IE10不支持拖拽文件导入</li>\n</ol>\n</li>\n</ol>\n<hr>\n"},{"title":"一篇来自2018年4月17日的Git笔记","date":"2020-11-09T04:27:22.000Z","author":"heyXiao","summary":"一些比较常用的Git指令","_content":"\n## GIT\n\n### 命令行窗口\n- 我们平时使用计算机都是通过可视化的界面来对电脑发送命令\n    + 鼠标右键->新建->新建文件夹\n- 命令行窗口也是一种可以向计算机发送命令的途径\n    + 通过命令的形式告诉计算机我们要做什么\n    + mkdir 文件夹的名字\n- 开启命令行\n    + win + R -> cmd -> enter\n- 常用命令行工具\n    + cmd\n    + powershell\n    + git bash\n\n### 常用命令\n- pwd (print working directory) 查看当前所在的目录\n- cd (change directory) 切换目录\n- ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)\n- clear 清屏（有兼容问题  可以用cls）\n- mkdir (make directory) 创建目录\n- touch 创建文件（有兼容问题 可以用 type nul>文件名）\n- cat 查看文件内容 一次性将所有内容输出\n- less 查看文件内容 每一次查看部分文件内容\n    + 回车 一次向下走一行\n    + 空格 一次向下走一页\n    + b（back）    一次向上走一页\n    + q（quit）    退出\n- rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）\n- rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用\n- mv (move) 移动文件或重命名\n- cp (copy) 复制文件\n- echo '内容' > 文件 输出内容到文件 每次输出都是覆盖原有文件内容\n- ehco '内容' >> 文件 输出内容到文件 每次输出都是追新内容\n- 命令的基本组成部分\n    + rm(删除命令) -rf(选项)\n\n### GIT是什么\n- 版本控制工具\n    + 例子：\n        * 人事专员管理职工信息\n        * 项目功能变更导致的问题\n        * 多人开发一个项目 代码共享时的问题\n\n### GIT三大区域\n- 工作目录\n    + 存放项目代码的目录\n- 暂存区\n    + 临时存放更改的了文件\n    + 防止工作目录中的代码丢失\n- 代码仓库\n    + 当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库\n    + 相当于复制了一份当前的代码存储到了仓库中\n\n### GIT常用命令\n- 配置git用户名和邮箱\n    + git config --global user.name zhangsan\n    + git config --global user.email demotest123@163.com\n- 查看当前的git配置\n    + git config --list\n- 初始化git仓库\n    + git init\n- 查看当前仓库的状态 \n    + git status\n- 将工作目录中的文件添加到暂存区\n    + git add\n- 将暂存区中的代码提交到本地仓库 形成一个版本\n    + git commit -m 备注 \n- 查看本地仓库中的历史提交版本\n    + git log \n- 将暂存区中的文件恢复到工作目录\n    + git rm --cached 文件列表 \n    + 说明:\n        * 必须保证工作目录中的代码和暂存区中的代码一致\n        * 此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理\n- 用暂存区中的文件覆盖工作目录中的文件\n    + git checkout -- 文件列表\n    + 说明：暂存区和工作目录都有此文件 这个文件依然被git管理\n- 回滚到本地仓库中的特定版本并覆盖暂存区和工作目录\n    + git reset --hard commitID\n- 查看分支\n    + git branch\n- 创建分支\n    + git branch 分支名称\n- 切换分支\n    + git checkout 分支名称\n- 创建并切换分支\n    + git checkout -b 分支名称 \n- 删除分支(如果分支没有被合并不允许删除)\n    + git branch -d 分支名称\n- 删除分支(强制删除分支)\n    + git branch -D 分支名称\n- 合并分支\n    + git merge 来源分支\n- 初始化一个裸露仓库(公共代码仓库)\n    + git init --bare \n- 向远程仓库推送代码\n    + git push 远程仓库地址 本地分支名称:远程分支名称\n- 从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)\n    + git pull 远程仓库地址 远程分支名称:本地分支名称\n- 为远程仓库地址创建别名\n    + git remote add 别名 远程仓库地址\n- 查看远程地址的详情信息\n    + git remote -v\n- 查看当前别名所对应的远程仓库地址\n    + git remote show 别名 \n- 删除当前别名及所对应的远程仓库地址\n    + git remote remove 别名 \n- 从远程仓库获取代码(拉取所有版本到本地)\n    + git clone 远程仓库地址 项目名称\n    + 使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发\n- 冲突修复\n    + 模拟冲突\n        * 张三和李四分别克隆代码到本地\n        * 张三改了demo文件并提交到远端仓库\n        * 李四也改了同一个文件\n        * 这时因为张三已经提交了一版代码到远程仓库\n        * 远程仓库的代码要比李四本地的代码新\n        * 所以李四不能直接向远程仓库推送代码\n        * 要先拉去再推送\n        * 此时因为张三和李四改了同一个文件所以产生了冲突\n        * 李四解决冲突并再次提交代码到远程仓库\n- 多人协作开发免登录操作\n    + ssh-keygen\n\n### git使用流程\n-   1.配置账户信息\n    + git config --global user.name 用户名\n    + git config --global user.email 邮箱地址\n    + git config --list 查看当前的git配置\n-   2.初始化本地仓库\n    + git init\n-   3.查看本地仓库的状态\n    + git status\n-   4.将工作目录中的文件提交到暂存区\n    + git add 文件列表\n    + git add . 添加工作目录中所有的文件到暂存区\n-   1. 将暂存区中的代码提交到本地仓库\n    + git commit -m 备注\n    + git commit -m \"first commit\"\n\n### git 忽略清单\n- .gitignore文件","source":"_posts/一篇来自2018年4月17日的Git笔记.md","raw":"---\ntitle: 一篇来自2018年4月17日的Git笔记\ndate: 2020-11-09 12:27:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: 一些比较常用的Git指令\ncategories: Git\ntags:\n  - Git\n---\n\n## GIT\n\n### 命令行窗口\n- 我们平时使用计算机都是通过可视化的界面来对电脑发送命令\n    + 鼠标右键->新建->新建文件夹\n- 命令行窗口也是一种可以向计算机发送命令的途径\n    + 通过命令的形式告诉计算机我们要做什么\n    + mkdir 文件夹的名字\n- 开启命令行\n    + win + R -> cmd -> enter\n- 常用命令行工具\n    + cmd\n    + powershell\n    + git bash\n\n### 常用命令\n- pwd (print working directory) 查看当前所在的目录\n- cd (change directory) 切换目录\n- ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)\n- clear 清屏（有兼容问题  可以用cls）\n- mkdir (make directory) 创建目录\n- touch 创建文件（有兼容问题 可以用 type nul>文件名）\n- cat 查看文件内容 一次性将所有内容输出\n- less 查看文件内容 每一次查看部分文件内容\n    + 回车 一次向下走一行\n    + 空格 一次向下走一页\n    + b（back）    一次向上走一页\n    + q（quit）    退出\n- rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）\n- rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用\n- mv (move) 移动文件或重命名\n- cp (copy) 复制文件\n- echo '内容' > 文件 输出内容到文件 每次输出都是覆盖原有文件内容\n- ehco '内容' >> 文件 输出内容到文件 每次输出都是追新内容\n- 命令的基本组成部分\n    + rm(删除命令) -rf(选项)\n\n### GIT是什么\n- 版本控制工具\n    + 例子：\n        * 人事专员管理职工信息\n        * 项目功能变更导致的问题\n        * 多人开发一个项目 代码共享时的问题\n\n### GIT三大区域\n- 工作目录\n    + 存放项目代码的目录\n- 暂存区\n    + 临时存放更改的了文件\n    + 防止工作目录中的代码丢失\n- 代码仓库\n    + 当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库\n    + 相当于复制了一份当前的代码存储到了仓库中\n\n### GIT常用命令\n- 配置git用户名和邮箱\n    + git config --global user.name zhangsan\n    + git config --global user.email demotest123@163.com\n- 查看当前的git配置\n    + git config --list\n- 初始化git仓库\n    + git init\n- 查看当前仓库的状态 \n    + git status\n- 将工作目录中的文件添加到暂存区\n    + git add\n- 将暂存区中的代码提交到本地仓库 形成一个版本\n    + git commit -m 备注 \n- 查看本地仓库中的历史提交版本\n    + git log \n- 将暂存区中的文件恢复到工作目录\n    + git rm --cached 文件列表 \n    + 说明:\n        * 必须保证工作目录中的代码和暂存区中的代码一致\n        * 此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理\n- 用暂存区中的文件覆盖工作目录中的文件\n    + git checkout -- 文件列表\n    + 说明：暂存区和工作目录都有此文件 这个文件依然被git管理\n- 回滚到本地仓库中的特定版本并覆盖暂存区和工作目录\n    + git reset --hard commitID\n- 查看分支\n    + git branch\n- 创建分支\n    + git branch 分支名称\n- 切换分支\n    + git checkout 分支名称\n- 创建并切换分支\n    + git checkout -b 分支名称 \n- 删除分支(如果分支没有被合并不允许删除)\n    + git branch -d 分支名称\n- 删除分支(强制删除分支)\n    + git branch -D 分支名称\n- 合并分支\n    + git merge 来源分支\n- 初始化一个裸露仓库(公共代码仓库)\n    + git init --bare \n- 向远程仓库推送代码\n    + git push 远程仓库地址 本地分支名称:远程分支名称\n- 从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)\n    + git pull 远程仓库地址 远程分支名称:本地分支名称\n- 为远程仓库地址创建别名\n    + git remote add 别名 远程仓库地址\n- 查看远程地址的详情信息\n    + git remote -v\n- 查看当前别名所对应的远程仓库地址\n    + git remote show 别名 \n- 删除当前别名及所对应的远程仓库地址\n    + git remote remove 别名 \n- 从远程仓库获取代码(拉取所有版本到本地)\n    + git clone 远程仓库地址 项目名称\n    + 使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发\n- 冲突修复\n    + 模拟冲突\n        * 张三和李四分别克隆代码到本地\n        * 张三改了demo文件并提交到远端仓库\n        * 李四也改了同一个文件\n        * 这时因为张三已经提交了一版代码到远程仓库\n        * 远程仓库的代码要比李四本地的代码新\n        * 所以李四不能直接向远程仓库推送代码\n        * 要先拉去再推送\n        * 此时因为张三和李四改了同一个文件所以产生了冲突\n        * 李四解决冲突并再次提交代码到远程仓库\n- 多人协作开发免登录操作\n    + ssh-keygen\n\n### git使用流程\n-   1.配置账户信息\n    + git config --global user.name 用户名\n    + git config --global user.email 邮箱地址\n    + git config --list 查看当前的git配置\n-   2.初始化本地仓库\n    + git init\n-   3.查看本地仓库的状态\n    + git status\n-   4.将工作目录中的文件提交到暂存区\n    + git add 文件列表\n    + git add . 添加工作目录中所有的文件到暂存区\n-   1. 将暂存区中的代码提交到本地仓库\n    + git commit -m 备注\n    + git commit -m \"first commit\"\n\n### git 忽略清单\n- .gitignore文件","slug":"一篇来自2018年4月17日的Git笔记","published":1,"updated":"2020-11-17T08:38:16.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6p0009bwr4fg2b72zz","content":"<h2 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h2><h3 id=\"命令行窗口\"><a href=\"#命令行窗口\" class=\"headerlink\" title=\"命令行窗口\"></a>命令行窗口</h3><ul>\n<li>我们平时使用计算机都是通过可视化的界面来对电脑发送命令<ul>\n<li>鼠标右键-&gt;新建-&gt;新建文件夹</li>\n</ul>\n</li>\n<li>命令行窗口也是一种可以向计算机发送命令的途径<ul>\n<li>通过命令的形式告诉计算机我们要做什么</li>\n<li>mkdir 文件夹的名字</li>\n</ul>\n</li>\n<li>开启命令行<ul>\n<li>win + R -&gt; cmd -&gt; enter</li>\n</ul>\n</li>\n<li>常用命令行工具<ul>\n<li>cmd</li>\n<li>powershell</li>\n<li>git bash</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>pwd (print working directory) 查看当前所在的目录</li>\n<li>cd (change directory) 切换目录</li>\n<li>ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)</li>\n<li>clear 清屏（有兼容问题  可以用cls）</li>\n<li>mkdir (make directory) 创建目录</li>\n<li>touch 创建文件（有兼容问题 可以用 type nul&gt;文件名）</li>\n<li>cat 查看文件内容 一次性将所有内容输出</li>\n<li>less 查看文件内容 每一次查看部分文件内容<ul>\n<li>回车 一次向下走一行</li>\n<li>空格 一次向下走一页</li>\n<li>b（back）    一次向上走一页</li>\n<li>q（quit）    退出</li>\n</ul>\n</li>\n<li>rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）</li>\n<li>rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用</li>\n<li>mv (move) 移动文件或重命名</li>\n<li>cp (copy) 复制文件</li>\n<li>echo ‘内容’ &gt; 文件 输出内容到文件 每次输出都是覆盖原有文件内容</li>\n<li>ehco ‘内容’ &gt;&gt; 文件 输出内容到文件 每次输出都是追新内容</li>\n<li>命令的基本组成部分<ul>\n<li>rm(删除命令) -rf(选项)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT是什么\"><a href=\"#GIT是什么\" class=\"headerlink\" title=\"GIT是什么\"></a>GIT是什么</h3><ul>\n<li>版本控制工具<ul>\n<li>例子：<ul>\n<li>人事专员管理职工信息</li>\n<li>项目功能变更导致的问题</li>\n<li>多人开发一个项目 代码共享时的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT三大区域\"><a href=\"#GIT三大区域\" class=\"headerlink\" title=\"GIT三大区域\"></a>GIT三大区域</h3><ul>\n<li>工作目录<ul>\n<li>存放项目代码的目录</li>\n</ul>\n</li>\n<li>暂存区<ul>\n<li>临时存放更改的了文件</li>\n<li>防止工作目录中的代码丢失</li>\n</ul>\n</li>\n<li>代码仓库<ul>\n<li>当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库</li>\n<li>相当于复制了一份当前的代码存储到了仓库中</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT常用命令\"><a href=\"#GIT常用命令\" class=\"headerlink\" title=\"GIT常用命令\"></a>GIT常用命令</h3><ul>\n<li>配置git用户名和邮箱<ul>\n<li>git config –global user.name zhangsan</li>\n<li>git config –global user.email <a href=\"mailto:&#x64;&#x65;&#x6d;&#111;&#116;&#101;&#x73;&#x74;&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;\">&#x64;&#x65;&#x6d;&#111;&#116;&#101;&#x73;&#x74;&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;</a></li>\n</ul>\n</li>\n<li>查看当前的git配置<ul>\n<li>git config –list</li>\n</ul>\n</li>\n<li>初始化git仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>查看当前仓库的状态 <ul>\n<li>git status</li>\n</ul>\n</li>\n<li>将工作目录中的文件添加到暂存区<ul>\n<li>git add</li>\n</ul>\n</li>\n<li>将暂存区中的代码提交到本地仓库 形成一个版本<ul>\n<li>git commit -m 备注 </li>\n</ul>\n</li>\n<li>查看本地仓库中的历史提交版本<ul>\n<li>git log </li>\n</ul>\n</li>\n<li>将暂存区中的文件恢复到工作目录<ul>\n<li>git rm –cached 文件列表 </li>\n<li>说明:<ul>\n<li>必须保证工作目录中的代码和暂存区中的代码一致</li>\n<li>此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用暂存区中的文件覆盖工作目录中的文件<ul>\n<li>git checkout – 文件列表</li>\n<li>说明：暂存区和工作目录都有此文件 这个文件依然被git管理</li>\n</ul>\n</li>\n<li>回滚到本地仓库中的特定版本并覆盖暂存区和工作目录<ul>\n<li>git reset –hard commitID</li>\n</ul>\n</li>\n<li>查看分支<ul>\n<li>git branch</li>\n</ul>\n</li>\n<li>创建分支<ul>\n<li>git branch 分支名称</li>\n</ul>\n</li>\n<li>切换分支<ul>\n<li>git checkout 分支名称</li>\n</ul>\n</li>\n<li>创建并切换分支<ul>\n<li>git checkout -b 分支名称 </li>\n</ul>\n</li>\n<li>删除分支(如果分支没有被合并不允许删除)<ul>\n<li>git branch -d 分支名称</li>\n</ul>\n</li>\n<li>删除分支(强制删除分支)<ul>\n<li>git branch -D 分支名称</li>\n</ul>\n</li>\n<li>合并分支<ul>\n<li>git merge 来源分支</li>\n</ul>\n</li>\n<li>初始化一个裸露仓库(公共代码仓库)<ul>\n<li>git init –bare </li>\n</ul>\n</li>\n<li>向远程仓库推送代码<ul>\n<li>git push 远程仓库地址 本地分支名称:远程分支名称</li>\n</ul>\n</li>\n<li>从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)<ul>\n<li>git pull 远程仓库地址 远程分支名称:本地分支名称</li>\n</ul>\n</li>\n<li>为远程仓库地址创建别名<ul>\n<li>git remote add 别名 远程仓库地址</li>\n</ul>\n</li>\n<li>查看远程地址的详情信息<ul>\n<li>git remote -v</li>\n</ul>\n</li>\n<li>查看当前别名所对应的远程仓库地址<ul>\n<li>git remote show 别名 </li>\n</ul>\n</li>\n<li>删除当前别名及所对应的远程仓库地址<ul>\n<li>git remote remove 别名 </li>\n</ul>\n</li>\n<li>从远程仓库获取代码(拉取所有版本到本地)<ul>\n<li>git clone 远程仓库地址 项目名称</li>\n<li>使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发</li>\n</ul>\n</li>\n<li>冲突修复<ul>\n<li>模拟冲突<ul>\n<li>张三和李四分别克隆代码到本地</li>\n<li>张三改了demo文件并提交到远端仓库</li>\n<li>李四也改了同一个文件</li>\n<li>这时因为张三已经提交了一版代码到远程仓库</li>\n<li>远程仓库的代码要比李四本地的代码新</li>\n<li>所以李四不能直接向远程仓库推送代码</li>\n<li>要先拉去再推送</li>\n<li>此时因为张三和李四改了同一个文件所以产生了冲突</li>\n<li>李四解决冲突并再次提交代码到远程仓库</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多人协作开发免登录操作<ul>\n<li>ssh-keygen</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git使用流程\"><a href=\"#git使用流程\" class=\"headerlink\" title=\"git使用流程\"></a>git使用流程</h3><ul>\n<li>1.配置账户信息<ul>\n<li>git config –global user.name 用户名</li>\n<li>git config –global user.email 邮箱地址</li>\n<li>git config –list 查看当前的git配置</li>\n</ul>\n</li>\n<li>2.初始化本地仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>3.查看本地仓库的状态<ul>\n<li>git status</li>\n</ul>\n</li>\n<li>4.将工作目录中的文件提交到暂存区<ul>\n<li>git add 文件列表</li>\n<li>git add . 添加工作目录中所有的文件到暂存区</li>\n</ul>\n</li>\n<li><ol>\n<li>将暂存区中的代码提交到本地仓库<ul>\n<li>git commit -m 备注</li>\n<li>git commit -m “first commit”</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"git-忽略清单\"><a href=\"#git-忽略清单\" class=\"headerlink\" title=\"git 忽略清单\"></a>git 忽略清单</h3><ul>\n<li>.gitignore文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h2><h3 id=\"命令行窗口\"><a href=\"#命令行窗口\" class=\"headerlink\" title=\"命令行窗口\"></a>命令行窗口</h3><ul>\n<li>我们平时使用计算机都是通过可视化的界面来对电脑发送命令<ul>\n<li>鼠标右键-&gt;新建-&gt;新建文件夹</li>\n</ul>\n</li>\n<li>命令行窗口也是一种可以向计算机发送命令的途径<ul>\n<li>通过命令的形式告诉计算机我们要做什么</li>\n<li>mkdir 文件夹的名字</li>\n</ul>\n</li>\n<li>开启命令行<ul>\n<li>win + R -&gt; cmd -&gt; enter</li>\n</ul>\n</li>\n<li>常用命令行工具<ul>\n<li>cmd</li>\n<li>powershell</li>\n<li>git bash</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>pwd (print working directory) 查看当前所在的目录</li>\n<li>cd (change directory) 切换目录</li>\n<li>ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)</li>\n<li>clear 清屏（有兼容问题  可以用cls）</li>\n<li>mkdir (make directory) 创建目录</li>\n<li>touch 创建文件（有兼容问题 可以用 type nul&gt;文件名）</li>\n<li>cat 查看文件内容 一次性将所有内容输出</li>\n<li>less 查看文件内容 每一次查看部分文件内容<ul>\n<li>回车 一次向下走一行</li>\n<li>空格 一次向下走一页</li>\n<li>b（back）    一次向上走一页</li>\n<li>q（quit）    退出</li>\n</ul>\n</li>\n<li>rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）</li>\n<li>rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用</li>\n<li>mv (move) 移动文件或重命名</li>\n<li>cp (copy) 复制文件</li>\n<li>echo ‘内容’ &gt; 文件 输出内容到文件 每次输出都是覆盖原有文件内容</li>\n<li>ehco ‘内容’ &gt;&gt; 文件 输出内容到文件 每次输出都是追新内容</li>\n<li>命令的基本组成部分<ul>\n<li>rm(删除命令) -rf(选项)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT是什么\"><a href=\"#GIT是什么\" class=\"headerlink\" title=\"GIT是什么\"></a>GIT是什么</h3><ul>\n<li>版本控制工具<ul>\n<li>例子：<ul>\n<li>人事专员管理职工信息</li>\n<li>项目功能变更导致的问题</li>\n<li>多人开发一个项目 代码共享时的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT三大区域\"><a href=\"#GIT三大区域\" class=\"headerlink\" title=\"GIT三大区域\"></a>GIT三大区域</h3><ul>\n<li>工作目录<ul>\n<li>存放项目代码的目录</li>\n</ul>\n</li>\n<li>暂存区<ul>\n<li>临时存放更改的了文件</li>\n<li>防止工作目录中的代码丢失</li>\n</ul>\n</li>\n<li>代码仓库<ul>\n<li>当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库</li>\n<li>相当于复制了一份当前的代码存储到了仓库中</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT常用命令\"><a href=\"#GIT常用命令\" class=\"headerlink\" title=\"GIT常用命令\"></a>GIT常用命令</h3><ul>\n<li>配置git用户名和邮箱<ul>\n<li>git config –global user.name zhangsan</li>\n<li>git config –global user.email <a href=\"mailto:&#x64;&#x65;&#x6d;&#111;&#116;&#101;&#x73;&#x74;&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;\">&#x64;&#x65;&#x6d;&#111;&#116;&#101;&#x73;&#x74;&#x31;&#x32;&#51;&#64;&#x31;&#x36;&#x33;&#46;&#x63;&#x6f;&#109;</a></li>\n</ul>\n</li>\n<li>查看当前的git配置<ul>\n<li>git config –list</li>\n</ul>\n</li>\n<li>初始化git仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>查看当前仓库的状态 <ul>\n<li>git status</li>\n</ul>\n</li>\n<li>将工作目录中的文件添加到暂存区<ul>\n<li>git add</li>\n</ul>\n</li>\n<li>将暂存区中的代码提交到本地仓库 形成一个版本<ul>\n<li>git commit -m 备注 </li>\n</ul>\n</li>\n<li>查看本地仓库中的历史提交版本<ul>\n<li>git log </li>\n</ul>\n</li>\n<li>将暂存区中的文件恢复到工作目录<ul>\n<li>git rm –cached 文件列表 </li>\n<li>说明:<ul>\n<li>必须保证工作目录中的代码和暂存区中的代码一致</li>\n<li>此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用暂存区中的文件覆盖工作目录中的文件<ul>\n<li>git checkout – 文件列表</li>\n<li>说明：暂存区和工作目录都有此文件 这个文件依然被git管理</li>\n</ul>\n</li>\n<li>回滚到本地仓库中的特定版本并覆盖暂存区和工作目录<ul>\n<li>git reset –hard commitID</li>\n</ul>\n</li>\n<li>查看分支<ul>\n<li>git branch</li>\n</ul>\n</li>\n<li>创建分支<ul>\n<li>git branch 分支名称</li>\n</ul>\n</li>\n<li>切换分支<ul>\n<li>git checkout 分支名称</li>\n</ul>\n</li>\n<li>创建并切换分支<ul>\n<li>git checkout -b 分支名称 </li>\n</ul>\n</li>\n<li>删除分支(如果分支没有被合并不允许删除)<ul>\n<li>git branch -d 分支名称</li>\n</ul>\n</li>\n<li>删除分支(强制删除分支)<ul>\n<li>git branch -D 分支名称</li>\n</ul>\n</li>\n<li>合并分支<ul>\n<li>git merge 来源分支</li>\n</ul>\n</li>\n<li>初始化一个裸露仓库(公共代码仓库)<ul>\n<li>git init –bare </li>\n</ul>\n</li>\n<li>向远程仓库推送代码<ul>\n<li>git push 远程仓库地址 本地分支名称:远程分支名称</li>\n</ul>\n</li>\n<li>从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)<ul>\n<li>git pull 远程仓库地址 远程分支名称:本地分支名称</li>\n</ul>\n</li>\n<li>为远程仓库地址创建别名<ul>\n<li>git remote add 别名 远程仓库地址</li>\n</ul>\n</li>\n<li>查看远程地址的详情信息<ul>\n<li>git remote -v</li>\n</ul>\n</li>\n<li>查看当前别名所对应的远程仓库地址<ul>\n<li>git remote show 别名 </li>\n</ul>\n</li>\n<li>删除当前别名及所对应的远程仓库地址<ul>\n<li>git remote remove 别名 </li>\n</ul>\n</li>\n<li>从远程仓库获取代码(拉取所有版本到本地)<ul>\n<li>git clone 远程仓库地址 项目名称</li>\n<li>使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发</li>\n</ul>\n</li>\n<li>冲突修复<ul>\n<li>模拟冲突<ul>\n<li>张三和李四分别克隆代码到本地</li>\n<li>张三改了demo文件并提交到远端仓库</li>\n<li>李四也改了同一个文件</li>\n<li>这时因为张三已经提交了一版代码到远程仓库</li>\n<li>远程仓库的代码要比李四本地的代码新</li>\n<li>所以李四不能直接向远程仓库推送代码</li>\n<li>要先拉去再推送</li>\n<li>此时因为张三和李四改了同一个文件所以产生了冲突</li>\n<li>李四解决冲突并再次提交代码到远程仓库</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多人协作开发免登录操作<ul>\n<li>ssh-keygen</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git使用流程\"><a href=\"#git使用流程\" class=\"headerlink\" title=\"git使用流程\"></a>git使用流程</h3><ul>\n<li>1.配置账户信息<ul>\n<li>git config –global user.name 用户名</li>\n<li>git config –global user.email 邮箱地址</li>\n<li>git config –list 查看当前的git配置</li>\n</ul>\n</li>\n<li>2.初始化本地仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>3.查看本地仓库的状态<ul>\n<li>git status</li>\n</ul>\n</li>\n<li>4.将工作目录中的文件提交到暂存区<ul>\n<li>git add 文件列表</li>\n<li>git add . 添加工作目录中所有的文件到暂存区</li>\n</ul>\n</li>\n<li><ol>\n<li>将暂存区中的代码提交到本地仓库<ul>\n<li>git commit -m 备注</li>\n<li>git commit -m “first commit”</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"git-忽略清单\"><a href=\"#git-忽略清单\" class=\"headerlink\" title=\"git 忽略清单\"></a>git 忽略清单</h3><ul>\n<li>.gitignore文件</li>\n</ul>\n"},{"title":"提上日程的几件事","date":"2020-11-17T08:37:15.000Z","author":"heyXiao","password":"025796e1db8c9c0f5ce8825e521e76692a7c03a73d8e77462e620ae458a88fe3","summary":"快要结束的一年的总结","indexing":false,"_content":"\n# 提上日程的几件事\n\n<font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font>\n<br/>\n<font color=\"#999999\">本周单休</font>\n\n## 年终总结\n<p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n","source":"_posts/提上日程的几件事.md","raw":"---\ntitle: 提上日程的几件事\ndate: 2020-11-17 16:37:15\nauthor: heyXiao\npassword: 025796e1db8c9c0f5ce8825e521e76692a7c03a73d8e77462e620ae458a88fe3\n# cover: true\nsummary: 快要结束的一年的总结\ncategories: 随笔\nindexing: false\ntags:\n  - 随笔\n---\n\n# 提上日程的几件事\n\n<font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font>\n<br/>\n<font color=\"#999999\">本周单休</font>\n\n## 年终总结\n<p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n","slug":"提上日程的几件事","published":1,"updated":"2021-01-06T03:33:07.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6q000bbwr4887z0ud3","content":"<h1 id=\"提上日程的几件事\"><a href=\"#提上日程的几件事\" class=\"headerlink\" title=\"提上日程的几件事\"></a>提上日程的几件事</h1><p><font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font><br><br/><br><font color=\"#999999\">本周单休</font></p>\n<h2 id=\"年终总结\"><a href=\"#年终总结\" class=\"headerlink\" title=\"年终总结\"></a>年终总结</h2><p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"提上日程的几件事\"><a href=\"#提上日程的几件事\" class=\"headerlink\" title=\"提上日程的几件事\"></a>提上日程的几件事</h1><p><font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font><br><br/><br><font color=\"#999999\">本周单休</font></p>\n<h2 id=\"年终总结\"><a href=\"#年终总结\" class=\"headerlink\" title=\"年终总结\"></a>年终总结</h2><p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n"},{"title":"无博客无心情","date":"2021-01-28T06:42:27.000Z","author":"heyXiao","summary":"随便写写","_content":"### 一\n三无博客可以查到了，虽然要打全拼。小小的鼓励。\n\n### 二\n最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。\n\n### 三\nCourtship but friendship at least.\n\n### 四\n在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。\n\n### 五\n如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。\n\n### 六\n不用拖延了，因为本周又有事情做。","source":"_posts/无博客无心情.md","raw":"---\ntitle: 无博客无心情\ndate: 2021-01-28 14:42:27\nauthor: heyXiao\nsummary: 随便写写\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n### 一\n三无博客可以查到了，虽然要打全拼。小小的鼓励。\n\n### 二\n最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。\n\n### 三\nCourtship but friendship at least.\n\n### 四\n在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。\n\n### 五\n如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。\n\n### 六\n不用拖延了，因为本周又有事情做。","slug":"无博客无心情","published":1,"updated":"2021-02-03T05:13:04.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6s000ebwr43rhjbzyu","content":"<h3 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h3><p>三无博客可以查到了，虽然要打全拼。小小的鼓励。</p>\n<h3 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h3><p>最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。</p>\n<h3 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h3><p>Courtship but friendship at least.</p>\n<h3 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h3><p>在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。</p>\n<h3 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h3><p>如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。</p>\n<h3 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h3><p>不用拖延了，因为本周又有事情做。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h3><p>三无博客可以查到了，虽然要打全拼。小小的鼓励。</p>\n<h3 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h3><p>最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。</p>\n<h3 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h3><p>Courtship but friendship at least.</p>\n<h3 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h3><p>在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。</p>\n<h3 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h3><p>如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。</p>\n<h3 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h3><p>不用拖延了，因为本周又有事情做。</p>\n"},{"title":"这个Blog还有我","date":"2020-11-07T08:27:22.000Z","author":"heyXiao","summary":"主要是个人简介与博客的介绍","_content":"# 这个Blog还有我\n\n-------------------\n## 个人简介\n\n**我** 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。\n**兴趣爱好：** 听音乐，排球，羽毛球，骑车\n**Favor：** 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。\n**联系方式：** 手机：18856980690 邮箱：heylheyz@163.com\n\n##### 技能简介\n**技术栈** H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。\n**PC端** 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。\n**移动端** 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。\n**业务能力** 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。\n\n##### 自我评价\n待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。\n\n## 博客简介\n**这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。**\n\n## 其他的事情\n很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。\n感谢 [blinkfox](https://github.com/blinkfox)和[hexo-theme-matery](https://github.com/blinkfox/hexo-theme-matery)，Ta的文章与Hexo主题帮助我建立了这个博客。\n","source":"_posts/这个Blog还有我.md","raw":"---\ntitle: 这个Blog还有我\ndate: 2020-11-07 16:27:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: 主要是个人简介与博客的介绍\ncategories: 致来访者\ntags:\n  - 个人简介\n  - 博客简介\n---\n# 这个Blog还有我\n\n-------------------\n## 个人简介\n\n**我** 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。\n**兴趣爱好：** 听音乐，排球，羽毛球，骑车\n**Favor：** 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。\n**联系方式：** 手机：18856980690 邮箱：heylheyz@163.com\n\n##### 技能简介\n**技术栈** H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。\n**PC端** 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。\n**移动端** 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。\n**业务能力** 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。\n\n##### 自我评价\n待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。\n\n## 博客简介\n**这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。**\n\n## 其他的事情\n很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。\n感谢 [blinkfox](https://github.com/blinkfox)和[hexo-theme-matery](https://github.com/blinkfox/hexo-theme-matery)，Ta的文章与Hexo主题帮助我建立了这个博客。\n","slug":"这个Blog还有我","published":1,"updated":"2021-01-06T03:16:01.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6t000fbwr48kwshhwf","content":"<h1 id=\"这个Blog还有我\"><a href=\"#这个Blog还有我\" class=\"headerlink\" title=\"这个Blog还有我\"></a>这个Blog还有我</h1><hr>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p><strong>我</strong> 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。<br><strong>兴趣爱好：</strong> 听音乐，排球，羽毛球，骑车<br><strong>Favor：</strong> 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。<br><strong>联系方式：</strong> 手机：18856980690 邮箱：<a href=\"mailto:&#104;&#101;&#x79;&#x6c;&#x68;&#x65;&#x79;&#122;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;\">&#104;&#101;&#x79;&#x6c;&#x68;&#x65;&#x79;&#122;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>\n<h5 id=\"技能简介\"><a href=\"#技能简介\" class=\"headerlink\" title=\"技能简介\"></a>技能简介</h5><p><strong>技术栈</strong> H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。<br><strong>PC端</strong> 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。<br><strong>移动端</strong> 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。<br><strong>业务能力</strong> 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。</p>\n<h5 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h5><p>待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。</p>\n<h2 id=\"博客简介\"><a href=\"#博客简介\" class=\"headerlink\" title=\"博客简介\"></a>博客简介</h2><p><strong>这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。</strong></p>\n<h2 id=\"其他的事情\"><a href=\"#其他的事情\" class=\"headerlink\" title=\"其他的事情\"></a>其他的事情</h2><p>很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。<br>感谢 <a href=\"https://github.com/blinkfox\">blinkfox</a>和<a href=\"https://github.com/blinkfox/hexo-theme-matery\">hexo-theme-matery</a>，Ta的文章与Hexo主题帮助我建立了这个博客。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这个Blog还有我\"><a href=\"#这个Blog还有我\" class=\"headerlink\" title=\"这个Blog还有我\"></a>这个Blog还有我</h1><hr>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p><strong>我</strong> 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。<br><strong>兴趣爱好：</strong> 听音乐，排球，羽毛球，骑车<br><strong>Favor：</strong> 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。<br><strong>联系方式：</strong> 手机：18856980690 邮箱：<a href=\"mailto:&#104;&#101;&#x79;&#x6c;&#x68;&#x65;&#x79;&#122;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;\">&#104;&#101;&#x79;&#x6c;&#x68;&#x65;&#x79;&#122;&#64;&#x31;&#54;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>\n<h5 id=\"技能简介\"><a href=\"#技能简介\" class=\"headerlink\" title=\"技能简介\"></a>技能简介</h5><p><strong>技术栈</strong> H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。<br><strong>PC端</strong> 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。<br><strong>移动端</strong> 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。<br><strong>业务能力</strong> 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。</p>\n<h5 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h5><p>待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。</p>\n<h2 id=\"博客简介\"><a href=\"#博客简介\" class=\"headerlink\" title=\"博客简介\"></a>博客简介</h2><p><strong>这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。</strong></p>\n<h2 id=\"其他的事情\"><a href=\"#其他的事情\" class=\"headerlink\" title=\"其他的事情\"></a>其他的事情</h2><p>很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。<br>感谢 <a href=\"https://github.com/blinkfox\">blinkfox</a>和<a href=\"https://github.com/blinkfox/hexo-theme-matery\">hexo-theme-matery</a>，Ta的文章与Hexo主题帮助我建立了这个博客。</p>\n"},{"title":"理解 JavaScript 的 async/await","date":"2020-11-12T23:26:22.000Z","author":"heyXiao","_content":"# [理解 JavaScript 的 async/await]()\n\nJavaScript 中的 async/await 是 [AsyncFunction 特性](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction) 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 [这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility) 查看。\n\n---\n\n我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。\n\n我之前在[《闲谈异步调用“扁平”化》](https://segmentfault.com/a/1190000003742890) 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 [Task 或 Task<Result>](https://msdn.microsoft.com/library/dd321424.aspx) 类，而 JavaScript 的 async/await 实现，也离不开 [Promise](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise)。\n\n现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。\n\n## 1\\. async 和 await 在干什么\n\n任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？\n\n如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……\n\n如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？\n\n### 1.1. async 起什么作用\n\n这个问题的关键在于，async 函数是怎么处理它的返回值的！\n\n我们当然希望它能直接通过 `return` 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：\n\n    async function testAsync() {\n        return \"hello async\";\n    }\n\n    const result = testAsync();\n    console.log(result);\n\n看到输出就恍然大悟了——输出的是一个 Promise 对象。\n\n    c:\\var\\test> node --harmony_async_await .\n    Promise { 'hello async' }\n\n所以，async 函数返回的是一个 Promise 对象。从[文档](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function)中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\n> 补充知识点 _\\[2020-06-04\\]_\n>\n> `Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样\n\n    testAsync().then(v => {\n        console.log(v);    // 输出 hello async\n    });\n\n现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n那么下一个关键点就在于 await 关键字了。\n\n### 1.2. await 到底在等啥\n\n一般来说，都认为 await 是在等待一个 async 函数完成。不过按[语法说明](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await)，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行\n\n    function getSomething() {\n        return \"something\";\n    }\n\n    async function testAsync() {\n        return Promise.resolve(\"hello async\");\n    }\n\n    async function test() {\n        const v1 = await getSomething();\n        const v2 = await testAsync();\n        console.log(v1, v2);\n    }\n\n    test();\n\n### 1.3. await 等到了要等的，然后呢\n\nawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，`await` 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。\n\n如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n\n如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n> 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n## 2\\. async/await 帮我们干了啥\n\n### 2.1. 作个简单的比较\n\n上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。\n\n现在举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写\n\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    takeLongTime().then(v => {\n        console.log(\"got\", v);\n    });\n\n如果改用 async/await 呢，会是这样\n\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    async function test() {\n        const v = await takeLongTime();\n        console.log(v);\n    }\n\n    test();\n\n眼尖的同学已经发现 `takeLongTime()` 没有申明为 `async`。实际上，`takeLongTime()` 本身就是返回的 Promise 对象，加不加 `async` 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。\n\n又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？\n\n### 2.2. async/await 的优势在于处理 then 链\n\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：\n\n    /**\n     * 传入参数 n，表示这个函数执行的时间（毫秒）\n     * 执行的结果是 n + 200，这个值将用于下一步骤\n     */\n    function takeLongTime(n) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(n + 200), n);\n        });\n    }\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(n) {\n        console.log(`step2 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step3(n) {\n        console.log(`step3 with ${n}`);\n        return takeLongTime(n);\n    }\n\n现在用 Promise 方式来实现这三个步骤的处理\n\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => step2(time2))\n            .then(time3 => step3(time3))\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 500\n    // step3 with 700\n    // result is 900\n    // doIt: 1507.251ms\n\n输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样\n\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time2);\n        const result = await step3(time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n### 2.3. 还有更酷的\n\n现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(m, n) {\n        console.log(`step2 with ${m} and ${n}`);\n        return takeLongTime(m + n);\n    }\n\n    function step3(k, m, n) {\n        console.log(`step3 with ${k}, ${m} and ${n}`);\n        return takeLongTime(k + m + n);\n    }\n\n这回先用 async/await 来写：\n\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time1, time2);\n        const result = await step3(time1, time2, time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 800 = 300 + 500\n    // step3 with 1800 = 300 + 500 + 1000\n    // result is 2000\n    // doIt: 2907.387ms\n\n除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？\n\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => {\n                return step2(time1, time2)\n                    .then(time3 => [time1, time2, time3]);\n            })\n            .then(times => {\n                const [time1, time2, time3] = times;\n                return step3(time1, time2, time3);\n            })\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！\n\n## 3\\. 洗洗睡吧\n\n就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？\n\n[阮一峰老师已经说过了](http://www.ruanyifeng.com/blog/2015/05/async.html)，我就懒得说了。\n\n## 4\\. 推荐相关文章\n\n- [在微信小程序中使用 async/await](https://segmentfault.com/a/1190000021966277) 2020-03-10\n- [代码审查，异步调用的常见问题剖析](https://segmentfault.com/a/1190000022349639) 2020-04-12\n- [Proxy 封装微信小程序的异步调用](https://segmentfault.com/a/1190000022315137) 2020-04-9\n- [改进异步封装：处理带返回值的异步调用](https://segmentfault.com/a/1190000022467002) 2020-04-25\n- [从地狱到天堂，Node 回调向 async/await 转变](https://segmentfault.com/a/1190000007987187) 2017-01-02\n- [异步编程需要“意识”](https://segmentfault.com/a/1190000013337421) 2018-02-23\n- [从不用 try-catch 实现的 async/await 语法说错误处理](https://segmentfault.com/a/1190000011802045) 2017-10-31\n\n## 5\\. 关于转载\n\n转载自[思否](https://segmentfault.com/a/1190000007535316) 作者[边城](https://segmentfault.com/u/jamesfancy)\n\n","source":"_posts/理解 JavaScript 的 async&await.md","raw":"---\ntitle: 理解 JavaScript 的 async/await\ndate: 2020-11-13 07:26:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 转载\n---\n# [理解 JavaScript 的 async/await]()\n\nJavaScript 中的 async/await 是 [AsyncFunction 特性](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction) 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 [这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility) 查看。\n\n---\n\n我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。\n\n我之前在[《闲谈异步调用“扁平”化》](https://segmentfault.com/a/1190000003742890) 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 [Task 或 Task<Result>](https://msdn.microsoft.com/library/dd321424.aspx) 类，而 JavaScript 的 async/await 实现，也离不开 [Promise](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise)。\n\n现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。\n\n## 1\\. async 和 await 在干什么\n\n任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？\n\n如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……\n\n如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？\n\n### 1.1. async 起什么作用\n\n这个问题的关键在于，async 函数是怎么处理它的返回值的！\n\n我们当然希望它能直接通过 `return` 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：\n\n    async function testAsync() {\n        return \"hello async\";\n    }\n\n    const result = testAsync();\n    console.log(result);\n\n看到输出就恍然大悟了——输出的是一个 Promise 对象。\n\n    c:\\var\\test> node --harmony_async_await .\n    Promise { 'hello async' }\n\n所以，async 函数返回的是一个 Promise 对象。从[文档](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function)中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\n> 补充知识点 _\\[2020-06-04\\]_\n>\n> `Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样\n\n    testAsync().then(v => {\n        console.log(v);    // 输出 hello async\n    });\n\n现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n那么下一个关键点就在于 await 关键字了。\n\n### 1.2. await 到底在等啥\n\n一般来说，都认为 await 是在等待一个 async 函数完成。不过按[语法说明](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await)，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行\n\n    function getSomething() {\n        return \"something\";\n    }\n\n    async function testAsync() {\n        return Promise.resolve(\"hello async\");\n    }\n\n    async function test() {\n        const v1 = await getSomething();\n        const v2 = await testAsync();\n        console.log(v1, v2);\n    }\n\n    test();\n\n### 1.3. await 等到了要等的，然后呢\n\nawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，`await` 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。\n\n如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n\n如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n> 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n## 2\\. async/await 帮我们干了啥\n\n### 2.1. 作个简单的比较\n\n上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。\n\n现在举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写\n\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    takeLongTime().then(v => {\n        console.log(\"got\", v);\n    });\n\n如果改用 async/await 呢，会是这样\n\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    async function test() {\n        const v = await takeLongTime();\n        console.log(v);\n    }\n\n    test();\n\n眼尖的同学已经发现 `takeLongTime()` 没有申明为 `async`。实际上，`takeLongTime()` 本身就是返回的 Promise 对象，加不加 `async` 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。\n\n又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？\n\n### 2.2. async/await 的优势在于处理 then 链\n\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：\n\n    /**\n     * 传入参数 n，表示这个函数执行的时间（毫秒）\n     * 执行的结果是 n + 200，这个值将用于下一步骤\n     */\n    function takeLongTime(n) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(n + 200), n);\n        });\n    }\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(n) {\n        console.log(`step2 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step3(n) {\n        console.log(`step3 with ${n}`);\n        return takeLongTime(n);\n    }\n\n现在用 Promise 方式来实现这三个步骤的处理\n\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => step2(time2))\n            .then(time3 => step3(time3))\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 500\n    // step3 with 700\n    // result is 900\n    // doIt: 1507.251ms\n\n输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样\n\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time2);\n        const result = await step3(time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n### 2.3. 还有更酷的\n\n现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(m, n) {\n        console.log(`step2 with ${m} and ${n}`);\n        return takeLongTime(m + n);\n    }\n\n    function step3(k, m, n) {\n        console.log(`step3 with ${k}, ${m} and ${n}`);\n        return takeLongTime(k + m + n);\n    }\n\n这回先用 async/await 来写：\n\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time1, time2);\n        const result = await step3(time1, time2, time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 800 = 300 + 500\n    // step3 with 1800 = 300 + 500 + 1000\n    // result is 2000\n    // doIt: 2907.387ms\n\n除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？\n\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => {\n                return step2(time1, time2)\n                    .then(time3 => [time1, time2, time3]);\n            })\n            .then(times => {\n                const [time1, time2, time3] = times;\n                return step3(time1, time2, time3);\n            })\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！\n\n## 3\\. 洗洗睡吧\n\n就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？\n\n[阮一峰老师已经说过了](http://www.ruanyifeng.com/blog/2015/05/async.html)，我就懒得说了。\n\n## 4\\. 推荐相关文章\n\n- [在微信小程序中使用 async/await](https://segmentfault.com/a/1190000021966277) 2020-03-10\n- [代码审查，异步调用的常见问题剖析](https://segmentfault.com/a/1190000022349639) 2020-04-12\n- [Proxy 封装微信小程序的异步调用](https://segmentfault.com/a/1190000022315137) 2020-04-9\n- [改进异步封装：处理带返回值的异步调用](https://segmentfault.com/a/1190000022467002) 2020-04-25\n- [从地狱到天堂，Node 回调向 async/await 转变](https://segmentfault.com/a/1190000007987187) 2017-01-02\n- [异步编程需要“意识”](https://segmentfault.com/a/1190000013337421) 2018-02-23\n- [从不用 try-catch 实现的 async/await 语法说错误处理](https://segmentfault.com/a/1190000011802045) 2017-10-31\n\n## 5\\. 关于转载\n\n转载自[思否](https://segmentfault.com/a/1190000007535316) 作者[边城](https://segmentfault.com/u/jamesfancy)\n\n","slug":"理解 JavaScript 的 async&await","published":1,"updated":"2020-11-13T00:49:13.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g6v000jbwr41vww7i2s","content":"<h1 id=\"理解-JavaScript-的-async-await\"><a href=\"#理解-JavaScript-的-async-await\" class=\"headerlink\" title=\"理解 JavaScript 的 async/await\"></a><a href=\"\">理解 JavaScript 的 async/await</a></h1><p>JavaScript 中的 async/await 是 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction 特性</a> 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility\">这里</a> 查看。</p>\n<hr>\n<p>我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p>\n<p>我之前在<a href=\"https://segmentfault.com/a/1190000003742890\">《闲谈异步调用“扁平”化》</a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href=\"https://msdn.microsoft.com/library/dd321424.aspx\">Task 或 Task<Result></a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>。</p>\n<p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p>\n<h2 id=\"1-async-和-await-在干什么\"><a href=\"#1-async-和-await-在干什么\" class=\"headerlink\" title=\"1. async 和 await 在干什么\"></a>1. async 和 await 在干什么</h2><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p>\n<p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p>\n<p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p>\n<h3 id=\"1-1-async-起什么作用\"><a href=\"#1-1-async-起什么作用\" class=\"headerlink\" title=\"1.1. async 起什么作用\"></a>1.1. async 起什么作用</h3><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p>\n<p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p>\n<pre><code>async function testAsync() &#123;\n    return &quot;hello async&quot;;\n&#125;\n\nconst result = testAsync();\nconsole.log(result);</code></pre>\n<p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p>\n<pre><code>c:\\var\\test&gt; node --harmony_async_await .\nPromise &#123; &#39;hello async&#39; &#125;</code></pre>\n<p>所以，async 函数返回的是一个 Promise 对象。从<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function\">文档</a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>\n<blockquote>\n<p>补充知识点 <em>[2020-06-04]</em></p>\n<p><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>\n</blockquote>\n<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p>\n<pre><code>testAsync().then(v =&gt; &#123;\n    console.log(v);    // 输出 hello async\n&#125;);</code></pre>\n<p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>\n<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<p>那么下一个关键点就在于 await 关键字了。</p>\n<h3 id=\"1-2-await-到底在等啥\"><a href=\"#1-2-await-到底在等啥\" class=\"headerlink\" title=\"1.2. await 到底在等啥\"></a>1.2. await 到底在等啥</h3><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await\">语法说明</a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>\n<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p>\n<pre><code>function getSomething() &#123;\n    return &quot;something&quot;;\n&#125;\n\nasync function testAsync() &#123;\n    return Promise.resolve(&quot;hello async&quot;);\n&#125;\n\nasync function test() &#123;\n    const v1 = await getSomething();\n    const v2 = await testAsync();\n    console.log(v1, v2);\n&#125;\n\ntest();</code></pre>\n<h3 id=\"1-3-await-等到了要等的，然后呢\"><a href=\"#1-3-await-等到了要等的，然后呢\" class=\"headerlink\" title=\"1.3. await 等到了要等的，然后呢\"></a>1.3. await 等到了要等的，然后呢</h3><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p>\n<p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p>\n<p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p>\n<blockquote>\n<p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n</blockquote>\n<h2 id=\"2-async-await-帮我们干了啥\"><a href=\"#2-async-await-帮我们干了啥\" class=\"headerlink\" title=\"2. async/await 帮我们干了啥\"></a>2. async/await 帮我们干了啥</h2><h3 id=\"2-1-作个简单的比较\"><a href=\"#2-1-作个简单的比较\" class=\"headerlink\" title=\"2.1. 作个简单的比较\"></a>2.1. 作个简单的比较</h3><p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>\n<p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p>\n<pre><code>function takeLongTime() &#123;\n    return new Promise(resolve =&gt; &#123;\n        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);\n    &#125;);\n&#125;\n\ntakeLongTime().then(v =&gt; &#123;\n    console.log(&quot;got&quot;, v);\n&#125;);</code></pre>\n<p>如果改用 async/await 呢，会是这样</p>\n<pre><code>function takeLongTime() &#123;\n    return new Promise(resolve =&gt; &#123;\n        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);\n    &#125;);\n&#125;\n\nasync function test() &#123;\n    const v = await takeLongTime();\n    console.log(v);\n&#125;\n\ntest();</code></pre>\n<p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p>\n<p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p>\n<h3 id=\"2-2-async-await-的优势在于处理-then-链\"><a href=\"#2-2-async-await-的优势在于处理-then-链\" class=\"headerlink\" title=\"2.2. async/await 的优势在于处理 then 链\"></a>2.2. async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>\n<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p>\n<pre><code>/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) &#123;\n    return new Promise(resolve =&gt; &#123;\n        setTimeout(() =&gt; resolve(n + 200), n);\n    &#125;);\n&#125;\n\nfunction step1(n) &#123;\n    console.log(`step1 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;\n\nfunction step2(n) &#123;\n    console.log(`step2 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;\n\nfunction step3(n) &#123;\n    console.log(`step3 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;</code></pre>\n<p>现在用 Promise 方式来实现这三个步骤的处理</p>\n<pre><code>function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    step1(time1)\n        .then(time2 =&gt; step2(time2))\n        .then(time3 =&gt; step3(time3))\n        .then(result =&gt; &#123;\n            console.log(`result is $&#123;result&#125;`);\n            console.timeEnd(&quot;doIt&quot;);\n        &#125;);\n&#125;\n\ndoIt();\n\n// c:\\var\\test&gt;node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms</code></pre>\n<p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p>\n<p>如果用 async/await 来实现呢，会是这样</p>\n<pre><code>async function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is $&#123;result&#125;`);\n    console.timeEnd(&quot;doIt&quot;);\n&#125;\n\ndoIt();</code></pre>\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h3 id=\"2-3-还有更酷的\"><a href=\"#2-3-还有更酷的\" class=\"headerlink\" title=\"2.3. 还有更酷的\"></a>2.3. 还有更酷的</h3><p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p>\n<pre><code>function step1(n) &#123;\n    console.log(`step1 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;\n\nfunction step2(m, n) &#123;\n    console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`);\n    return takeLongTime(m + n);\n&#125;\n\nfunction step3(k, m, n) &#123;\n    console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`);\n    return takeLongTime(k + m + n);\n&#125;</code></pre>\n<p>这回先用 async/await 来写：</p>\n<pre><code>async function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time1, time2);\n    const result = await step3(time1, time2, time3);\n    console.log(`result is $&#123;result&#125;`);\n    console.timeEnd(&quot;doIt&quot;);\n&#125;\n\ndoIt();\n\n// c:\\var\\test&gt;node --harmony_async_await .\n// step1 with 300\n// step2 with 800 = 300 + 500\n// step3 with 1800 = 300 + 500 + 1000\n// result is 2000\n// doIt: 2907.387ms</code></pre>\n<p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p>\n<pre><code>function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    step1(time1)\n        .then(time2 =&gt; &#123;\n            return step2(time1, time2)\n                .then(time3 =&gt; [time1, time2, time3]);\n        &#125;)\n        .then(times =&gt; &#123;\n            const [time1, time2, time3] = times;\n            return step3(time1, time2, time3);\n        &#125;)\n        .then(result =&gt; &#123;\n            console.log(`result is $&#123;result&#125;`);\n            console.timeEnd(&quot;doIt&quot;);\n        &#125;);\n&#125;\n\ndoIt();</code></pre>\n<p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p>\n<h2 id=\"3-洗洗睡吧\"><a href=\"#3-洗洗睡吧\" class=\"headerlink\" title=\"3. 洗洗睡吧\"></a>3. 洗洗睡吧</h2><p>就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\">阮一峰老师已经说过了</a>，我就懒得说了。</p>\n<h2 id=\"4-推荐相关文章\"><a href=\"#4-推荐相关文章\" class=\"headerlink\" title=\"4. 推荐相关文章\"></a>4. 推荐相关文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000021966277\">在微信小程序中使用 async/await</a> 2020-03-10</li>\n<li><a href=\"https://segmentfault.com/a/1190000022349639\">代码审查，异步调用的常见问题剖析</a> 2020-04-12</li>\n<li><a href=\"https://segmentfault.com/a/1190000022315137\">Proxy 封装微信小程序的异步调用</a> 2020-04-9</li>\n<li><a href=\"https://segmentfault.com/a/1190000022467002\">改进异步封装：处理带返回值的异步调用</a> 2020-04-25</li>\n<li><a href=\"https://segmentfault.com/a/1190000007987187\">从地狱到天堂，Node 回调向 async/await 转变</a> 2017-01-02</li>\n<li><a href=\"https://segmentfault.com/a/1190000013337421\">异步编程需要“意识”</a> 2018-02-23</li>\n<li><a href=\"https://segmentfault.com/a/1190000011802045\">从不用 try-catch 实现的 async/await 语法说错误处理</a> 2017-10-31</li>\n</ul>\n<h2 id=\"5-关于转载\"><a href=\"#5-关于转载\" class=\"headerlink\" title=\"5. 关于转载\"></a>5. 关于转载</h2><p>转载自<a href=\"https://segmentfault.com/a/1190000007535316\">思否</a> 作者<a href=\"https://segmentfault.com/u/jamesfancy\">边城</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"理解-JavaScript-的-async-await\"><a href=\"#理解-JavaScript-的-async-await\" class=\"headerlink\" title=\"理解 JavaScript 的 async/await\"></a><a href=\"\">理解 JavaScript 的 async/await</a></h1><p>JavaScript 中的 async/await 是 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction 特性</a> 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility\">这里</a> 查看。</p>\n<hr>\n<p>我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p>\n<p>我之前在<a href=\"https://segmentfault.com/a/1190000003742890\">《闲谈异步调用“扁平”化》</a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href=\"https://msdn.microsoft.com/library/dd321424.aspx\">Task 或 Task<Result></a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>。</p>\n<p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p>\n<h2 id=\"1-async-和-await-在干什么\"><a href=\"#1-async-和-await-在干什么\" class=\"headerlink\" title=\"1. async 和 await 在干什么\"></a>1. async 和 await 在干什么</h2><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p>\n<p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p>\n<p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p>\n<h3 id=\"1-1-async-起什么作用\"><a href=\"#1-1-async-起什么作用\" class=\"headerlink\" title=\"1.1. async 起什么作用\"></a>1.1. async 起什么作用</h3><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p>\n<p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p>\n<pre><code>async function testAsync() &#123;\n    return &quot;hello async&quot;;\n&#125;\n\nconst result = testAsync();\nconsole.log(result);</code></pre>\n<p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p>\n<pre><code>c:\\var\\test&gt; node --harmony_async_await .\nPromise &#123; &#39;hello async&#39; &#125;</code></pre>\n<p>所以，async 函数返回的是一个 Promise 对象。从<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function\">文档</a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>\n<blockquote>\n<p>补充知识点 <em>[2020-06-04]</em></p>\n<p><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>\n</blockquote>\n<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p>\n<pre><code>testAsync().then(v =&gt; &#123;\n    console.log(v);    // 输出 hello async\n&#125;);</code></pre>\n<p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>\n<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<p>那么下一个关键点就在于 await 关键字了。</p>\n<h3 id=\"1-2-await-到底在等啥\"><a href=\"#1-2-await-到底在等啥\" class=\"headerlink\" title=\"1.2. await 到底在等啥\"></a>1.2. await 到底在等啥</h3><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await\">语法说明</a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>\n<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p>\n<pre><code>function getSomething() &#123;\n    return &quot;something&quot;;\n&#125;\n\nasync function testAsync() &#123;\n    return Promise.resolve(&quot;hello async&quot;);\n&#125;\n\nasync function test() &#123;\n    const v1 = await getSomething();\n    const v2 = await testAsync();\n    console.log(v1, v2);\n&#125;\n\ntest();</code></pre>\n<h3 id=\"1-3-await-等到了要等的，然后呢\"><a href=\"#1-3-await-等到了要等的，然后呢\" class=\"headerlink\" title=\"1.3. await 等到了要等的，然后呢\"></a>1.3. await 等到了要等的，然后呢</h3><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p>\n<p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p>\n<p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p>\n<blockquote>\n<p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n</blockquote>\n<h2 id=\"2-async-await-帮我们干了啥\"><a href=\"#2-async-await-帮我们干了啥\" class=\"headerlink\" title=\"2. async/await 帮我们干了啥\"></a>2. async/await 帮我们干了啥</h2><h3 id=\"2-1-作个简单的比较\"><a href=\"#2-1-作个简单的比较\" class=\"headerlink\" title=\"2.1. 作个简单的比较\"></a>2.1. 作个简单的比较</h3><p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>\n<p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p>\n<pre><code>function takeLongTime() &#123;\n    return new Promise(resolve =&gt; &#123;\n        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);\n    &#125;);\n&#125;\n\ntakeLongTime().then(v =&gt; &#123;\n    console.log(&quot;got&quot;, v);\n&#125;);</code></pre>\n<p>如果改用 async/await 呢，会是这样</p>\n<pre><code>function takeLongTime() &#123;\n    return new Promise(resolve =&gt; &#123;\n        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);\n    &#125;);\n&#125;\n\nasync function test() &#123;\n    const v = await takeLongTime();\n    console.log(v);\n&#125;\n\ntest();</code></pre>\n<p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p>\n<p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p>\n<h3 id=\"2-2-async-await-的优势在于处理-then-链\"><a href=\"#2-2-async-await-的优势在于处理-then-链\" class=\"headerlink\" title=\"2.2. async/await 的优势在于处理 then 链\"></a>2.2. async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>\n<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p>\n<pre><code>/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) &#123;\n    return new Promise(resolve =&gt; &#123;\n        setTimeout(() =&gt; resolve(n + 200), n);\n    &#125;);\n&#125;\n\nfunction step1(n) &#123;\n    console.log(`step1 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;\n\nfunction step2(n) &#123;\n    console.log(`step2 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;\n\nfunction step3(n) &#123;\n    console.log(`step3 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;</code></pre>\n<p>现在用 Promise 方式来实现这三个步骤的处理</p>\n<pre><code>function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    step1(time1)\n        .then(time2 =&gt; step2(time2))\n        .then(time3 =&gt; step3(time3))\n        .then(result =&gt; &#123;\n            console.log(`result is $&#123;result&#125;`);\n            console.timeEnd(&quot;doIt&quot;);\n        &#125;);\n&#125;\n\ndoIt();\n\n// c:\\var\\test&gt;node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms</code></pre>\n<p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p>\n<p>如果用 async/await 来实现呢，会是这样</p>\n<pre><code>async function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is $&#123;result&#125;`);\n    console.timeEnd(&quot;doIt&quot;);\n&#125;\n\ndoIt();</code></pre>\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h3 id=\"2-3-还有更酷的\"><a href=\"#2-3-还有更酷的\" class=\"headerlink\" title=\"2.3. 还有更酷的\"></a>2.3. 还有更酷的</h3><p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p>\n<pre><code>function step1(n) &#123;\n    console.log(`step1 with $&#123;n&#125;`);\n    return takeLongTime(n);\n&#125;\n\nfunction step2(m, n) &#123;\n    console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`);\n    return takeLongTime(m + n);\n&#125;\n\nfunction step3(k, m, n) &#123;\n    console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`);\n    return takeLongTime(k + m + n);\n&#125;</code></pre>\n<p>这回先用 async/await 来写：</p>\n<pre><code>async function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time1, time2);\n    const result = await step3(time1, time2, time3);\n    console.log(`result is $&#123;result&#125;`);\n    console.timeEnd(&quot;doIt&quot;);\n&#125;\n\ndoIt();\n\n// c:\\var\\test&gt;node --harmony_async_await .\n// step1 with 300\n// step2 with 800 = 300 + 500\n// step3 with 1800 = 300 + 500 + 1000\n// result is 2000\n// doIt: 2907.387ms</code></pre>\n<p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p>\n<pre><code>function doIt() &#123;\n    console.time(&quot;doIt&quot;);\n    const time1 = 300;\n    step1(time1)\n        .then(time2 =&gt; &#123;\n            return step2(time1, time2)\n                .then(time3 =&gt; [time1, time2, time3]);\n        &#125;)\n        .then(times =&gt; &#123;\n            const [time1, time2, time3] = times;\n            return step3(time1, time2, time3);\n        &#125;)\n        .then(result =&gt; &#123;\n            console.log(`result is $&#123;result&#125;`);\n            console.timeEnd(&quot;doIt&quot;);\n        &#125;);\n&#125;\n\ndoIt();</code></pre>\n<p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p>\n<h2 id=\"3-洗洗睡吧\"><a href=\"#3-洗洗睡吧\" class=\"headerlink\" title=\"3. 洗洗睡吧\"></a>3. 洗洗睡吧</h2><p>就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\">阮一峰老师已经说过了</a>，我就懒得说了。</p>\n<h2 id=\"4-推荐相关文章\"><a href=\"#4-推荐相关文章\" class=\"headerlink\" title=\"4. 推荐相关文章\"></a>4. 推荐相关文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000021966277\">在微信小程序中使用 async/await</a> 2020-03-10</li>\n<li><a href=\"https://segmentfault.com/a/1190000022349639\">代码审查，异步调用的常见问题剖析</a> 2020-04-12</li>\n<li><a href=\"https://segmentfault.com/a/1190000022315137\">Proxy 封装微信小程序的异步调用</a> 2020-04-9</li>\n<li><a href=\"https://segmentfault.com/a/1190000022467002\">改进异步封装：处理带返回值的异步调用</a> 2020-04-25</li>\n<li><a href=\"https://segmentfault.com/a/1190000007987187\">从地狱到天堂，Node 回调向 async/await 转变</a> 2017-01-02</li>\n<li><a href=\"https://segmentfault.com/a/1190000013337421\">异步编程需要“意识”</a> 2018-02-23</li>\n<li><a href=\"https://segmentfault.com/a/1190000011802045\">从不用 try-catch 实现的 async/await 语法说错误处理</a> 2017-10-31</li>\n</ul>\n<h2 id=\"5-关于转载\"><a href=\"#5-关于转载\" class=\"headerlink\" title=\"5. 关于转载\"></a>5. 关于转载</h2><p>转载自<a href=\"https://segmentfault.com/a/1190000007535316\">思否</a> 作者<a href=\"https://segmentfault.com/u/jamesfancy\">边城</a></p>\n"},{"title":"彻底理解Promise原理及全功能实现","date":"2020-11-20T04:26:22.000Z","author":"heyXiao","summary":"Promise 作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影","_content":"\n# 彻底理解 Promise 原理及全功能实现\n\n## 开篇\n\n**Promise**作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如**Vue**的批量处理等。今天我们就按照**Promise A+** 规范来完整实现**Promise**全功能，话不多说，上代码。\n\n## Promise 实现\n\n### status 状态定义\n\n**Promise**的设定是一个不可逆的状态机，包含：\n\n    const PENDDING = \"PENDDING\"; // 初始化pendding状态\n    const RESOLVED = \"RESOLVED\"; // 正确完成resolve状态\n    const REJECTED = \"REJECTED\"; // 错误完成reject状态\n\n### MyPromise\n\n创建**MyPromise**类函数和初始化相对应的值和状态\n\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.status = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n    }\n\n### MyPromise.then\n\n#### 同步和异步\n\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 完成状态，推入完成队列\n        if (this.status === RESOLVED) {\n          resolve(this.value);\n        }\n\n        // 拒绝状态，推入拒绝队列\n        if (this.status === REJECTED) {\n          reject(this.reason);\n        }\n\n        // 异步情况\n        if (this.status === PENDDING) {\n          this.resolves.push(resolve);\n          this.rejects.push(reject);\n        }\n      }\n      // ...\n    }\n\n    // 测试同步任务\n\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('promise sync')\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise sync\n\n    // 测试异步任务\n    const promise = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('promise async)\n        }, 500)\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise async\n\n#### Promise A+规范场景\n\n> 根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。\n\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      resolve(\"first\");\n    });\n\n    // 第一种场景：返回常规值\n    promise\n      .then((res) => {\n        console.log(res);\n\n        return \"second\";\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // second\n\n    // 第二种场景：返回promise\n    promise\n      .then((res) => {\n        console.log(res);\n        return new Promise((resolve) => {\n          resolve(\"promise\");\n        });\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // promise\n\n    // 第三种场景：值穿透\n    promise\n      .then((res) => {\n        console.log(res);\n        return res;\n      })\n      .then()\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // first\n\n#### 实现 then\n\n根据以上规范定义，我们来改造一下**then**方法：\n\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason )\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('first')\n    })\n\n    promise.then(res => {\n        console.log(res)\n        return new MyPromise((resolve, reject) => {\n            resolve('promise second')\n        })\n    }).then().then(res => {\n        console.log(res)\n        return 'third'\n    }).then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // first\n    // promise second\n    // third\n\n#### 小结\n\n测试成功，**promise**的改造就算符合规范了。这个难点在于**then**内函数的返回值如果是**promise**，那么我们会先让他执行注册一次**then**，让**promise**接着往下执行。\n\n### MyPromise.catch\n\n**catch**方法相对比较简单，将拒绝的值放到**reject**方法里执行就可以。\n\n#### Promise A+规范场景\n\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      reject(\"promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // promise reject\n\n#### 实现 catch\n\n    class MyPromise {\n      // ...\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n      reject(\"my promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // my promise reject\n\n#### 小结\n\n**catch**方法在于执行回调去获取**reject**的结果，所以只需执行一下**then**并传入**callback**就实现了，相对好理解。\n\n### MyPromise.all\n\n业务场景中，我们经常会遇到不止一个**promie**的场景，因此需要合并一次执行多个**promise**，统一返回结果，**Promise.all**就是为了解决此问题。\n\n#### Promise A+规范场景\n\n      // Promise A+\n      // 创建三个promise\n      const promise1 = Promise.resolve(1)\n      const promise2 = Promise.resolve(2)\n      const promise3 = Promise.resolve(3)\n\n      Promise.all([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // [1,2,3]\n\n      // 添加一个reject\n      const promise4 = Promise.resolve(1)\n      const promise5 = Promise.reject('reject')\n      const promise6 = Promise.resolve(3)\n\n      Promise.all([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n      // reject\n\n> 根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。\n\n#### 实现 Promise.all\n\n我们来实现一下：\n\n      class MyPromise {\n        // ...\n        // all是静态方法\n        static all(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push(res)\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  reject(e instanceof Error ? e.message : e)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push(promise)\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n        // ...\n      }\n\n      // 测试\n      // 创建三个MyPromise\n      const promise1 = MyPromise.resolve(1)\n      const promise2 = MyPromise.resolve(2)\n      const promise3 = MyPromise.resolve(3)\n\n      MyPromise.all([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // [1,2,3]\n\n      // 添加一个reject\n      const promise4 = MyPromise.resolve(1)\n      const promise5 = MyPromise.reject('reject')\n      const promise6 = MyPromise.resolve(3)\n\n      MyPromise.all([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n      // reject\n\n#### 小结\n\n**Promise.all**作为一个批量处理的函数，让我们在使用时可以同时多个处理**promise**，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个**promise**后再去执行下一个**promise**，处理完这个逻辑也就基本完成了**Promise.all**的全功能了。\n\n### MyPromise.resolve\n\n静态方法**resolve**的实现就相对简单了，返回一个**promise**，传入对应参数即可。\n\n#### 实现 MyPromise.resolve\n\n      class MyPromise {\n        // ...\n        static resolve(value) {\n          return new MyPromise((resolveFn, rejectFn) => {\n            resolveFn(value)\n          })\n        }\n        // ...\n      }\n\n      // 测试\n      MyPromise.resolve('static resolve').then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // static resolve\n\n### MyPromise.reject\n\n静态方法**reject**的实现跟**resolve**是类似，返回一个**promise**，传入对应参数即可。\n\n      class MyPromise {\n        // ...\n        static reject(reason) {\n          return new MyPromise((resolveFn, rejectFn) => {\n            rejectFn(reason)\n          })\n        }\n        // ...\n      }\n\n      // 测试\n      MyPromise.reject('static reject').catch(e => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // static reject\n\n### 什么是 allSettled？\n\nECMA 官网最新更新了**Promise**的新的静态方法**Promise.allSettled**，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理**Promise**的函数，但是我们已经有了**Promise.all**，为什么还需要**allSettled**。要解开这个问题，我们得回顾一下**Promise.all**。现有的**Promise.all**我们说过，如果**Promise**队列里有一个**reject**，那么他就只会返回**reject**，所以**Promise.all**不一定会返回所有结果，很显然**Promise.allSettled**能够解决这个问题。\n\n#### Promise A+测试场景\n\n       // Promise A+\n      // 创建三个promise\n      const promise1 = Promise.resolve(1)\n      const promise2 = Promise.resolve(2)\n      const promise3 = Promise.resolve(3)\n\n      Promise.allSettled([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'fulfilished', value: 2},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n      // 添加一个reject\n      const promise4 = Promise.resolve(1)\n      const promise5 = Promise.reject('reject')\n      const promise6 = Promise.resolve(3)\n\n      Promise.allSettled([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n       /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'rejected', value: 'reject'},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n可以看出来**allSettled**和 all 最大的区别就是，**allSettled**不管是**resolve**，还是**reject**都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，**status**描述状态，**value**接收返回值。\n\n#### 实现 MyPromise.allSettled\n\n**allSettled**的整体逻辑跟**all**是一样的，只不过返回值的处理稍微有所不同\n\n      class MyPromise {\n    // ...\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n      // ...\n      }\n\n      // 测试\n      // 创建三个promise\n      const promise1 = MyPromise.resolve(1)\n      const promise2 = MyPromise.resolve(2)\n      const promise3 = MyPromise.resolve(3)\n\n      MyPromise.allSettled([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'fulfilished', value: 2},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n      // 添加一个reject\n      const promise4 = MyPromise.resolve(1)\n      const promise5 = MyPromise.reject('reject')\n      const promise6 = MyPromise.resolve(3)\n\n      Promise.allSettled([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n       /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'rejected', value: 'reject'},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n## 完整代码\n\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.statue = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n\n      // then\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n\n      // resolve\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n\n        // reject\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n\n      // all\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n\n      // allSettled\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n    }\n\n## 总结\n\n至此**Promise A+**的完整的方法和实现就完成了，个人觉得实现**promise**的难点在于理解**then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然\n\n## 关于转载\n\n转载自[掘金](https://juejin.cn/post/6866372840451473415#heading-0) 作者[MichaelHong](https://juejin.cn/user/448256474885159)\n","source":"_posts/彻底理解Promise原理及全功能实现.md","raw":"---\ntitle: 彻底理解Promise原理及全功能实现\ndate: 2020-11-20 12:26:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: Promise 作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影\ncategories: 技术\ntags:\n  - JavaScript\n  - 转载\n---\n\n# 彻底理解 Promise 原理及全功能实现\n\n## 开篇\n\n**Promise**作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如**Vue**的批量处理等。今天我们就按照**Promise A+** 规范来完整实现**Promise**全功能，话不多说，上代码。\n\n## Promise 实现\n\n### status 状态定义\n\n**Promise**的设定是一个不可逆的状态机，包含：\n\n    const PENDDING = \"PENDDING\"; // 初始化pendding状态\n    const RESOLVED = \"RESOLVED\"; // 正确完成resolve状态\n    const REJECTED = \"REJECTED\"; // 错误完成reject状态\n\n### MyPromise\n\n创建**MyPromise**类函数和初始化相对应的值和状态\n\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.status = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n    }\n\n### MyPromise.then\n\n#### 同步和异步\n\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 完成状态，推入完成队列\n        if (this.status === RESOLVED) {\n          resolve(this.value);\n        }\n\n        // 拒绝状态，推入拒绝队列\n        if (this.status === REJECTED) {\n          reject(this.reason);\n        }\n\n        // 异步情况\n        if (this.status === PENDDING) {\n          this.resolves.push(resolve);\n          this.rejects.push(reject);\n        }\n      }\n      // ...\n    }\n\n    // 测试同步任务\n\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('promise sync')\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise sync\n\n    // 测试异步任务\n    const promise = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('promise async)\n        }, 500)\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise async\n\n#### Promise A+规范场景\n\n> 根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。\n\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      resolve(\"first\");\n    });\n\n    // 第一种场景：返回常规值\n    promise\n      .then((res) => {\n        console.log(res);\n\n        return \"second\";\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // second\n\n    // 第二种场景：返回promise\n    promise\n      .then((res) => {\n        console.log(res);\n        return new Promise((resolve) => {\n          resolve(\"promise\");\n        });\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // promise\n\n    // 第三种场景：值穿透\n    promise\n      .then((res) => {\n        console.log(res);\n        return res;\n      })\n      .then()\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // first\n\n#### 实现 then\n\n根据以上规范定义，我们来改造一下**then**方法：\n\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason )\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('first')\n    })\n\n    promise.then(res => {\n        console.log(res)\n        return new MyPromise((resolve, reject) => {\n            resolve('promise second')\n        })\n    }).then().then(res => {\n        console.log(res)\n        return 'third'\n    }).then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // first\n    // promise second\n    // third\n\n#### 小结\n\n测试成功，**promise**的改造就算符合规范了。这个难点在于**then**内函数的返回值如果是**promise**，那么我们会先让他执行注册一次**then**，让**promise**接着往下执行。\n\n### MyPromise.catch\n\n**catch**方法相对比较简单，将拒绝的值放到**reject**方法里执行就可以。\n\n#### Promise A+规范场景\n\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      reject(\"promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // promise reject\n\n#### 实现 catch\n\n    class MyPromise {\n      // ...\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n      reject(\"my promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // my promise reject\n\n#### 小结\n\n**catch**方法在于执行回调去获取**reject**的结果，所以只需执行一下**then**并传入**callback**就实现了，相对好理解。\n\n### MyPromise.all\n\n业务场景中，我们经常会遇到不止一个**promie**的场景，因此需要合并一次执行多个**promise**，统一返回结果，**Promise.all**就是为了解决此问题。\n\n#### Promise A+规范场景\n\n      // Promise A+\n      // 创建三个promise\n      const promise1 = Promise.resolve(1)\n      const promise2 = Promise.resolve(2)\n      const promise3 = Promise.resolve(3)\n\n      Promise.all([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // [1,2,3]\n\n      // 添加一个reject\n      const promise4 = Promise.resolve(1)\n      const promise5 = Promise.reject('reject')\n      const promise6 = Promise.resolve(3)\n\n      Promise.all([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n      // reject\n\n> 根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。\n\n#### 实现 Promise.all\n\n我们来实现一下：\n\n      class MyPromise {\n        // ...\n        // all是静态方法\n        static all(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push(res)\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  reject(e instanceof Error ? e.message : e)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push(promise)\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n        // ...\n      }\n\n      // 测试\n      // 创建三个MyPromise\n      const promise1 = MyPromise.resolve(1)\n      const promise2 = MyPromise.resolve(2)\n      const promise3 = MyPromise.resolve(3)\n\n      MyPromise.all([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // [1,2,3]\n\n      // 添加一个reject\n      const promise4 = MyPromise.resolve(1)\n      const promise5 = MyPromise.reject('reject')\n      const promise6 = MyPromise.resolve(3)\n\n      MyPromise.all([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n      // reject\n\n#### 小结\n\n**Promise.all**作为一个批量处理的函数，让我们在使用时可以同时多个处理**promise**，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个**promise**后再去执行下一个**promise**，处理完这个逻辑也就基本完成了**Promise.all**的全功能了。\n\n### MyPromise.resolve\n\n静态方法**resolve**的实现就相对简单了，返回一个**promise**，传入对应参数即可。\n\n#### 实现 MyPromise.resolve\n\n      class MyPromise {\n        // ...\n        static resolve(value) {\n          return new MyPromise((resolveFn, rejectFn) => {\n            resolveFn(value)\n          })\n        }\n        // ...\n      }\n\n      // 测试\n      MyPromise.resolve('static resolve').then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // static resolve\n\n### MyPromise.reject\n\n静态方法**reject**的实现跟**resolve**是类似，返回一个**promise**，传入对应参数即可。\n\n      class MyPromise {\n        // ...\n        static reject(reason) {\n          return new MyPromise((resolveFn, rejectFn) => {\n            rejectFn(reason)\n          })\n        }\n        // ...\n      }\n\n      // 测试\n      MyPromise.reject('static reject').catch(e => {\n        console.log(res)\n      })\n\n      // 打印结果\n      // static reject\n\n### 什么是 allSettled？\n\nECMA 官网最新更新了**Promise**的新的静态方法**Promise.allSettled**，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理**Promise**的函数，但是我们已经有了**Promise.all**，为什么还需要**allSettled**。要解开这个问题，我们得回顾一下**Promise.all**。现有的**Promise.all**我们说过，如果**Promise**队列里有一个**reject**，那么他就只会返回**reject**，所以**Promise.all**不一定会返回所有结果，很显然**Promise.allSettled**能够解决这个问题。\n\n#### Promise A+测试场景\n\n       // Promise A+\n      // 创建三个promise\n      const promise1 = Promise.resolve(1)\n      const promise2 = Promise.resolve(2)\n      const promise3 = Promise.resolve(3)\n\n      Promise.allSettled([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'fulfilished', value: 2},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n      // 添加一个reject\n      const promise4 = Promise.resolve(1)\n      const promise5 = Promise.reject('reject')\n      const promise6 = Promise.resolve(3)\n\n      Promise.allSettled([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n       /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'rejected', value: 'reject'},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n可以看出来**allSettled**和 all 最大的区别就是，**allSettled**不管是**resolve**，还是**reject**都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，**status**描述状态，**value**接收返回值。\n\n#### 实现 MyPromise.allSettled\n\n**allSettled**的整体逻辑跟**all**是一样的，只不过返回值的处理稍微有所不同\n\n      class MyPromise {\n    // ...\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n      // ...\n      }\n\n      // 测试\n      // 创建三个promise\n      const promise1 = MyPromise.resolve(1)\n      const promise2 = MyPromise.resolve(2)\n      const promise3 = MyPromise.resolve(3)\n\n      MyPromise.allSettled([promise1,promise12,promise3]).then(res => {\n        console.log(res)\n      })\n\n      // 打印结果\n      /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'fulfilished', value: 2},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n      // 添加一个reject\n      const promise4 = MyPromise.resolve(1)\n      const promise5 = MyPromise.reject('reject')\n      const promise6 = MyPromise.resolve(3)\n\n      Promise.allSettled([promise4, promise5,promise6]).then(res => {\n        console.log(res, 'resolve')\n      }).catch(e => {\n        console.log(e)\n      })\n\n      // 打印结果\n       /*\n      [\n        {status: 'fulfilished', value: 1},\n        {status: 'rejected', value: 'reject'},\n        {status: 'fulfilished', value: 3}\n      ]\n      */\n\n## 完整代码\n\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.statue = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n\n      // then\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n\n      // resolve\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n\n        // reject\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n\n      // all\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n\n      // allSettled\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n    }\n\n## 总结\n\n至此**Promise A+**的完整的方法和实现就完成了，个人觉得实现**promise**的难点在于理解**then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然\n\n## 关于转载\n\n转载自[掘金](https://juejin.cn/post/6866372840451473415#heading-0) 作者[MichaelHong](https://juejin.cn/user/448256474885159)\n","slug":"彻底理解Promise原理及全功能实现","published":1,"updated":"2020-11-20T03:21:43.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g75001lbwr45vlf9b07","content":"<h1 id=\"彻底理解-Promise-原理及全功能实现\"><a href=\"#彻底理解-Promise-原理及全功能实现\" class=\"headerlink\" title=\"彻底理解 Promise 原理及全功能实现\"></a>彻底理解 Promise 原理及全功能实现</h1><h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p><strong>Promise</strong>作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如<strong>Vue</strong>的批量处理等。今天我们就按照<strong>Promise A+</strong> 规范来完整实现<strong>Promise</strong>全功能，话不多说，上代码。</p>\n<h2 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h2><h3 id=\"status-状态定义\"><a href=\"#status-状态定义\" class=\"headerlink\" title=\"status 状态定义\"></a>status 状态定义</h3><p><strong>Promise</strong>的设定是一个不可逆的状态机，包含：</p>\n<pre><code>const PENDDING = &quot;PENDDING&quot;; // 初始化pendding状态\nconst RESOLVED = &quot;RESOLVED&quot;; // 正确完成resolve状态\nconst REJECTED = &quot;REJECTED&quot;; // 错误完成reject状态</code></pre>\n<h3 id=\"MyPromise\"><a href=\"#MyPromise\" class=\"headerlink\" title=\"MyPromise\"></a>MyPromise</h3><p>创建<strong>MyPromise</strong>类函数和初始化相对应的值和状态</p>\n<pre><code>class MyPromise &#123;\n  constructor(executor) &#123;\n    // 初始化状态status\n    // 返回值value\n    // 错误原因reason\n    this.status = PENDDING;\n    this.value = undefined;\n    this.reason = undefined;\n\n    // 返回值回调队列和错误回调队列\n    this.resolves = [];\n    this.rejects = [];\n\n    // 声明resolve函数\n    const resolve = (value) =&gt; &#123;\n      if (this.status === PENDDING) &#123;\n        this.status = RESOLVED; // 变更状态为完成状态\n        this.value = value; // 赋值\n\n        // 执行resolves队列\n        while (this.resolves.length) &#123;\n          const callback = this.resolves.shift();\n          callback(value);\n        &#125;\n      &#125;\n    &#125;;\n\n    // 声明reject函数\n    const reject = (reason) =&gt; &#123;\n      if (this.statue === PENDDING) &#123;\n        this.status = REJECTED; // 变更状态为拒绝状态\n        this.reason = reason; // 赋值\n\n        // 执行rejects队列\n        while (this.rejects.length) &#123;\n          const callback = this.rejects.shift();\n          callback(reason);\n        &#125;\n      &#125;\n    &#125;;\n\n    try&#123;\n        executor(resolve,reject)\n    &#125;catch(e)&#123;\n        reject(e)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h3 id=\"MyPromise-then\"><a href=\"#MyPromise-then\" class=\"headerlink\" title=\"MyPromise.then\"></a>MyPromise.then</h3><h4 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h4><pre><code>class MyPromise &#123;\n  // ...\n  then(resolve, reject) &#123;\n    // 完成状态，推入完成队列\n    if (this.status === RESOLVED) &#123;\n      resolve(this.value);\n    &#125;\n\n    // 拒绝状态，推入拒绝队列\n    if (this.status === REJECTED) &#123;\n      reject(this.reason);\n    &#125;\n\n    // 异步情况\n    if (this.status === PENDDING) &#123;\n      this.resolves.push(resolve);\n      this.rejects.push(reject);\n    &#125;\n  &#125;\n  // ...\n&#125;\n\n// 测试同步任务\n\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n    resolve(&#39;promise sync&#39;)\n&#125;)\n\npromise.then(res =&gt; &#123;\n    console.log(res)\n&#125;)\n\n// 打印结果\n// promise sync\n\n// 测试异步任务\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        resolve(&#39;promise async)\n    &#125;, 500)\n&#125;)\n\npromise.then(res =&gt; &#123;\n    console.log(res)\n&#125;)\n\n// 打印结果\n// promise async</code></pre>\n<h4 id=\"Promise-A-规范场景\"><a href=\"#Promise-A-规范场景\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><blockquote>\n<p>根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。</p>\n</blockquote>\n<pre><code>// Promise A+\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  resolve(&quot;first&quot;);\n&#125;);\n\n// 第一种场景：返回常规值\npromise\n  .then((res) =&gt; &#123;\n    console.log(res);\n\n    return &quot;second&quot;;\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\n\n// 打印结果\n// first\n// second\n\n// 第二种场景：返回promise\npromise\n  .then((res) =&gt; &#123;\n    console.log(res);\n    return new Promise((resolve) =&gt; &#123;\n      resolve(&quot;promise&quot;);\n    &#125;);\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\n\n// 打印结果\n// first\n// promise\n\n// 第三种场景：值穿透\npromise\n  .then((res) =&gt; &#123;\n    console.log(res);\n    return res;\n  &#125;)\n  .then()\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\n\n// 打印结果\n// first\n// first</code></pre>\n<h4 id=\"实现-then\"><a href=\"#实现-then\" class=\"headerlink\" title=\"实现 then\"></a>实现 then</h4><p>根据以上规范定义，我们来改造一下<strong>then</strong>方法：</p>\n<pre><code>class MyPromise &#123;\n  // ...\n  then(resolve, reject) &#123;\n    // 判断resolve和reject未传入的情况，解决空值透传问题\n    // then()情况\n    typeof resolve !== &#39;function&#39; ? resolve = value =&gt; value : resolve\n    typeof reject !== &#39;function&#39; ? reject = reason =&gt; throw new Error(reason instanceof Error ? reason.message : reason )\n\n    //根据规范，then会返回一个全新的promise\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        // 重写传入的resolve方法\n        // 判断返回值\n        const fulfilished = value =&gt; &#123;\n            try&#123;\n                // 接收返回值\n                const res = resolve(value)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n            &#125;catch(e) &#123;\n                rejectFn(e)\n            &#125;\n        &#125;\n\n        // 重写传入的reject方法\n        // 判断返回值\n        const rejected = reason =&gt; &#123;\n            try&#123;\n        // 接收返回值\n                const res = reject(reason)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n            &#125;catch(e)&#123;\n                rejectFn(e instanceof Error ? e.message: e)\n            &#125;\n\n        &#125;\n\n        // 判断同步异步任务\n        // 执行相对应的方法\n        // 这里用switch方法改进\n        switch(this.status) &#123;\n            case RESOLVED:\n                fulfilished(this.value)\n            break;\n\n            case REJECTED:\n                rejected(this.reason)\n            break;\n\n            case PENDDING:\n                this.resolves.push(fulfilished)\n                this.rejects.push(rejected)\n              break;\n        &#125;\n    &#125;)\n\n  &#125;\n  // ...\n&#125;\n\n// 测试\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n    resolve(&#39;first&#39;)\n&#125;)\n\npromise.then(res =&gt; &#123;\n    console.log(res)\n    return new MyPromise((resolve, reject) =&gt; &#123;\n        resolve(&#39;promise second&#39;)\n    &#125;)\n&#125;).then().then(res =&gt; &#123;\n    console.log(res)\n    return &#39;third&#39;\n&#125;).then(res =&gt; &#123;\n    console.log(res)\n&#125;)\n\n// 打印结果\n// first\n// promise second\n// third</code></pre>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>测试成功，<strong>promise</strong>的改造就算符合规范了。这个难点在于<strong>then</strong>内函数的返回值如果是<strong>promise</strong>，那么我们会先让他执行注册一次<strong>then</strong>，让<strong>promise</strong>接着往下执行。</p>\n<h3 id=\"MyPromise-catch\"><a href=\"#MyPromise-catch\" class=\"headerlink\" title=\"MyPromise.catch\"></a>MyPromise.catch</h3><p><strong>catch</strong>方法相对比较简单，将拒绝的值放到<strong>reject</strong>方法里执行就可以。</p>\n<h4 id=\"Promise-A-规范场景-1\"><a href=\"#Promise-A-规范场景-1\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre><code>// Promise A+\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  reject(&quot;promise reject&quot;);\n&#125;);\n\npromise.catch((e) =&gt; &#123;\n  console.log(e);\n&#125;);\n\n// 打印结果\n// promise reject</code></pre>\n<h4 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch\"></a>实现 catch</h4><pre><code>class MyPromise &#123;\n  // ...\n  catch(errorFn) &#123;\n    // 这里只需注册执行下then，传入callback就能实现\n    this.then(null, errorFn);\n  &#125;\n  // ...\n&#125;\n\n// 测试\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n  reject(&quot;my promise reject&quot;);\n&#125;);\n\npromise.catch((e) =&gt; &#123;\n  console.log(e);\n&#125;);\n\n// 打印结果\n// my promise reject</code></pre>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>catch</strong>方法在于执行回调去获取<strong>reject</strong>的结果，所以只需执行一下<strong>then</strong>并传入<strong>callback</strong>就实现了，相对好理解。</p>\n<h3 id=\"MyPromise-all\"><a href=\"#MyPromise-all\" class=\"headerlink\" title=\"MyPromise.all\"></a>MyPromise.all</h3><p>业务场景中，我们经常会遇到不止一个<strong>promie</strong>的场景，因此需要合并一次执行多个<strong>promise</strong>，统一返回结果，<strong>Promise.all</strong>就是为了解决此问题。</p>\n<h4 id=\"Promise-A-规范场景-2\"><a href=\"#Promise-A-规范场景-2\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre><code>  // Promise A+\n  // 创建三个promise\n  const promise1 = Promise.resolve(1)\n  const promise2 = Promise.resolve(2)\n  const promise3 = Promise.resolve(3)\n\n  Promise.all([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // [1,2,3]\n\n  // 添加一个reject\n  const promise4 = Promise.resolve(1)\n  const promise5 = Promise.reject(&#39;reject&#39;)\n  const promise6 = Promise.resolve(3)\n\n  Promise.all([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n  // reject</code></pre>\n<blockquote>\n<p>根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。</p>\n</blockquote>\n<h4 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h4><p>我们来实现一下：</p>\n<pre><code>  class MyPromise &#123;\n    // ...\n    // all是静态方法\n    static all(promises) &#123;\n      // 已然是返回一个promise\n      return new MyPromise((resolve, reject) =&gt; &#123;\n        // 创建一个收集返回值的数组\n        const result = []\n\n        // 执行\n        deepPromise(promises[0], 0 , result)\n\n        // 返回结果\n        resolve(result)\n\n        // 这里我们用递归来实现\n        // @param &#123;MyPromise&#125; promise 每一个promise方法\n        // @param &#123;number&#125; index 索引\n        // @param &#123;string[]&#125; result 收集返回结果的数组\n        function deepPromise(promise, index, result) &#123;\n          // 边界判断\n          // 所有执行完之后返回收集数组\n          if(index &gt; promises.length - 1) &#123;\n            return result\n          &#125;\n\n          if(typeof promise.then === &#39;function&#39;) &#123;\n            // 如果是promise\n            promise.then(res =&gt; &#123;\n              index++\n              result.push(res)\n              deepPromise(promises[index], index, result)\n            &#125;).catch(e =&gt; &#123;\n              // reject直接返回\n              reject(e instanceof Error ? e.message : e)\n            &#125;)\n          &#125;else &#123;\n            // 如果是普通值\n            // 这里我们只做简单判断，非promise则直接当返回值处理\n            index++\n            result.push(promise)\n            deepPromise(promises[index], index, res)\n          &#125;\n        &#125;\n      &#125;)\n\n    &#125;\n    // ...\n  &#125;\n\n  // 测试\n  // 创建三个MyPromise\n  const promise1 = MyPromise.resolve(1)\n  const promise2 = MyPromise.resolve(2)\n  const promise3 = MyPromise.resolve(3)\n\n  MyPromise.all([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // [1,2,3]\n\n  // 添加一个reject\n  const promise4 = MyPromise.resolve(1)\n  const promise5 = MyPromise.reject(&#39;reject&#39;)\n  const promise6 = MyPromise.resolve(3)\n\n  MyPromise.all([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n  // reject</code></pre>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>Promise.all</strong>作为一个批量处理的函数，让我们在使用时可以同时多个处理<strong>promise</strong>，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个<strong>promise</strong>后再去执行下一个<strong>promise</strong>，处理完这个逻辑也就基本完成了<strong>Promise.all</strong>的全功能了。</p>\n<h3 id=\"MyPromise-resolve\"><a href=\"#MyPromise-resolve\" class=\"headerlink\" title=\"MyPromise.resolve\"></a>MyPromise.resolve</h3><p>静态方法<strong>resolve</strong>的实现就相对简单了，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<h4 id=\"实现-MyPromise-resolve\"><a href=\"#实现-MyPromise-resolve\" class=\"headerlink\" title=\"实现 MyPromise.resolve\"></a>实现 MyPromise.resolve</h4><pre><code>  class MyPromise &#123;\n    // ...\n    static resolve(value) &#123;\n      return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        resolveFn(value)\n      &#125;)\n    &#125;\n    // ...\n  &#125;\n\n  // 测试\n  MyPromise.resolve(&#39;static resolve&#39;).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // static resolve</code></pre>\n<h3 id=\"MyPromise-reject\"><a href=\"#MyPromise-reject\" class=\"headerlink\" title=\"MyPromise.reject\"></a>MyPromise.reject</h3><p>静态方法<strong>reject</strong>的实现跟<strong>resolve</strong>是类似，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<pre><code>  class MyPromise &#123;\n    // ...\n    static reject(reason) &#123;\n      return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        rejectFn(reason)\n      &#125;)\n    &#125;\n    // ...\n  &#125;\n\n  // 测试\n  MyPromise.reject(&#39;static reject&#39;).catch(e =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // static reject</code></pre>\n<h3 id=\"什么是-allSettled？\"><a href=\"#什么是-allSettled？\" class=\"headerlink\" title=\"什么是 allSettled？\"></a>什么是 allSettled？</h3><p>ECMA 官网最新更新了<strong>Promise</strong>的新的静态方法<strong>Promise.allSettled</strong>，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理<strong>Promise</strong>的函数，但是我们已经有了<strong>Promise.all</strong>，为什么还需要<strong>allSettled</strong>。要解开这个问题，我们得回顾一下<strong>Promise.all</strong>。现有的<strong>Promise.all</strong>我们说过，如果<strong>Promise</strong>队列里有一个<strong>reject</strong>，那么他就只会返回<strong>reject</strong>，所以<strong>Promise.all</strong>不一定会返回所有结果，很显然<strong>Promise.allSettled</strong>能够解决这个问题。</p>\n<h4 id=\"Promise-A-测试场景\"><a href=\"#Promise-A-测试场景\" class=\"headerlink\" title=\"Promise A+测试场景\"></a>Promise A+测试场景</h4><pre><code>   // Promise A+\n  // 创建三个promise\n  const promise1 = Promise.resolve(1)\n  const promise2 = Promise.resolve(2)\n  const promise3 = Promise.resolve(3)\n\n  Promise.allSettled([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 2&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */\n\n  // 添加一个reject\n  const promise4 = Promise.resolve(1)\n  const promise5 = Promise.reject(&#39;reject&#39;)\n  const promise6 = Promise.resolve(3)\n\n  Promise.allSettled([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n   /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;rejected&#39;, value: &#39;reject&#39;&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */</code></pre>\n<p>可以看出来<strong>allSettled</strong>和 all 最大的区别就是，<strong>allSettled</strong>不管是<strong>resolve</strong>，还是<strong>reject</strong>都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，<strong>status</strong>描述状态，<strong>value</strong>接收返回值。</p>\n<h4 id=\"实现-MyPromise-allSettled\"><a href=\"#实现-MyPromise-allSettled\" class=\"headerlink\" title=\"实现 MyPromise.allSettled\"></a>实现 MyPromise.allSettled</h4><p><strong>allSettled</strong>的整体逻辑跟<strong>all</strong>是一样的，只不过返回值的处理稍微有所不同</p>\n<pre><code>  class MyPromise &#123;\n// ...\n  static allSettled(promises) &#123;\n      // 已然是返回一个promise\n      return new MyPromise((resolve, reject) =&gt; &#123;\n        // 创建一个收集返回值的数组\n        const result = []\n\n        // 执行\n        deepPromise(promises[0], 0 , result)\n\n        // 返回结果\n        resolve(result)\n\n        // 这里我们用递归来实现\n        // @param &#123;MyPromise&#125; promise 每一个promise方法\n        // @param &#123;number&#125; index 索引\n        // @param &#123;string[]&#125; result 收集返回结果的数组\n        function deepPromise(promise, index, result) &#123;\n          // 边界判断\n          // 所有执行完之后返回收集数组\n          if(index &gt; promises.length - 1) &#123;\n            return result\n          &#125;\n\n          if(typeof promise.then === &#39;function&#39;) &#123;\n            // 如果是promise\n            promise.then(res =&gt; &#123;\n              index++\n              result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;).catch(e =&gt; &#123;\n              // reject直接返回\n              index ++\n              result.push(&#123;status: &#39;rejected&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;)\n          &#125;else &#123;\n            // 如果是普通值\n            // 这里我们只做简单判断，非promise则直接当返回值处理\n            index++\n            result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n            deepPromise(promises[index], index, res)\n          &#125;\n        &#125;\n      &#125;)\n\n    &#125;\n  // ...\n  &#125;\n\n  // 测试\n  // 创建三个promise\n  const promise1 = MyPromise.resolve(1)\n  const promise2 = MyPromise.resolve(2)\n  const promise3 = MyPromise.resolve(3)\n\n  MyPromise.allSettled([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 2&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */\n\n  // 添加一个reject\n  const promise4 = MyPromise.resolve(1)\n  const promise5 = MyPromise.reject(&#39;reject&#39;)\n  const promise6 = MyPromise.resolve(3)\n\n  Promise.allSettled([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n   /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;rejected&#39;, value: &#39;reject&#39;&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>class MyPromise &#123;\n  constructor(executor) &#123;\n    // 初始化状态status\n    // 返回值value\n    // 错误原因reason\n    this.statue = PENDDING;\n    this.value = undefined;\n    this.reason = undefined;\n\n    // 返回值回调队列和错误回调队列\n    this.resolves = [];\n    this.rejects = [];\n\n    // 声明resolve函数\n    const resolve = (value) =&gt; &#123;\n      if (this.status === PENDDING) &#123;\n        this.status = RESOLVED; // 变更状态为完成状态\n        this.value = value; // 赋值\n\n        // 执行resolves队列\n        while (this.resolves.length) &#123;\n          const callback = this.resolves.shift();\n          callback(value);\n        &#125;\n      &#125;\n    &#125;;\n\n    // 声明reject函数\n    const reject = (reason) =&gt; &#123;\n      if (this.statue === PENDDING) &#123;\n        this.status = REJECTED; // 变更状态为拒绝状态\n        this.reason = reason; // 赋值\n\n        // 执行rejects队列\n        while (this.rejects.length) &#123;\n          const callback = this.rejects.shift();\n          callback(reason);\n        &#125;\n      &#125;\n    &#125;;\n\n    try&#123;\n        executor(resolve,reject)\n    &#125;catch(e)&#123;\n        reject(e)\n    &#125;\n  &#125;\n\n  // then\n  then(resolve, reject) &#123;\n    // 判断resolve和reject未传入的情况，解决空值透传问题\n    // then()情况\n    typeof resolve !== &#39;function&#39; ? resolve = value =&gt; value : resolve\n    typeof reject !== &#39;function&#39; ? reject = reason =&gt; throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n    //根据规范，then会返回一个全新的promise\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        // 重写传入的resolve方法\n        // 判断返回值\n        const fulfilished = value =&gt; &#123;\n            try&#123;\n                // 接收返回值\n                const res = resolve(value)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n            &#125;catch(e) &#123;\n                rejectFn(e)\n            &#125;\n        &#125;\n\n        // 重写传入的reject方法\n        // 判断返回值\n        const rejected = reason =&gt; &#123;\n            try&#123;\n        // 接收返回值\n                const res = reject(reason)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n            &#125;catch(e)&#123;\n                rejectFn(e instanceof Error ? e.message: e)\n            &#125;\n\n        &#125;\n\n        // 判断同步异步任务\n        // 执行相对应的方法\n        // 这里用switch方法改进\n        switch(this.status) &#123;\n            case RESOLVED:\n                fulfilished(this.value)\n            break;\n\n            case REJECTED:\n                rejected(this.reason)\n            break;\n\n            case PENDDING:\n                this.resolves.push(fulfilished)\n                this.rejects.push(rejected)\n              break;\n        &#125;\n    &#125;)\n\n  &#125;\n\n  catch(errorFn) &#123;\n    // 这里只需注册执行下then，传入callback就能实现\n    this.then(null, errorFn);\n  &#125;\n\n  // resolve\n  static resolve(value) &#123;\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n      resolveFn(value)\n    &#125;)\n  &#125;\n\n    // reject\n  static reject(reason) &#123;\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n      rejectFn(reason)\n    &#125;)\n  &#125;\n\n  // all\n  static all(promises) &#123;\n    // 已然是返回一个promise\n    return new MyPromise((resolve, reject) =&gt; &#123;\n      // 创建一个收集返回值的数组\n      const result = []\n\n      // 执行\n      deepPromise(promises[0], 0 , result)\n\n      // 返回结果\n      resolve(result)\n\n      // 这里我们用递归来实现\n      // @param &#123;MyPromise&#125; promise 每一个promise方法\n      // @param &#123;number&#125; index 索引\n      // @param &#123;string[]&#125; result 收集返回结果的数组\n      function deepPromise(promise, index, result) &#123;\n        // 边界判断\n        // 所有执行完之后返回收集数组\n        if(index &gt; promises.length - 1) &#123;\n          return result\n        &#125;\n\n        if(typeof promise.then === &#39;function&#39;) &#123;\n          // 如果是promise\n          promise.then(res =&gt; &#123;\n            index++\n            result.push(res)\n            deepPromise(promises[index], index, result)\n          &#125;).catch(e =&gt; &#123;\n            // reject直接返回\n            reject(e instanceof Error ? e.message : e)\n          &#125;)\n        &#125;else &#123;\n          // 如果是普通值\n          // 这里我们只做简单判断，非promise则直接当返回值处理\n          index++\n          result.push(promise)\n          deepPromise(promises[index], index, res)\n        &#125;\n      &#125;\n    &#125;)\n\n  &#125;\n\n  // allSettled\n  static allSettled(promises) &#123;\n      // 已然是返回一个promise\n      return new MyPromise((resolve, reject) =&gt; &#123;\n        // 创建一个收集返回值的数组\n        const result = []\n\n        // 执行\n        deepPromise(promises[0], 0 , result)\n\n        // 返回结果\n        resolve(result)\n\n        // 这里我们用递归来实现\n        // @param &#123;MyPromise&#125; promise 每一个promise方法\n        // @param &#123;number&#125; index 索引\n        // @param &#123;string[]&#125; result 收集返回结果的数组\n        function deepPromise(promise, index, result) &#123;\n          // 边界判断\n          // 所有执行完之后返回收集数组\n          if(index &gt; promises.length - 1) &#123;\n            return result\n          &#125;\n\n          if(typeof promise.then === &#39;function&#39;) &#123;\n            // 如果是promise\n            promise.then(res =&gt; &#123;\n              index++\n              result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;).catch(e =&gt; &#123;\n              // reject直接返回\n              index ++\n              result.push(&#123;status: &#39;rejected&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;)\n          &#125;else &#123;\n            // 如果是普通值\n            // 这里我们只做简单判断，非promise则直接当返回值处理\n            index++\n            result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n            deepPromise(promises[index], index, res)\n          &#125;\n        &#125;\n      &#125;)\n\n    &#125;\n&#125;</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此<strong>Promise A+**的完整的方法和实现就完成了，个人觉得实现</strong>promise<strong>的难点在于理解</strong>then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然</p>\n<h2 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h2><p>转载自<a href=\"https://juejin.cn/post/6866372840451473415#heading-0\">掘金</a> 作者<a href=\"https://juejin.cn/user/448256474885159\">MichaelHong</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"彻底理解-Promise-原理及全功能实现\"><a href=\"#彻底理解-Promise-原理及全功能实现\" class=\"headerlink\" title=\"彻底理解 Promise 原理及全功能实现\"></a>彻底理解 Promise 原理及全功能实现</h1><h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p><strong>Promise</strong>作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如<strong>Vue</strong>的批量处理等。今天我们就按照<strong>Promise A+</strong> 规范来完整实现<strong>Promise</strong>全功能，话不多说，上代码。</p>\n<h2 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h2><h3 id=\"status-状态定义\"><a href=\"#status-状态定义\" class=\"headerlink\" title=\"status 状态定义\"></a>status 状态定义</h3><p><strong>Promise</strong>的设定是一个不可逆的状态机，包含：</p>\n<pre><code>const PENDDING = &quot;PENDDING&quot;; // 初始化pendding状态\nconst RESOLVED = &quot;RESOLVED&quot;; // 正确完成resolve状态\nconst REJECTED = &quot;REJECTED&quot;; // 错误完成reject状态</code></pre>\n<h3 id=\"MyPromise\"><a href=\"#MyPromise\" class=\"headerlink\" title=\"MyPromise\"></a>MyPromise</h3><p>创建<strong>MyPromise</strong>类函数和初始化相对应的值和状态</p>\n<pre><code>class MyPromise &#123;\n  constructor(executor) &#123;\n    // 初始化状态status\n    // 返回值value\n    // 错误原因reason\n    this.status = PENDDING;\n    this.value = undefined;\n    this.reason = undefined;\n\n    // 返回值回调队列和错误回调队列\n    this.resolves = [];\n    this.rejects = [];\n\n    // 声明resolve函数\n    const resolve = (value) =&gt; &#123;\n      if (this.status === PENDDING) &#123;\n        this.status = RESOLVED; // 变更状态为完成状态\n        this.value = value; // 赋值\n\n        // 执行resolves队列\n        while (this.resolves.length) &#123;\n          const callback = this.resolves.shift();\n          callback(value);\n        &#125;\n      &#125;\n    &#125;;\n\n    // 声明reject函数\n    const reject = (reason) =&gt; &#123;\n      if (this.statue === PENDDING) &#123;\n        this.status = REJECTED; // 变更状态为拒绝状态\n        this.reason = reason; // 赋值\n\n        // 执行rejects队列\n        while (this.rejects.length) &#123;\n          const callback = this.rejects.shift();\n          callback(reason);\n        &#125;\n      &#125;\n    &#125;;\n\n    try&#123;\n        executor(resolve,reject)\n    &#125;catch(e)&#123;\n        reject(e)\n    &#125;\n  &#125;\n&#125;</code></pre>\n<h3 id=\"MyPromise-then\"><a href=\"#MyPromise-then\" class=\"headerlink\" title=\"MyPromise.then\"></a>MyPromise.then</h3><h4 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h4><pre><code>class MyPromise &#123;\n  // ...\n  then(resolve, reject) &#123;\n    // 完成状态，推入完成队列\n    if (this.status === RESOLVED) &#123;\n      resolve(this.value);\n    &#125;\n\n    // 拒绝状态，推入拒绝队列\n    if (this.status === REJECTED) &#123;\n      reject(this.reason);\n    &#125;\n\n    // 异步情况\n    if (this.status === PENDDING) &#123;\n      this.resolves.push(resolve);\n      this.rejects.push(reject);\n    &#125;\n  &#125;\n  // ...\n&#125;\n\n// 测试同步任务\n\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n    resolve(&#39;promise sync&#39;)\n&#125;)\n\npromise.then(res =&gt; &#123;\n    console.log(res)\n&#125;)\n\n// 打印结果\n// promise sync\n\n// 测试异步任务\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n        resolve(&#39;promise async)\n    &#125;, 500)\n&#125;)\n\npromise.then(res =&gt; &#123;\n    console.log(res)\n&#125;)\n\n// 打印结果\n// promise async</code></pre>\n<h4 id=\"Promise-A-规范场景\"><a href=\"#Promise-A-规范场景\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><blockquote>\n<p>根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。</p>\n</blockquote>\n<pre><code>// Promise A+\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  resolve(&quot;first&quot;);\n&#125;);\n\n// 第一种场景：返回常规值\npromise\n  .then((res) =&gt; &#123;\n    console.log(res);\n\n    return &quot;second&quot;;\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\n\n// 打印结果\n// first\n// second\n\n// 第二种场景：返回promise\npromise\n  .then((res) =&gt; &#123;\n    console.log(res);\n    return new Promise((resolve) =&gt; &#123;\n      resolve(&quot;promise&quot;);\n    &#125;);\n  &#125;)\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\n\n// 打印结果\n// first\n// promise\n\n// 第三种场景：值穿透\npromise\n  .then((res) =&gt; &#123;\n    console.log(res);\n    return res;\n  &#125;)\n  .then()\n  .then((res) =&gt; &#123;\n    console.log(res);\n  &#125;);\n\n// 打印结果\n// first\n// first</code></pre>\n<h4 id=\"实现-then\"><a href=\"#实现-then\" class=\"headerlink\" title=\"实现 then\"></a>实现 then</h4><p>根据以上规范定义，我们来改造一下<strong>then</strong>方法：</p>\n<pre><code>class MyPromise &#123;\n  // ...\n  then(resolve, reject) &#123;\n    // 判断resolve和reject未传入的情况，解决空值透传问题\n    // then()情况\n    typeof resolve !== &#39;function&#39; ? resolve = value =&gt; value : resolve\n    typeof reject !== &#39;function&#39; ? reject = reason =&gt; throw new Error(reason instanceof Error ? reason.message : reason )\n\n    //根据规范，then会返回一个全新的promise\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        // 重写传入的resolve方法\n        // 判断返回值\n        const fulfilished = value =&gt; &#123;\n            try&#123;\n                // 接收返回值\n                const res = resolve(value)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n            &#125;catch(e) &#123;\n                rejectFn(e)\n            &#125;\n        &#125;\n\n        // 重写传入的reject方法\n        // 判断返回值\n        const rejected = reason =&gt; &#123;\n            try&#123;\n        // 接收返回值\n                const res = reject(reason)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n            &#125;catch(e)&#123;\n                rejectFn(e instanceof Error ? e.message: e)\n            &#125;\n\n        &#125;\n\n        // 判断同步异步任务\n        // 执行相对应的方法\n        // 这里用switch方法改进\n        switch(this.status) &#123;\n            case RESOLVED:\n                fulfilished(this.value)\n            break;\n\n            case REJECTED:\n                rejected(this.reason)\n            break;\n\n            case PENDDING:\n                this.resolves.push(fulfilished)\n                this.rejects.push(rejected)\n              break;\n        &#125;\n    &#125;)\n\n  &#125;\n  // ...\n&#125;\n\n// 测试\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n    resolve(&#39;first&#39;)\n&#125;)\n\npromise.then(res =&gt; &#123;\n    console.log(res)\n    return new MyPromise((resolve, reject) =&gt; &#123;\n        resolve(&#39;promise second&#39;)\n    &#125;)\n&#125;).then().then(res =&gt; &#123;\n    console.log(res)\n    return &#39;third&#39;\n&#125;).then(res =&gt; &#123;\n    console.log(res)\n&#125;)\n\n// 打印结果\n// first\n// promise second\n// third</code></pre>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>测试成功，<strong>promise</strong>的改造就算符合规范了。这个难点在于<strong>then</strong>内函数的返回值如果是<strong>promise</strong>，那么我们会先让他执行注册一次<strong>then</strong>，让<strong>promise</strong>接着往下执行。</p>\n<h3 id=\"MyPromise-catch\"><a href=\"#MyPromise-catch\" class=\"headerlink\" title=\"MyPromise.catch\"></a>MyPromise.catch</h3><p><strong>catch</strong>方法相对比较简单，将拒绝的值放到<strong>reject</strong>方法里执行就可以。</p>\n<h4 id=\"Promise-A-规范场景-1\"><a href=\"#Promise-A-规范场景-1\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre><code>// Promise A+\nconst promise = new Promise((resolve, reject) =&gt; &#123;\n  reject(&quot;promise reject&quot;);\n&#125;);\n\npromise.catch((e) =&gt; &#123;\n  console.log(e);\n&#125;);\n\n// 打印结果\n// promise reject</code></pre>\n<h4 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch\"></a>实现 catch</h4><pre><code>class MyPromise &#123;\n  // ...\n  catch(errorFn) &#123;\n    // 这里只需注册执行下then，传入callback就能实现\n    this.then(null, errorFn);\n  &#125;\n  // ...\n&#125;\n\n// 测试\nconst promise = new MyPromise((resolve, reject) =&gt; &#123;\n  reject(&quot;my promise reject&quot;);\n&#125;);\n\npromise.catch((e) =&gt; &#123;\n  console.log(e);\n&#125;);\n\n// 打印结果\n// my promise reject</code></pre>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>catch</strong>方法在于执行回调去获取<strong>reject</strong>的结果，所以只需执行一下<strong>then</strong>并传入<strong>callback</strong>就实现了，相对好理解。</p>\n<h3 id=\"MyPromise-all\"><a href=\"#MyPromise-all\" class=\"headerlink\" title=\"MyPromise.all\"></a>MyPromise.all</h3><p>业务场景中，我们经常会遇到不止一个<strong>promie</strong>的场景，因此需要合并一次执行多个<strong>promise</strong>，统一返回结果，<strong>Promise.all</strong>就是为了解决此问题。</p>\n<h4 id=\"Promise-A-规范场景-2\"><a href=\"#Promise-A-规范场景-2\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre><code>  // Promise A+\n  // 创建三个promise\n  const promise1 = Promise.resolve(1)\n  const promise2 = Promise.resolve(2)\n  const promise3 = Promise.resolve(3)\n\n  Promise.all([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // [1,2,3]\n\n  // 添加一个reject\n  const promise4 = Promise.resolve(1)\n  const promise5 = Promise.reject(&#39;reject&#39;)\n  const promise6 = Promise.resolve(3)\n\n  Promise.all([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n  // reject</code></pre>\n<blockquote>\n<p>根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。</p>\n</blockquote>\n<h4 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h4><p>我们来实现一下：</p>\n<pre><code>  class MyPromise &#123;\n    // ...\n    // all是静态方法\n    static all(promises) &#123;\n      // 已然是返回一个promise\n      return new MyPromise((resolve, reject) =&gt; &#123;\n        // 创建一个收集返回值的数组\n        const result = []\n\n        // 执行\n        deepPromise(promises[0], 0 , result)\n\n        // 返回结果\n        resolve(result)\n\n        // 这里我们用递归来实现\n        // @param &#123;MyPromise&#125; promise 每一个promise方法\n        // @param &#123;number&#125; index 索引\n        // @param &#123;string[]&#125; result 收集返回结果的数组\n        function deepPromise(promise, index, result) &#123;\n          // 边界判断\n          // 所有执行完之后返回收集数组\n          if(index &gt; promises.length - 1) &#123;\n            return result\n          &#125;\n\n          if(typeof promise.then === &#39;function&#39;) &#123;\n            // 如果是promise\n            promise.then(res =&gt; &#123;\n              index++\n              result.push(res)\n              deepPromise(promises[index], index, result)\n            &#125;).catch(e =&gt; &#123;\n              // reject直接返回\n              reject(e instanceof Error ? e.message : e)\n            &#125;)\n          &#125;else &#123;\n            // 如果是普通值\n            // 这里我们只做简单判断，非promise则直接当返回值处理\n            index++\n            result.push(promise)\n            deepPromise(promises[index], index, res)\n          &#125;\n        &#125;\n      &#125;)\n\n    &#125;\n    // ...\n  &#125;\n\n  // 测试\n  // 创建三个MyPromise\n  const promise1 = MyPromise.resolve(1)\n  const promise2 = MyPromise.resolve(2)\n  const promise3 = MyPromise.resolve(3)\n\n  MyPromise.all([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // [1,2,3]\n\n  // 添加一个reject\n  const promise4 = MyPromise.resolve(1)\n  const promise5 = MyPromise.reject(&#39;reject&#39;)\n  const promise6 = MyPromise.resolve(3)\n\n  MyPromise.all([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n  // reject</code></pre>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>Promise.all</strong>作为一个批量处理的函数，让我们在使用时可以同时多个处理<strong>promise</strong>，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个<strong>promise</strong>后再去执行下一个<strong>promise</strong>，处理完这个逻辑也就基本完成了<strong>Promise.all</strong>的全功能了。</p>\n<h3 id=\"MyPromise-resolve\"><a href=\"#MyPromise-resolve\" class=\"headerlink\" title=\"MyPromise.resolve\"></a>MyPromise.resolve</h3><p>静态方法<strong>resolve</strong>的实现就相对简单了，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<h4 id=\"实现-MyPromise-resolve\"><a href=\"#实现-MyPromise-resolve\" class=\"headerlink\" title=\"实现 MyPromise.resolve\"></a>实现 MyPromise.resolve</h4><pre><code>  class MyPromise &#123;\n    // ...\n    static resolve(value) &#123;\n      return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        resolveFn(value)\n      &#125;)\n    &#125;\n    // ...\n  &#125;\n\n  // 测试\n  MyPromise.resolve(&#39;static resolve&#39;).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // static resolve</code></pre>\n<h3 id=\"MyPromise-reject\"><a href=\"#MyPromise-reject\" class=\"headerlink\" title=\"MyPromise.reject\"></a>MyPromise.reject</h3><p>静态方法<strong>reject</strong>的实现跟<strong>resolve</strong>是类似，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<pre><code>  class MyPromise &#123;\n    // ...\n    static reject(reason) &#123;\n      return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        rejectFn(reason)\n      &#125;)\n    &#125;\n    // ...\n  &#125;\n\n  // 测试\n  MyPromise.reject(&#39;static reject&#39;).catch(e =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  // static reject</code></pre>\n<h3 id=\"什么是-allSettled？\"><a href=\"#什么是-allSettled？\" class=\"headerlink\" title=\"什么是 allSettled？\"></a>什么是 allSettled？</h3><p>ECMA 官网最新更新了<strong>Promise</strong>的新的静态方法<strong>Promise.allSettled</strong>，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理<strong>Promise</strong>的函数，但是我们已经有了<strong>Promise.all</strong>，为什么还需要<strong>allSettled</strong>。要解开这个问题，我们得回顾一下<strong>Promise.all</strong>。现有的<strong>Promise.all</strong>我们说过，如果<strong>Promise</strong>队列里有一个<strong>reject</strong>，那么他就只会返回<strong>reject</strong>，所以<strong>Promise.all</strong>不一定会返回所有结果，很显然<strong>Promise.allSettled</strong>能够解决这个问题。</p>\n<h4 id=\"Promise-A-测试场景\"><a href=\"#Promise-A-测试场景\" class=\"headerlink\" title=\"Promise A+测试场景\"></a>Promise A+测试场景</h4><pre><code>   // Promise A+\n  // 创建三个promise\n  const promise1 = Promise.resolve(1)\n  const promise2 = Promise.resolve(2)\n  const promise3 = Promise.resolve(3)\n\n  Promise.allSettled([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 2&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */\n\n  // 添加一个reject\n  const promise4 = Promise.resolve(1)\n  const promise5 = Promise.reject(&#39;reject&#39;)\n  const promise6 = Promise.resolve(3)\n\n  Promise.allSettled([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n   /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;rejected&#39;, value: &#39;reject&#39;&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */</code></pre>\n<p>可以看出来<strong>allSettled</strong>和 all 最大的区别就是，<strong>allSettled</strong>不管是<strong>resolve</strong>，还是<strong>reject</strong>都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，<strong>status</strong>描述状态，<strong>value</strong>接收返回值。</p>\n<h4 id=\"实现-MyPromise-allSettled\"><a href=\"#实现-MyPromise-allSettled\" class=\"headerlink\" title=\"实现 MyPromise.allSettled\"></a>实现 MyPromise.allSettled</h4><p><strong>allSettled</strong>的整体逻辑跟<strong>all</strong>是一样的，只不过返回值的处理稍微有所不同</p>\n<pre><code>  class MyPromise &#123;\n// ...\n  static allSettled(promises) &#123;\n      // 已然是返回一个promise\n      return new MyPromise((resolve, reject) =&gt; &#123;\n        // 创建一个收集返回值的数组\n        const result = []\n\n        // 执行\n        deepPromise(promises[0], 0 , result)\n\n        // 返回结果\n        resolve(result)\n\n        // 这里我们用递归来实现\n        // @param &#123;MyPromise&#125; promise 每一个promise方法\n        // @param &#123;number&#125; index 索引\n        // @param &#123;string[]&#125; result 收集返回结果的数组\n        function deepPromise(promise, index, result) &#123;\n          // 边界判断\n          // 所有执行完之后返回收集数组\n          if(index &gt; promises.length - 1) &#123;\n            return result\n          &#125;\n\n          if(typeof promise.then === &#39;function&#39;) &#123;\n            // 如果是promise\n            promise.then(res =&gt; &#123;\n              index++\n              result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;).catch(e =&gt; &#123;\n              // reject直接返回\n              index ++\n              result.push(&#123;status: &#39;rejected&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;)\n          &#125;else &#123;\n            // 如果是普通值\n            // 这里我们只做简单判断，非promise则直接当返回值处理\n            index++\n            result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n            deepPromise(promises[index], index, res)\n          &#125;\n        &#125;\n      &#125;)\n\n    &#125;\n  // ...\n  &#125;\n\n  // 测试\n  // 创建三个promise\n  const promise1 = MyPromise.resolve(1)\n  const promise2 = MyPromise.resolve(2)\n  const promise3 = MyPromise.resolve(3)\n\n  MyPromise.allSettled([promise1,promise12,promise3]).then(res =&gt; &#123;\n    console.log(res)\n  &#125;)\n\n  // 打印结果\n  /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 2&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */\n\n  // 添加一个reject\n  const promise4 = MyPromise.resolve(1)\n  const promise5 = MyPromise.reject(&#39;reject&#39;)\n  const promise6 = MyPromise.resolve(3)\n\n  Promise.allSettled([promise4, promise5,promise6]).then(res =&gt; &#123;\n    console.log(res, &#39;resolve&#39;)\n  &#125;).catch(e =&gt; &#123;\n    console.log(e)\n  &#125;)\n\n  // 打印结果\n   /*\n  [\n    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,\n    &#123;status: &#39;rejected&#39;, value: &#39;reject&#39;&#125;,\n    &#123;status: &#39;fulfilished&#39;, value: 3&#125;\n  ]\n  */</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code>class MyPromise &#123;\n  constructor(executor) &#123;\n    // 初始化状态status\n    // 返回值value\n    // 错误原因reason\n    this.statue = PENDDING;\n    this.value = undefined;\n    this.reason = undefined;\n\n    // 返回值回调队列和错误回调队列\n    this.resolves = [];\n    this.rejects = [];\n\n    // 声明resolve函数\n    const resolve = (value) =&gt; &#123;\n      if (this.status === PENDDING) &#123;\n        this.status = RESOLVED; // 变更状态为完成状态\n        this.value = value; // 赋值\n\n        // 执行resolves队列\n        while (this.resolves.length) &#123;\n          const callback = this.resolves.shift();\n          callback(value);\n        &#125;\n      &#125;\n    &#125;;\n\n    // 声明reject函数\n    const reject = (reason) =&gt; &#123;\n      if (this.statue === PENDDING) &#123;\n        this.status = REJECTED; // 变更状态为拒绝状态\n        this.reason = reason; // 赋值\n\n        // 执行rejects队列\n        while (this.rejects.length) &#123;\n          const callback = this.rejects.shift();\n          callback(reason);\n        &#125;\n      &#125;\n    &#125;;\n\n    try&#123;\n        executor(resolve,reject)\n    &#125;catch(e)&#123;\n        reject(e)\n    &#125;\n  &#125;\n\n  // then\n  then(resolve, reject) &#123;\n    // 判断resolve和reject未传入的情况，解决空值透传问题\n    // then()情况\n    typeof resolve !== &#39;function&#39; ? resolve = value =&gt; value : resolve\n    typeof reject !== &#39;function&#39; ? reject = reason =&gt; throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n    //根据规范，then会返回一个全新的promise\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n        // 重写传入的resolve方法\n        // 判断返回值\n        const fulfilished = value =&gt; &#123;\n            try&#123;\n                // 接收返回值\n                const res = resolve(value)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n            &#125;catch(e) &#123;\n                rejectFn(e)\n            &#125;\n        &#125;\n\n        // 重写传入的reject方法\n        // 判断返回值\n        const rejected = reason =&gt; &#123;\n            try&#123;\n        // 接收返回值\n                const res = reject(reason)\n\n                // 判断返回值类型：promise或普通类型\n                // 如果是promise，则往下执行一次then\n                // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n            &#125;catch(e)&#123;\n                rejectFn(e instanceof Error ? e.message: e)\n            &#125;\n\n        &#125;\n\n        // 判断同步异步任务\n        // 执行相对应的方法\n        // 这里用switch方法改进\n        switch(this.status) &#123;\n            case RESOLVED:\n                fulfilished(this.value)\n            break;\n\n            case REJECTED:\n                rejected(this.reason)\n            break;\n\n            case PENDDING:\n                this.resolves.push(fulfilished)\n                this.rejects.push(rejected)\n              break;\n        &#125;\n    &#125;)\n\n  &#125;\n\n  catch(errorFn) &#123;\n    // 这里只需注册执行下then，传入callback就能实现\n    this.then(null, errorFn);\n  &#125;\n\n  // resolve\n  static resolve(value) &#123;\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n      resolveFn(value)\n    &#125;)\n  &#125;\n\n    // reject\n  static reject(reason) &#123;\n    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;\n      rejectFn(reason)\n    &#125;)\n  &#125;\n\n  // all\n  static all(promises) &#123;\n    // 已然是返回一个promise\n    return new MyPromise((resolve, reject) =&gt; &#123;\n      // 创建一个收集返回值的数组\n      const result = []\n\n      // 执行\n      deepPromise(promises[0], 0 , result)\n\n      // 返回结果\n      resolve(result)\n\n      // 这里我们用递归来实现\n      // @param &#123;MyPromise&#125; promise 每一个promise方法\n      // @param &#123;number&#125; index 索引\n      // @param &#123;string[]&#125; result 收集返回结果的数组\n      function deepPromise(promise, index, result) &#123;\n        // 边界判断\n        // 所有执行完之后返回收集数组\n        if(index &gt; promises.length - 1) &#123;\n          return result\n        &#125;\n\n        if(typeof promise.then === &#39;function&#39;) &#123;\n          // 如果是promise\n          promise.then(res =&gt; &#123;\n            index++\n            result.push(res)\n            deepPromise(promises[index], index, result)\n          &#125;).catch(e =&gt; &#123;\n            // reject直接返回\n            reject(e instanceof Error ? e.message : e)\n          &#125;)\n        &#125;else &#123;\n          // 如果是普通值\n          // 这里我们只做简单判断，非promise则直接当返回值处理\n          index++\n          result.push(promise)\n          deepPromise(promises[index], index, res)\n        &#125;\n      &#125;\n    &#125;)\n\n  &#125;\n\n  // allSettled\n  static allSettled(promises) &#123;\n      // 已然是返回一个promise\n      return new MyPromise((resolve, reject) =&gt; &#123;\n        // 创建一个收集返回值的数组\n        const result = []\n\n        // 执行\n        deepPromise(promises[0], 0 , result)\n\n        // 返回结果\n        resolve(result)\n\n        // 这里我们用递归来实现\n        // @param &#123;MyPromise&#125; promise 每一个promise方法\n        // @param &#123;number&#125; index 索引\n        // @param &#123;string[]&#125; result 收集返回结果的数组\n        function deepPromise(promise, index, result) &#123;\n          // 边界判断\n          // 所有执行完之后返回收集数组\n          if(index &gt; promises.length - 1) &#123;\n            return result\n          &#125;\n\n          if(typeof promise.then === &#39;function&#39;) &#123;\n            // 如果是promise\n            promise.then(res =&gt; &#123;\n              index++\n              result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;).catch(e =&gt; &#123;\n              // reject直接返回\n              index ++\n              result.push(&#123;status: &#39;rejected&#39;, value: res&#125;) // 这里推入的是对象\n              deepPromise(promises[index], index, result)\n            &#125;)\n          &#125;else &#123;\n            // 如果是普通值\n            // 这里我们只做简单判断，非promise则直接当返回值处理\n            index++\n            result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象\n            deepPromise(promises[index], index, res)\n          &#125;\n        &#125;\n      &#125;)\n\n    &#125;\n&#125;</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此<strong>Promise A+**的完整的方法和实现就完成了，个人觉得实现</strong>promise<strong>的难点在于理解</strong>then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然</p>\n<h2 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h2><p>转载自<a href=\"https://juejin.cn/post/6866372840451473415#heading-0\">掘金</a> 作者<a href=\"https://juejin.cn/user/448256474885159\">MichaelHong</a></p>\n"},{"title":"Promise V8 源码分析(二)","date":"2020-12-14T06:14:22.000Z","author":"heyXiao","summary":"基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。","_content":"\n基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。\n\n## reject\n\n    new Promise((resolve, reject) => {\n      setTimeout(_ => reject('rejected'), 5000)\n    }).then(_ => {\n      console.log('fulfilled')\n    }, reason => {\n      console.log(reason)\n    })\n\n上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 [RejectPromise](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210) 函数，源码如下：\n\n    transitioning builtin\n    RejectPromise(implicit context: Context)(\n        promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny {\n      // 取出 Promise 的处理对象 PromiseReaction\n      const reactions =\n          UnsafeCast<(Zero | PromiseReaction)>(promise.reactions_or_result);\n      // 这里的 reason 就是 reject 函数的参数\n      promise.reactions_or_result = reason;\n      // 设置 Promise 的状态为 rejected\n      promise.SetStatus(PromiseState::kRejected);\n      TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n      return Undefined;\n    }\n\n[TriggerPromiseReactions](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140) 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：\n\n    // https://tc39.es/ecma262/#sec-triggerpromisereactions\n    transitioning macro TriggerPromiseReactions(implicit context: Context)(\n        reactions: Zero|PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      // 删减了链表反转的代码\n      let current = reactions;\n      // reactions 是一个链表，下面的 while 循环遍历链表\n      while (true) {\n        typeswitch (current) {\n          case (Zero): {\n            break;\n          }\n          case (currentReaction: PromiseReaction): {\n            // 取出链表下一个结点\n            current = currentReaction.next;\n            // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n            MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n          }\n        }\n      }\n    }\n\n[MorphAndEnqueuePromiseReaction](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84) 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。\n\nMorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。\n\n    transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n        promiseReaction: PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      let primaryHandler: Callable|Undefined;\n      let secondaryHandler: Callable|Undefined;\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        primaryHandler = promiseReaction.fulfill_handler;\n        secondaryHandler = promiseReaction.reject_handler;\n      } else {\n        primaryHandler = promiseReaction.reject_handler;\n        secondaryHandler = promiseReaction.fulfill_handler;\n      }\n      const handlerContext: Context =\n          ExtractHandlerContext(primaryHandler, secondaryHandler);\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        // 删\n      } else {\n        * UnsafeConstCast(& promiseReaction.map) =\n            PromiseRejectReactionJobTaskMapConstant();\n        const promiseReactionJobTask =\n            UnsafeCast<PromiseRejectReactionJobTask>(promiseReaction);\n        // argument 是 reject 的参数\n        promiseReactionJobTask.argument = argument;\n        promiseReactionJobTask.context = handlerContext;\n        // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n        promiseReactionJobTask.handler = primaryHandler;\n        // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n        // EnqueueMicrotask 将 microtask 插入 microtask 队列\n        EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n      }\n    }\n\nreject 和 resolve 的逻辑基本相同，分为 3 步：\n\n- 设置 Promise 的 value/reason，也就是 resolve/reject 的参数\n- 设置 Promise 的状态：fulfilled/rejected\n- 从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列\n\n## catch\n\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        console.log('rejected')\n    })\n\n以上面代码为例，当 catch 方法执行时，调用了 V8 的 [PromisePrototypeCatch](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100) 方法，源码如下：\n\n    transitioning javascript builtin\n    PromisePrototypeCatch(\n        js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny {\n      const nativeContext = LoadNativeContext(context);\n      return UnsafeCast<JSAny>(\n          InvokeThen(nativeContext, receiver, Undefined, onRejected));\n    }\n\nPromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，[InvokeThen](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199) 源码如下：\n\n    transitioning\n    macro InvokeThen<F: type>(implicit context: Context)(\n        nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n        callFunctor: F): JSAny {\n      if (!Is<Smi>(receiver) &&\n          IsPromiseThenLookupChainIntact(\n              nativeContext, UnsafeCast<HeapObject>(receiver).map)) {\n        const then =\n            UnsafeCast<JSAny>(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n        // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n        return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n      } else\n        deferred {\n          const then = UnsafeCast<JSAny>(GetProperty(receiver, kThenString));\n          // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n          return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n        }\n    }\n\nInvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。\n\n既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。\n\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        throw 'rejected'\n    }).catch(_ => {\n        console.log('last catch')\n    })\n\n上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。\n\n> catch 方法通过底层调用 then 方法来实现  \n> 假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)\n\n## then 的链式调用与 microtask 队列\n\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n\n以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。\n\n    const p0 = Promise.resolve('123')\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n\nthen 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。\n\np0 开始便处于 fulfilled 状态，当执行\n\n    const p1 = p0.then(() => {throw new Error('456')})\n\n时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n跑完余下所有的代码。\n\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n\np1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n开始执行 microtask 队列，核心方法是 [MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114)，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。\n\n在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 [PromiseReactionJob](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43)，源码如下：\n\n    transitioning\n    macro PromiseReactionJob(\n        context: Context, argument: JSAny, handler: Callable|Undefined,\n        promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n        reactionType: constexpr PromiseReactionType): JSAny {\n      if (handler == Undefined) {\n        // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n        if constexpr (reactionType == kPromiseReactionFulfill) {\n          // 基本类同 JS 层的 resolve\n          return FuflfillPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        } else {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        }\n      } else {\n        try {\n          // 试图调用 Promise 处理函数，相当于 handler(argument)\n          const result =\n              Call(context, UnsafeCast<Callable>(handler), Undefined, argument);\n            // 基本类同 JS 层的 resolve\n            return FuflfillPromiseReactionJob(\n                context, promiseOrCapability, result, reactionType);\n        } catch (e) {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, e, reactionType);\n        }\n      }\n    }\n\nPromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 '123'，handler 是函数 () => {throw new Error('456')}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。\n\nhandler 有值，进入 else 分支，在 try...catch 包裹下，试图调用 handler。handler 里 throw new Error('456') 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。\n\n新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：\n\n![](https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg)\n\nhandler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。\n\n开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error('456')，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error('456')，自己没有相应状态的处理函数，把从 p0 收到的 Error('456') 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg)\n\n还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error('456')，handler 是 (e) => console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try...catch 中试图 handler，handler 不再抛异常，打印 Error('456')，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg)\n\n后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) => console.log(e) 的返回值是 undefined，所以 (data) => console.log(data) 打印 undefined。\n\n执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。\n\n![](https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg)\n\n回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=> console.log(data) 得到执行的机会。\n\n    // 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n    // 调用本级的 handler，将本级的 argument 和状态传给下一级\n    // 有点类似数组的 reduce 方法\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n        // 恢复成 fulfilled 状态\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n\n## 总结与感想\n\n本文看似篇幅略长，其实大部分内容是 [Promise A+](https://promisesaplus.com/#notes) 规范的 2.2.7 节，规范简直字字珠玑，膜拜。\n\n![](https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg)\n\n## 转载说明\n\n本文经由作者同意，转载自知乎用户[徐鹏跃](https://www.zhihu.com/people/kan-a-79)\n<a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a>\n","source":"_posts/Promise V8 源码分析(二).md","raw":"---\ntitle: Promise V8 源码分析(二)\ndate: 2020-12-14 14:14:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: 基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。\ncategories: 技术\ntags:\n  - JavaScript\n  - 转载\n---\n\n基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。\n\n## reject\n\n    new Promise((resolve, reject) => {\n      setTimeout(_ => reject('rejected'), 5000)\n    }).then(_ => {\n      console.log('fulfilled')\n    }, reason => {\n      console.log(reason)\n    })\n\n上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 [RejectPromise](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210) 函数，源码如下：\n\n    transitioning builtin\n    RejectPromise(implicit context: Context)(\n        promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny {\n      // 取出 Promise 的处理对象 PromiseReaction\n      const reactions =\n          UnsafeCast<(Zero | PromiseReaction)>(promise.reactions_or_result);\n      // 这里的 reason 就是 reject 函数的参数\n      promise.reactions_or_result = reason;\n      // 设置 Promise 的状态为 rejected\n      promise.SetStatus(PromiseState::kRejected);\n      TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n      return Undefined;\n    }\n\n[TriggerPromiseReactions](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140) 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：\n\n    // https://tc39.es/ecma262/#sec-triggerpromisereactions\n    transitioning macro TriggerPromiseReactions(implicit context: Context)(\n        reactions: Zero|PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      // 删减了链表反转的代码\n      let current = reactions;\n      // reactions 是一个链表，下面的 while 循环遍历链表\n      while (true) {\n        typeswitch (current) {\n          case (Zero): {\n            break;\n          }\n          case (currentReaction: PromiseReaction): {\n            // 取出链表下一个结点\n            current = currentReaction.next;\n            // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n            MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n          }\n        }\n      }\n    }\n\n[MorphAndEnqueuePromiseReaction](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84) 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。\n\nMorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。\n\n    transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n        promiseReaction: PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      let primaryHandler: Callable|Undefined;\n      let secondaryHandler: Callable|Undefined;\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        primaryHandler = promiseReaction.fulfill_handler;\n        secondaryHandler = promiseReaction.reject_handler;\n      } else {\n        primaryHandler = promiseReaction.reject_handler;\n        secondaryHandler = promiseReaction.fulfill_handler;\n      }\n      const handlerContext: Context =\n          ExtractHandlerContext(primaryHandler, secondaryHandler);\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        // 删\n      } else {\n        * UnsafeConstCast(& promiseReaction.map) =\n            PromiseRejectReactionJobTaskMapConstant();\n        const promiseReactionJobTask =\n            UnsafeCast<PromiseRejectReactionJobTask>(promiseReaction);\n        // argument 是 reject 的参数\n        promiseReactionJobTask.argument = argument;\n        promiseReactionJobTask.context = handlerContext;\n        // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n        promiseReactionJobTask.handler = primaryHandler;\n        // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n        // EnqueueMicrotask 将 microtask 插入 microtask 队列\n        EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n      }\n    }\n\nreject 和 resolve 的逻辑基本相同，分为 3 步：\n\n- 设置 Promise 的 value/reason，也就是 resolve/reject 的参数\n- 设置 Promise 的状态：fulfilled/rejected\n- 从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列\n\n## catch\n\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        console.log('rejected')\n    })\n\n以上面代码为例，当 catch 方法执行时，调用了 V8 的 [PromisePrototypeCatch](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100) 方法，源码如下：\n\n    transitioning javascript builtin\n    PromisePrototypeCatch(\n        js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny {\n      const nativeContext = LoadNativeContext(context);\n      return UnsafeCast<JSAny>(\n          InvokeThen(nativeContext, receiver, Undefined, onRejected));\n    }\n\nPromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，[InvokeThen](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199) 源码如下：\n\n    transitioning\n    macro InvokeThen<F: type>(implicit context: Context)(\n        nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n        callFunctor: F): JSAny {\n      if (!Is<Smi>(receiver) &&\n          IsPromiseThenLookupChainIntact(\n              nativeContext, UnsafeCast<HeapObject>(receiver).map)) {\n        const then =\n            UnsafeCast<JSAny>(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n        // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n        return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n      } else\n        deferred {\n          const then = UnsafeCast<JSAny>(GetProperty(receiver, kThenString));\n          // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n          return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n        }\n    }\n\nInvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。\n\n既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。\n\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        throw 'rejected'\n    }).catch(_ => {\n        console.log('last catch')\n    })\n\n上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。\n\n> catch 方法通过底层调用 then 方法来实现  \n> 假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)\n\n## then 的链式调用与 microtask 队列\n\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n\n以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。\n\n    const p0 = Promise.resolve('123')\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n\nthen 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。\n\np0 开始便处于 fulfilled 状态，当执行\n\n    const p1 = p0.then(() => {throw new Error('456')})\n\n时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n跑完余下所有的代码。\n\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n\np1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n开始执行 microtask 队列，核心方法是 [MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114)，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。\n\n在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 [PromiseReactionJob](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43)，源码如下：\n\n    transitioning\n    macro PromiseReactionJob(\n        context: Context, argument: JSAny, handler: Callable|Undefined,\n        promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n        reactionType: constexpr PromiseReactionType): JSAny {\n      if (handler == Undefined) {\n        // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n        if constexpr (reactionType == kPromiseReactionFulfill) {\n          // 基本类同 JS 层的 resolve\n          return FuflfillPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        } else {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        }\n      } else {\n        try {\n          // 试图调用 Promise 处理函数，相当于 handler(argument)\n          const result =\n              Call(context, UnsafeCast<Callable>(handler), Undefined, argument);\n            // 基本类同 JS 层的 resolve\n            return FuflfillPromiseReactionJob(\n                context, promiseOrCapability, result, reactionType);\n        } catch (e) {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, e, reactionType);\n        }\n      }\n    }\n\nPromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 '123'，handler 是函数 () => {throw new Error('456')}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。\n\nhandler 有值，进入 else 分支，在 try...catch 包裹下，试图调用 handler。handler 里 throw new Error('456') 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。\n\n新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：\n\n![](https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg)\n\nhandler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。\n\n开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error('456')，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error('456')，自己没有相应状态的处理函数，把从 p0 收到的 Error('456') 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg)\n\n还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error('456')，handler 是 (e) => console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try...catch 中试图 handler，handler 不再抛异常，打印 Error('456')，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg)\n\n后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) => console.log(e) 的返回值是 undefined，所以 (data) => console.log(data) 打印 undefined。\n\n执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。\n\n![](https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg)\n\n回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=> console.log(data) 得到执行的机会。\n\n    // 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n    // 调用本级的 handler，将本级的 argument 和状态传给下一级\n    // 有点类似数组的 reduce 方法\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n        // 恢复成 fulfilled 状态\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n\n## 总结与感想\n\n本文看似篇幅略长，其实大部分内容是 [Promise A+](https://promisesaplus.com/#notes) 规范的 2.2.7 节，规范简直字字珠玑，膜拜。\n\n![](https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg)\n\n## 转载说明\n\n本文经由作者同意，转载自知乎用户[徐鹏跃](https://www.zhihu.com/people/kan-a-79)\n<a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a>\n","slug":"Promise V8 源码分析(二)","published":1,"updated":"2020-12-14T06:21:16.078Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckkoz6g76001mbwr4ct3e8rg5","content":"<p>基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。</p>\n<h2 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject\"></a>reject</h2><pre><code>new Promise((resolve, reject) =&gt; &#123;\n  setTimeout(_ =&gt; reject(&#39;rejected&#39;), 5000)\n&#125;).then(_ =&gt; &#123;\n  console.log(&#39;fulfilled&#39;)\n&#125;, reason =&gt; &#123;\n  console.log(reason)\n&#125;)</code></pre>\n<p>上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210\">RejectPromise</a> 函数，源码如下：</p>\n<pre><code>transitioning builtin\nRejectPromise(implicit context: Context)(\n    promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny &#123;\n  // 取出 Promise 的处理对象 PromiseReaction\n  const reactions =\n      UnsafeCast&lt;(Zero | PromiseReaction)&gt;(promise.reactions_or_result);\n  // 这里的 reason 就是 reject 函数的参数\n  promise.reactions_or_result = reason;\n  // 设置 Promise 的状态为 rejected\n  promise.SetStatus(PromiseState::kRejected);\n  TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n  return Undefined;\n&#125;</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140\">TriggerPromiseReactions</a> 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：</p>\n<pre><code>// https://tc39.es/ecma262/#sec-triggerpromisereactions\ntransitioning macro TriggerPromiseReactions(implicit context: Context)(\n    reactions: Zero|PromiseReaction, argument: JSAny,\n    reactionType: constexpr PromiseReactionType): void &#123;\n  // 删减了链表反转的代码\n  let current = reactions;\n  // reactions 是一个链表，下面的 while 循环遍历链表\n  while (true) &#123;\n    typeswitch (current) &#123;\n      case (Zero): &#123;\n        break;\n      &#125;\n      case (currentReaction: PromiseReaction): &#123;\n        // 取出链表下一个结点\n        current = currentReaction.next;\n        // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n        MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84\">MorphAndEnqueuePromiseReaction</a> 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。</p>\n<p>MorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。</p>\n<pre><code>transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n    promiseReaction: PromiseReaction, argument: JSAny,\n    reactionType: constexpr PromiseReactionType): void &#123;\n  let primaryHandler: Callable|Undefined;\n  let secondaryHandler: Callable|Undefined;\n  if constexpr (reactionType == kPromiseReactionFulfill) &#123;\n    primaryHandler = promiseReaction.fulfill_handler;\n    secondaryHandler = promiseReaction.reject_handler;\n  &#125; else &#123;\n    primaryHandler = promiseReaction.reject_handler;\n    secondaryHandler = promiseReaction.fulfill_handler;\n  &#125;\n  const handlerContext: Context =\n      ExtractHandlerContext(primaryHandler, secondaryHandler);\n  if constexpr (reactionType == kPromiseReactionFulfill) &#123;\n    // 删\n  &#125; else &#123;\n    * UnsafeConstCast(&amp; promiseReaction.map) =\n        PromiseRejectReactionJobTaskMapConstant();\n    const promiseReactionJobTask =\n        UnsafeCast&lt;PromiseRejectReactionJobTask&gt;(promiseReaction);\n    // argument 是 reject 的参数\n    promiseReactionJobTask.argument = argument;\n    promiseReactionJobTask.context = handlerContext;\n    // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n    promiseReactionJobTask.handler = primaryHandler;\n    // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n    // EnqueueMicrotask 将 microtask 插入 microtask 队列\n    EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n  &#125;\n&#125;</code></pre>\n<p>reject 和 resolve 的逻辑基本相同，分为 3 步：</p>\n<ul>\n<li>设置 Promise 的 value/reason，也就是 resolve/reject 的参数</li>\n<li>设置 Promise 的状态：fulfilled/rejected</li>\n<li>从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列</li>\n</ul>\n<h2 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch\"></a>catch</h2><pre><code>new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(reject, 2000)\n&#125;).catch(_ =&gt; &#123;\n    console.log(&#39;rejected&#39;)\n&#125;)</code></pre>\n<p>以上面代码为例，当 catch 方法执行时，调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100\">PromisePrototypeCatch</a> 方法，源码如下：</p>\n<pre><code>transitioning javascript builtin\nPromisePrototypeCatch(\n    js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny &#123;\n  const nativeContext = LoadNativeContext(context);\n  return UnsafeCast&lt;JSAny&gt;(\n      InvokeThen(nativeContext, receiver, Undefined, onRejected));\n&#125;</code></pre>\n<p>PromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，<a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199\">InvokeThen</a> 源码如下：</p>\n<pre><code>transitioning\nmacro InvokeThen&lt;F: type&gt;(implicit context: Context)(\n    nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n    callFunctor: F): JSAny &#123;\n  if (!Is&lt;Smi&gt;(receiver) &amp;&amp;\n      IsPromiseThenLookupChainIntact(\n          nativeContext, UnsafeCast&lt;HeapObject&gt;(receiver).map)) &#123;\n    const then =\n        UnsafeCast&lt;JSAny&gt;(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n    // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n    return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n  &#125; else\n    deferred &#123;\n      const then = UnsafeCast&lt;JSAny&gt;(GetProperty(receiver, kThenString));\n      // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n      return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n    &#125;\n&#125;</code></pre>\n<p>InvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。</p>\n<p>既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。</p>\n<pre><code>new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(reject, 2000)\n&#125;).catch(_ =&gt; &#123;\n    throw &#39;rejected&#39;\n&#125;).catch(_ =&gt; &#123;\n    console.log(&#39;last catch&#39;)\n&#125;)</code></pre>\n<p>上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。</p>\n<blockquote>\n<p>catch 方法通过底层调用 then 方法来实现<br>假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)</p>\n</blockquote>\n<h2 id=\"then-的链式调用与-microtask-队列\"><a href=\"#then-的链式调用与-microtask-队列\" class=\"headerlink\" title=\"then 的链式调用与 microtask 队列\"></a>then 的链式调用与 microtask 队列</h2><pre><code>Promise.resolve(&#39;123&#39;)\n    .then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\n    .then(_ =&gt; &#123;\n        console.log(&#39;shouldnot be here&#39;)\n    &#125;)\n    .catch((e) =&gt; console.log(e))\n    .then((data) =&gt; console.log(data));</code></pre>\n<p>以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。</p>\n<pre><code>const p0 = Promise.resolve(&#39;123&#39;)\nconst p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\nconst p2 = p1.then(_ =&gt; &#123;\n    console.log(&#39;shouldnot be here&#39;)\n&#125;)\nconst p3 = p2.catch((e) =&gt; console.log(e))\nconst p4 = p3.then((data) =&gt; console.log(data));</code></pre>\n<p>then 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。</p>\n<p>p0 开始便处于 fulfilled 状态，当执行</p>\n<pre><code>const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)</code></pre>\n<p>时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>跑完余下所有的代码。</p>\n<pre><code>const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\nconst p2 = p1.then(_ =&gt; &#123;\n    console.log(&#39;shouldnot be here&#39;)\n&#125;)\nconst p3 = p2.catch((e) =&gt; console.log(e))\nconst p4 = p3.then((data) =&gt; console.log(data));</code></pre>\n<p>p1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>开始执行 microtask 队列，核心方法是 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114\">MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask</a>，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。</p>\n<p>在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43\">PromiseReactionJob</a>，源码如下：</p>\n<pre><code>transitioning\nmacro PromiseReactionJob(\n    context: Context, argument: JSAny, handler: Callable|Undefined,\n    promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n    reactionType: constexpr PromiseReactionType): JSAny &#123;\n  if (handler == Undefined) &#123;\n    // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n    if constexpr (reactionType == kPromiseReactionFulfill) &#123;\n      // 基本类同 JS 层的 resolve\n      return FuflfillPromiseReactionJob(\n          context, promiseOrCapability, argument, reactionType);\n    &#125; else &#123;\n      // 基本类同 JS 层的 reject\n      return RejectPromiseReactionJob(\n          context, promiseOrCapability, argument, reactionType);\n    &#125;\n  &#125; else &#123;\n    try &#123;\n      // 试图调用 Promise 处理函数，相当于 handler(argument)\n      const result =\n          Call(context, UnsafeCast&lt;Callable&gt;(handler), Undefined, argument);\n        // 基本类同 JS 层的 resolve\n        return FuflfillPromiseReactionJob(\n            context, promiseOrCapability, result, reactionType);\n    &#125; catch (e) &#123;\n      // 基本类同 JS 层的 reject\n      return RejectPromiseReactionJob(\n          context, promiseOrCapability, e, reactionType);\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>PromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 ‘123’，handler 是函数 () =&gt; {throw new Error(‘456’)}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。</p>\n<p>handler 有值，进入 else 分支，在 try…catch 包裹下，试图调用 handler。handler 里 throw new Error(‘456’) 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。</p>\n<p>新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：</p>\n<p><img src=\"https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg\"></p>\n<p>handler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。</p>\n<p>开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error(‘456’)，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error(‘456’)，自己没有相应状态的处理函数，把从 p0 收到的 Error(‘456’) 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg\"></p>\n<p>还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error(‘456’)，handler 是 (e) =&gt; console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try…catch 中试图 handler，handler 不再抛异常，打印 Error(‘456’)，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg\"></p>\n<p>后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) =&gt; console.log(e) 的返回值是 undefined，所以 (data) =&gt; console.log(data) 打印 undefined。</p>\n<p>执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg\"></p>\n<p>回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=&gt; console.log(data) 得到执行的机会。</p>\n<pre><code>// 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n// 调用本级的 handler，将本级的 argument 和状态传给下一级\n// 有点类似数组的 reduce 方法\nPromise.resolve(&#39;123&#39;)\n    .then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\n    .then(_ =&gt; &#123;\n        console.log(&#39;shouldnot be here&#39;)\n    &#125;)\n    // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n    // 恢复成 fulfilled 状态\n    .catch((e) =&gt; console.log(e))\n    .then((data) =&gt; console.log(data));</code></pre>\n<h2 id=\"总结与感想\"><a href=\"#总结与感想\" class=\"headerlink\" title=\"总结与感想\"></a>总结与感想</h2><p>本文看似篇幅略长，其实大部分内容是 <a href=\"https://promisesaplus.com/#notes\">Promise A+</a> 规范的 2.2.7 节，规范简直字字珠玑，膜拜。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg\"></p>\n<h2 id=\"转载说明\"><a href=\"#转载说明\" class=\"headerlink\" title=\"转载说明\"></a>转载说明</h2><p>本文经由作者同意，转载自知乎用户<a href=\"https://www.zhihu.com/people/kan-a-79\">徐鹏跃</a><br><a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。</p>\n<h2 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject\"></a>reject</h2><pre><code>new Promise((resolve, reject) =&gt; &#123;\n  setTimeout(_ =&gt; reject(&#39;rejected&#39;), 5000)\n&#125;).then(_ =&gt; &#123;\n  console.log(&#39;fulfilled&#39;)\n&#125;, reason =&gt; &#123;\n  console.log(reason)\n&#125;)</code></pre>\n<p>上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210\">RejectPromise</a> 函数，源码如下：</p>\n<pre><code>transitioning builtin\nRejectPromise(implicit context: Context)(\n    promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny &#123;\n  // 取出 Promise 的处理对象 PromiseReaction\n  const reactions =\n      UnsafeCast&lt;(Zero | PromiseReaction)&gt;(promise.reactions_or_result);\n  // 这里的 reason 就是 reject 函数的参数\n  promise.reactions_or_result = reason;\n  // 设置 Promise 的状态为 rejected\n  promise.SetStatus(PromiseState::kRejected);\n  TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n  return Undefined;\n&#125;</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140\">TriggerPromiseReactions</a> 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：</p>\n<pre><code>// https://tc39.es/ecma262/#sec-triggerpromisereactions\ntransitioning macro TriggerPromiseReactions(implicit context: Context)(\n    reactions: Zero|PromiseReaction, argument: JSAny,\n    reactionType: constexpr PromiseReactionType): void &#123;\n  // 删减了链表反转的代码\n  let current = reactions;\n  // reactions 是一个链表，下面的 while 循环遍历链表\n  while (true) &#123;\n    typeswitch (current) &#123;\n      case (Zero): &#123;\n        break;\n      &#125;\n      case (currentReaction: PromiseReaction): &#123;\n        // 取出链表下一个结点\n        current = currentReaction.next;\n        // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n        MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84\">MorphAndEnqueuePromiseReaction</a> 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。</p>\n<p>MorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。</p>\n<pre><code>transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n    promiseReaction: PromiseReaction, argument: JSAny,\n    reactionType: constexpr PromiseReactionType): void &#123;\n  let primaryHandler: Callable|Undefined;\n  let secondaryHandler: Callable|Undefined;\n  if constexpr (reactionType == kPromiseReactionFulfill) &#123;\n    primaryHandler = promiseReaction.fulfill_handler;\n    secondaryHandler = promiseReaction.reject_handler;\n  &#125; else &#123;\n    primaryHandler = promiseReaction.reject_handler;\n    secondaryHandler = promiseReaction.fulfill_handler;\n  &#125;\n  const handlerContext: Context =\n      ExtractHandlerContext(primaryHandler, secondaryHandler);\n  if constexpr (reactionType == kPromiseReactionFulfill) &#123;\n    // 删\n  &#125; else &#123;\n    * UnsafeConstCast(&amp; promiseReaction.map) =\n        PromiseRejectReactionJobTaskMapConstant();\n    const promiseReactionJobTask =\n        UnsafeCast&lt;PromiseRejectReactionJobTask&gt;(promiseReaction);\n    // argument 是 reject 的参数\n    promiseReactionJobTask.argument = argument;\n    promiseReactionJobTask.context = handlerContext;\n    // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n    promiseReactionJobTask.handler = primaryHandler;\n    // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n    // EnqueueMicrotask 将 microtask 插入 microtask 队列\n    EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n  &#125;\n&#125;</code></pre>\n<p>reject 和 resolve 的逻辑基本相同，分为 3 步：</p>\n<ul>\n<li>设置 Promise 的 value/reason，也就是 resolve/reject 的参数</li>\n<li>设置 Promise 的状态：fulfilled/rejected</li>\n<li>从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列</li>\n</ul>\n<h2 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch\"></a>catch</h2><pre><code>new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(reject, 2000)\n&#125;).catch(_ =&gt; &#123;\n    console.log(&#39;rejected&#39;)\n&#125;)</code></pre>\n<p>以上面代码为例，当 catch 方法执行时，调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100\">PromisePrototypeCatch</a> 方法，源码如下：</p>\n<pre><code>transitioning javascript builtin\nPromisePrototypeCatch(\n    js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny &#123;\n  const nativeContext = LoadNativeContext(context);\n  return UnsafeCast&lt;JSAny&gt;(\n      InvokeThen(nativeContext, receiver, Undefined, onRejected));\n&#125;</code></pre>\n<p>PromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，<a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199\">InvokeThen</a> 源码如下：</p>\n<pre><code>transitioning\nmacro InvokeThen&lt;F: type&gt;(implicit context: Context)(\n    nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n    callFunctor: F): JSAny &#123;\n  if (!Is&lt;Smi&gt;(receiver) &amp;&amp;\n      IsPromiseThenLookupChainIntact(\n          nativeContext, UnsafeCast&lt;HeapObject&gt;(receiver).map)) &#123;\n    const then =\n        UnsafeCast&lt;JSAny&gt;(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n    // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n    return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n  &#125; else\n    deferred &#123;\n      const then = UnsafeCast&lt;JSAny&gt;(GetProperty(receiver, kThenString));\n      // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n      return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n    &#125;\n&#125;</code></pre>\n<p>InvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。</p>\n<p>既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。</p>\n<pre><code>new Promise((resolve, reject) =&gt; &#123;\n    setTimeout(reject, 2000)\n&#125;).catch(_ =&gt; &#123;\n    throw &#39;rejected&#39;\n&#125;).catch(_ =&gt; &#123;\n    console.log(&#39;last catch&#39;)\n&#125;)</code></pre>\n<p>上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。</p>\n<blockquote>\n<p>catch 方法通过底层调用 then 方法来实现<br>假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)</p>\n</blockquote>\n<h2 id=\"then-的链式调用与-microtask-队列\"><a href=\"#then-的链式调用与-microtask-队列\" class=\"headerlink\" title=\"then 的链式调用与 microtask 队列\"></a>then 的链式调用与 microtask 队列</h2><pre><code>Promise.resolve(&#39;123&#39;)\n    .then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\n    .then(_ =&gt; &#123;\n        console.log(&#39;shouldnot be here&#39;)\n    &#125;)\n    .catch((e) =&gt; console.log(e))\n    .then((data) =&gt; console.log(data));</code></pre>\n<p>以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。</p>\n<pre><code>const p0 = Promise.resolve(&#39;123&#39;)\nconst p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\nconst p2 = p1.then(_ =&gt; &#123;\n    console.log(&#39;shouldnot be here&#39;)\n&#125;)\nconst p3 = p2.catch((e) =&gt; console.log(e))\nconst p4 = p3.then((data) =&gt; console.log(data));</code></pre>\n<p>then 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。</p>\n<p>p0 开始便处于 fulfilled 状态，当执行</p>\n<pre><code>const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)</code></pre>\n<p>时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>跑完余下所有的代码。</p>\n<pre><code>const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\nconst p2 = p1.then(_ =&gt; &#123;\n    console.log(&#39;shouldnot be here&#39;)\n&#125;)\nconst p3 = p2.catch((e) =&gt; console.log(e))\nconst p4 = p3.then((data) =&gt; console.log(data));</code></pre>\n<p>p1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>开始执行 microtask 队列，核心方法是 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114\">MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask</a>，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。</p>\n<p>在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43\">PromiseReactionJob</a>，源码如下：</p>\n<pre><code>transitioning\nmacro PromiseReactionJob(\n    context: Context, argument: JSAny, handler: Callable|Undefined,\n    promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n    reactionType: constexpr PromiseReactionType): JSAny &#123;\n  if (handler == Undefined) &#123;\n    // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n    if constexpr (reactionType == kPromiseReactionFulfill) &#123;\n      // 基本类同 JS 层的 resolve\n      return FuflfillPromiseReactionJob(\n          context, promiseOrCapability, argument, reactionType);\n    &#125; else &#123;\n      // 基本类同 JS 层的 reject\n      return RejectPromiseReactionJob(\n          context, promiseOrCapability, argument, reactionType);\n    &#125;\n  &#125; else &#123;\n    try &#123;\n      // 试图调用 Promise 处理函数，相当于 handler(argument)\n      const result =\n          Call(context, UnsafeCast&lt;Callable&gt;(handler), Undefined, argument);\n        // 基本类同 JS 层的 resolve\n        return FuflfillPromiseReactionJob(\n            context, promiseOrCapability, result, reactionType);\n    &#125; catch (e) &#123;\n      // 基本类同 JS 层的 reject\n      return RejectPromiseReactionJob(\n          context, promiseOrCapability, e, reactionType);\n    &#125;\n  &#125;\n&#125;</code></pre>\n<p>PromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 ‘123’，handler 是函数 () =&gt; {throw new Error(‘456’)}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。</p>\n<p>handler 有值，进入 else 分支，在 try…catch 包裹下，试图调用 handler。handler 里 throw new Error(‘456’) 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。</p>\n<p>新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：</p>\n<p><img src=\"https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg\"></p>\n<p>handler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。</p>\n<p>开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error(‘456’)，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error(‘456’)，自己没有相应状态的处理函数，把从 p0 收到的 Error(‘456’) 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg\"></p>\n<p>还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error(‘456’)，handler 是 (e) =&gt; console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try…catch 中试图 handler，handler 不再抛异常，打印 Error(‘456’)，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg\"></p>\n<p>后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) =&gt; console.log(e) 的返回值是 undefined，所以 (data) =&gt; console.log(data) 打印 undefined。</p>\n<p>执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg\"></p>\n<p>回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=&gt; console.log(data) 得到执行的机会。</p>\n<pre><code>// 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n// 调用本级的 handler，将本级的 argument 和状态传给下一级\n// 有点类似数组的 reduce 方法\nPromise.resolve(&#39;123&#39;)\n    .then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)\n    .then(_ =&gt; &#123;\n        console.log(&#39;shouldnot be here&#39;)\n    &#125;)\n    // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n    // 恢复成 fulfilled 状态\n    .catch((e) =&gt; console.log(e))\n    .then((data) =&gt; console.log(data));</code></pre>\n<h2 id=\"总结与感想\"><a href=\"#总结与感想\" class=\"headerlink\" title=\"总结与感想\"></a>总结与感想</h2><p>本文看似篇幅略长，其实大部分内容是 <a href=\"https://promisesaplus.com/#notes\">Promise A+</a> 规范的 2.2.7 节，规范简直字字珠玑，膜拜。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg\"></p>\n<h2 id=\"转载说明\"><a href=\"#转载说明\" class=\"headerlink\" title=\"转载说明\"></a>转载说明</h2><p>本文经由作者同意，转载自知乎用户<a href=\"https://www.zhihu.com/people/kan-a-79\">徐鹏跃</a><br><a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckkoz6g6i0001bwr4869j5y1i","category_id":"ckkoz6g6l0004bwr4gk057ldy","_id":"ckkoz6g6u000hbwr49ymb323p"},{"post_id":"ckkoz6g6k0003bwr4623oedfu","category_id":"ckkoz6g6l0004bwr4gk057ldy","_id":"ckkoz6g6w000kbwr40z94hikt"},{"post_id":"ckkoz6g6v000jbwr41vww7i2s","category_id":"ckkoz6g6l0004bwr4gk057ldy","_id":"ckkoz6g6x000obwr44ynpc6oa"},{"post_id":"ckkoz6g6o0007bwr4bm2c1tq5","category_id":"ckkoz6g6u000gbwr44kvjdhdl","_id":"ckkoz6g6y000sbwr47e6m83jp"},{"post_id":"ckkoz6g6p0009bwr4fg2b72zz","category_id":"ckkoz6g6w000lbwr422l21fu7","_id":"ckkoz6g6y000ubwr4685h6v24"},{"post_id":"ckkoz6g6q000bbwr4887z0ud3","category_id":"ckkoz6g6x000qbwr4fyls0nz6","_id":"ckkoz6g71000zbwr4g7pd20x8"},{"post_id":"ckkoz6g6s000ebwr43rhjbzyu","category_id":"ckkoz6g6x000qbwr4fyls0nz6","_id":"ckkoz6g710012bwr48q5ofio4"},{"post_id":"ckkoz6g6t000fbwr48kwshhwf","category_id":"ckkoz6g6z000ybwr4go2yh89k","_id":"ckkoz6g720015bwr4arkgh031"},{"post_id":"ckkoz6g75001lbwr45vlf9b07","category_id":"ckkoz6g6l0004bwr4gk057ldy","_id":"ckkoz6g77001pbwr4afv3cm78"},{"post_id":"ckkoz6g76001mbwr4ct3e8rg5","category_id":"ckkoz6g6l0004bwr4gk057ldy","_id":"ckkoz6g77001rbwr49p0l9mah"}],"PostTag":[{"post_id":"ckkoz6g6i0001bwr4869j5y1i","tag_id":"ckkoz6g6n0005bwr4dk3i1jt1","_id":"ckkoz6g6x000nbwr438wjcz1a"},{"post_id":"ckkoz6g6i0001bwr4869j5y1i","tag_id":"ckkoz6g6r000dbwr42ihp1j8n","_id":"ckkoz6g6x000pbwr41ggf8yxc"},{"post_id":"ckkoz6g6i0001bwr4869j5y1i","tag_id":"ckkoz6g6u000ibwr4bjie3is7","_id":"ckkoz6g6y000tbwr4fbbha9mx"},{"post_id":"ckkoz6g6k0003bwr4623oedfu","tag_id":"ckkoz6g6n0005bwr4dk3i1jt1","_id":"ckkoz6g710010bwr4ap91hs2i"},{"post_id":"ckkoz6g6k0003bwr4623oedfu","tag_id":"ckkoz6g6r000dbwr42ihp1j8n","_id":"ckkoz6g710011bwr46ijwb3gf"},{"post_id":"ckkoz6g6k0003bwr4623oedfu","tag_id":"ckkoz6g6u000ibwr4bjie3is7","_id":"ckkoz6g720014bwr4atqu1dfz"},{"post_id":"ckkoz6g6o0007bwr4bm2c1tq5","tag_id":"ckkoz6g6z000xbwr41bc8aqe8","_id":"ckkoz6g720017bwr492n87cnj"},{"post_id":"ckkoz6g6o0007bwr4bm2c1tq5","tag_id":"ckkoz6g710013bwr4dua876q1","_id":"ckkoz6g720018bwr4ggo99vie"},{"post_id":"ckkoz6g6p0009bwr4fg2b72zz","tag_id":"ckkoz6g720016bwr4bmfddkmr","_id":"ckkoz6g73001abwr4hsxe7c9w"},{"post_id":"ckkoz6g6q000bbwr4887z0ud3","tag_id":"ckkoz6g720019bwr4e893gojj","_id":"ckkoz6g73001cbwr49227a08u"},{"post_id":"ckkoz6g6s000ebwr43rhjbzyu","tag_id":"ckkoz6g720019bwr4e893gojj","_id":"ckkoz6g73001ebwr45pvubiid"},{"post_id":"ckkoz6g6t000fbwr48kwshhwf","tag_id":"ckkoz6g73001dbwr49p4r4qp6","_id":"ckkoz6g74001hbwr4540ucd1i"},{"post_id":"ckkoz6g6t000fbwr48kwshhwf","tag_id":"ckkoz6g74001fbwr47uh1apue","_id":"ckkoz6g74001ibwr477mx47ip"},{"post_id":"ckkoz6g6v000jbwr41vww7i2s","tag_id":"ckkoz6g6n0005bwr4dk3i1jt1","_id":"ckkoz6g74001jbwr4c23nb0dq"},{"post_id":"ckkoz6g6v000jbwr41vww7i2s","tag_id":"ckkoz6g74001gbwr4b9e14l6h","_id":"ckkoz6g74001kbwr4cme5ab0s"},{"post_id":"ckkoz6g75001lbwr45vlf9b07","tag_id":"ckkoz6g6n0005bwr4dk3i1jt1","_id":"ckkoz6g77001nbwr48db1g9x7"},{"post_id":"ckkoz6g75001lbwr45vlf9b07","tag_id":"ckkoz6g74001gbwr4b9e14l6h","_id":"ckkoz6g77001obwr473hw2scn"},{"post_id":"ckkoz6g76001mbwr4ct3e8rg5","tag_id":"ckkoz6g6n0005bwr4dk3i1jt1","_id":"ckkoz6g77001qbwr43fgu30qe"},{"post_id":"ckkoz6g76001mbwr4ct3e8rg5","tag_id":"ckkoz6g74001gbwr4b9e14l6h","_id":"ckkoz6g77001sbwr491r4bf7m"}],"Tag":[{"name":"JavaScript","_id":"ckkoz6g6n0005bwr4dk3i1jt1"},{"name":"LeetCode","_id":"ckkoz6g6r000dbwr42ihp1j8n"},{"name":"学习总结","_id":"ckkoz6g6u000ibwr4bjie3is7"},{"name":"Typora","_id":"ckkoz6g6z000xbwr41bc8aqe8"},{"name":"Markdown","_id":"ckkoz6g710013bwr4dua876q1"},{"name":"Git","_id":"ckkoz6g720016bwr4bmfddkmr"},{"name":"随笔","_id":"ckkoz6g720019bwr4e893gojj"},{"name":"个人简介","_id":"ckkoz6g73001dbwr49p4r4qp6"},{"name":"博客简介","_id":"ckkoz6g74001fbwr47uh1apue"},{"name":"转载","_id":"ckkoz6g74001gbwr4b9e14l6h"}]}}