{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery-master/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.png","path":"medias/avatar.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/icp.png","path":"medias/icp.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/logo.png","path":"medias/logo.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar1.png","path":"medias/avatar1.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/logo5.png","path":"medias/logo5.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/comment_bg.png","path":"medias/comment_bg.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeBlockFuction.js","path":"libs/codeBlock/codeBlockFuction.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeCopy.js","path":"libs/codeBlock/codeCopy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeShrink.js","path":"libs/codeBlock/codeShrink.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeLang.js","path":"libs/codeBlock/codeLang.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/instantpage/instantpage.js","path":"libs/instantpage/instantpage.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/jquery/jquery.min.js","path":"libs/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/css/all.css","path":"libs/awesome/css/all.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.eot","path":"libs/awesome/webfonts/fa-brands-400.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.svg","path":"libs/awesome/webfonts/fa-brands-400.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff2","path":"libs/awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.eot","path":"libs/awesome/webfonts/fa-regular-400.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.ttf","path":"libs/awesome/webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.svg","path":"libs/awesome/webfonts/fa-regular-400.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff","path":"libs/awesome/webfonts/fa-regular-400.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff2","path":"libs/awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.svg","path":"libs/awesome/webfonts/fa-solid-900.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.ttf","path":"libs/awesome/webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff","path":"libs/awesome/webfonts/fa-solid-900.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff2","path":"libs/awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.eot","path":"libs/awesome/webfonts/fa-solid-900.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.ttf","path":"libs/awesome/webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff","path":"libs/awesome/webfonts/fa-brands-400.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"1a029a492861cf92cd5f267fadd2322bb7f9c70d","modified":1603440099030},{"_id":"source/_posts/2021-02-25博客.md","hash":"7be5ba34498ed2bc74dc51e7b5304fd6890bc05f","modified":1614320936600},{"_id":"source/_posts/2021-03-09博客.md","hash":"3f2bef00bdccbf75d5e62519642f6bcb6b4e162c","modified":1615453883746},{"_id":"source/_posts/2021-03-02博客.md","hash":"e8ca448af1b6615cee60c35dc1c70f2a2d211a96","modified":1615194910086},{"_id":"source/_posts/LeetCode 64 Minimum Path Sum.md","hash":"3f28495e644b530fc535429094e9858dab3b4a15","modified":1614319905453},{"_id":"source/_posts/2021-03-17博客.md","hash":"ad6d522396e4008a87f119936be489bda4eed0c6","modified":1617162971783},{"_id":"source/_posts/2021-04-01博客.md","hash":"fefcd521570a97029f21e7dceee5aa2ae695fdaa","modified":1617670707086},{"_id":"source/_posts/一篇来自2018年4月17日的Git笔记.md","hash":"92c6cd7aab3988159ceebd4f41f3681f501d12c5","modified":1605602296685},{"_id":"source/_posts/LeetCode 70 Climb Stairs.md","hash":"0339784304724cf17abe6c5bbdcfc8f20271d56d","modified":1614319937717},{"_id":"source/_posts/不是LeetCode的02题.md","hash":"0e37988ecd8620d93d5a04ffab6c05dbe44bab7b","modified":1615347279102},{"_id":"source/_posts/不是LeetCode的01题.md","hash":"049088fb009d6ab655058aa3322e523184bac7b3","modified":1614319251293},{"_id":"source/_posts/不是LeetCode的03题.md","hash":"d148891f76646cbd079325d52fa92c123fc08735","modified":1616121620854},{"_id":"source/_posts/不是LeetCode的07题.md","hash":"0b8ae4cecacc3a3cef9d3d611659342fdbf07a6e","modified":1617180812067},{"_id":"source/_posts/使用CSDN-markdown编辑器.md","hash":"1373c0c5db2a4ccdd757e413eb183a05d2d96476","modified":1604734149539},{"_id":"source/_posts/Promise V8 源码分析(二).md","hash":"07ef06a6756a9b3febe49371992a405a0a9f5b03","modified":1614320138356},{"_id":"source/_posts/不是LeetCode的04&05题.md","hash":"dd513f1f8d47b2714b0b068601449129a7d1d1fd","modified":1616392236765},{"_id":"source/about/index.md","hash":"9105689fa67a906e190688bdbee17b211677fbe6","modified":1603440099035},{"_id":"source/contact/index.md","hash":"8055bf0d0de9a37f5ab589d2a00d5bcb8f0099cb","modified":1603440099039},{"_id":"source/tags/index.md","hash":"c04e8cf7ca8aa9a79c958b427bce614c17e39691","modified":1603440099042},{"_id":"source/_posts/不是LeetCode的06题.md","hash":"b8080e9a100c4ab696955bfd8be63f9add4305c5","modified":1616569948964},{"_id":"source/categories/index.md","hash":"6b6ac2b912947667f3e6ec4091975f7d343e2818","modified":1603440099037},{"_id":"source/_posts/无博客无心情.md","hash":"3ef352d34058a31b06ad5fb61aa45d8fa4784216","modified":1612689449582},{"_id":"source/_posts/彻底理解Promise原理及全功能实现.md","hash":"2cbebea7cc2007b4cea38a179275adf6d5475cb6","modified":1614319701982},{"_id":"source/_posts/提上日程的几件事.md","hash":"3a9444587095254bb8fa4b9cd1283b27f8028d30","modified":1609903987797},{"_id":"source/_posts/理解 JavaScript 的 async&await.md","hash":"c3906050c477a13140df17916f46a469d9fb46d7","modified":1614319854150},{"_id":"source/_posts/这个Blog还有我.md","hash":"e5c534989513e81a8c8879b1a92c1af5a99a6aa5","modified":1609902961088},{"_id":"themes/hexo-theme-matery-master/.gitignore","hash":"5340c994462c7345373e075529f40e60c1952f00","modified":1603440099045},{"_id":"themes/hexo-theme-matery-master/LICENSE","hash":"b314c7ebb7d599944981908b7f3ed33a30e78f3a","modified":1603440099046},{"_id":"themes/hexo-theme-matery-master/README_CN.md","hash":"f280ab55f3aaff01bc1dfb24e8ea6ada54054065","modified":1614318389715},{"_id":"themes/hexo-theme-matery-master/_config.yml","hash":"1fa6796804d205e3f3534e165dab5307e5153b55","modified":1614830016104},{"_id":"themes/hexo-theme-matery-master/languages/zh-CN.yml","hash":"13ce732a54ce08b0ca01f14fd09cbe8fc418de21","modified":1603440099055},{"_id":"themes/hexo-theme-matery-master/languages/zh-HK.yml","hash":"ae34ac0e175c3037675722e436637efbceea32f0","modified":1603440099057},{"_id":"themes/hexo-theme-matery-master/layout/categories.ejs","hash":"c431e772d0f7700592228bbd9502793bdc28a893","modified":1603440099130},{"_id":"themes/hexo-theme-matery-master/layout/404.ejs","hash":"162136ceca6c95928c90a1adef8fabc2161d5c0e","modified":1603440099059},{"_id":"themes/hexo-theme-matery-master/layout/about.ejs","hash":"88e23163aae5dff7a2e7050f55c3754f0e76ae68","modified":1603440099128},{"_id":"themes/hexo-theme-matery-master/layout/category.ejs","hash":"4ac716d15d84e7c37f07308a5ec008a2ac090c9b","modified":1603440099132},{"_id":"themes/hexo-theme-matery-master/layout/contact.ejs","hash":"72fb5af3fc2f8955e2eb10926bbe4532a04ccd1b","modified":1603440099134},{"_id":"themes/hexo-theme-matery-master/layout/friends.ejs","hash":"e9716a948172e6ad46c18cc7e78770cdc46f1857","modified":1603440099135},{"_id":"themes/hexo-theme-matery-master/layout/index.ejs","hash":"3cabb8e3680858c1412277def37bdef73981be0f","modified":1603440099137},{"_id":"themes/hexo-theme-matery-master/languages/default.yml","hash":"9baf9370d0d7494e8575934e4bd0fa6d24484052","modified":1603440099054},{"_id":"themes/hexo-theme-matery-master/layout/layout.ejs","hash":"e179c72cb4eef88e5168cadafa2e1c3b46fd1486","modified":1603440099138},{"_id":"themes/hexo-theme-matery-master/layout/archive.ejs","hash":"57733d52d17361e735fcc95f875e0b1b9ebdcbd8","modified":1603440099129},{"_id":"themes/hexo-theme-matery-master/layout/post.ejs","hash":"3783bb4d7807e3a3701d67499a878c69a0a872d6","modified":1603440099140},{"_id":"themes/hexo-theme-matery-master/layout/tag.ejs","hash":"058eb27ff10f5314d8b9e334c54419b9a6572315","modified":1603440099141},{"_id":"themes/hexo-theme-matery-master/README.md","hash":"bbc201f264ea3fca4ec3738728d4236626cd698a","modified":1603440099048},{"_id":"themes/hexo-theme-matery-master/layout/tags.ejs","hash":"851c0ee599e91e7b1d657673859e8b6ff79cf50b","modified":1603440099143},{"_id":"themes/hexo-theme-matery-master/layout/_partial/baidu-analytics.ejs","hash":"4b01030b7136192bdbd704e29a0fe12f92767551","modified":1603440099063},{"_id":"themes/hexo-theme-matery-master/layout/_partial/baidu-push.ejs","hash":"2841870e0c625787de348221e5ddb7bbe99ec5a2","modified":1603440099064},{"_id":"themes/hexo-theme-matery-master/layout/_partial/back-top.ejs","hash":"be527741c39c9dc4a13ad712b49fe8db0147fe1e","modified":1603440099062},{"_id":"themes/hexo-theme-matery-master/layout/_partial/bg-cover.ejs","hash":"d5a7b9bb96e04c0a3485dd873748f19c50a6a04f","modified":1603440099068},{"_id":"themes/hexo-theme-matery-master/source/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1603440099152},{"_id":"themes/hexo-theme-matery-master/layout/_partial/bg-cover-content.ejs","hash":"58a7a07f8ab81ecc19a78d897955ca1ad73defb3","modified":1603440099066},{"_id":"themes/hexo-theme-matery-master/layout/_partial/github-link.ejs","hash":"fd4034bca2eb3987dcf113e6477260bee97eb1e7","modified":1603440099073},{"_id":"themes/hexo-theme-matery-master/layout/_partial/disqus.ejs","hash":"1b392f2160f962f62f3ddf5e1155c7f2f4888e1d","modified":1603440099069},{"_id":"themes/hexo-theme-matery-master/layout/_partial/gitalk.ejs","hash":"27764936791ce36b527bea63689435346bbfb425","modified":1603440099072},{"_id":"themes/hexo-theme-matery-master/layout/_partial/google-analytics.ejs","hash":"890c8f04c1f4905dfceb3ea9fd6efdd040d79c01","modified":1603440099076},{"_id":"themes/hexo-theme-matery-master/layout/_partial/footer.ejs","hash":"e672e0d9cb233fd115f5d50612e0716ab4a150e2","modified":1614242220717},{"_id":"themes/hexo-theme-matery-master/layout/_partial/gitment.ejs","hash":"90888c945384aa1ee4650bd43bd7ea670f25828c","modified":1603440099075},{"_id":"themes/hexo-theme-matery-master/layout/_partial/head.ejs","hash":"adaeca6ae9064c41047c3fb4f8bd046b736ae457","modified":1603440099078},{"_id":"themes/hexo-theme-matery-master/layout/_partial/livere.ejs","hash":"42728561c09589f79b698eb059ab4def53ed3642","modified":1603440099083},{"_id":"themes/hexo-theme-matery-master/layout/_partial/index-cover.ejs","hash":"6dc2522bc03b65d0b421a643b21a78a59c8213c1","modified":1603440099081},{"_id":"themes/hexo-theme-matery-master/layout/_partial/minivaline.ejs","hash":"e1264587db510ae1885405aed433592291ae74c4","modified":1603440099084},{"_id":"themes/hexo-theme-matery-master/layout/_partial/header.ejs","hash":"4bcdbd27273dd1b7098d4cfa6479b5d6b138cd12","modified":1614229440896},{"_id":"themes/hexo-theme-matery-master/layout/_partial/navigation.ejs","hash":"5a2179a9a3de6f56b0aaa154a11919b8f34fcbf9","modified":1603440099087},{"_id":"themes/hexo-theme-matery-master/layout/_partial/mobile-nav.ejs","hash":"8ce2974b19765e1f05d935a4f18abf7c84a980da","modified":1603440099085},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-detail.ejs","hash":"8ad8a7ec3f6438af496c51fd6bef1684e158a9ef","modified":1603440099093},{"_id":"themes/hexo-theme-matery-master/layout/_partial/paging.ejs","hash":"d8773abab5d0b672b70a9df20a8f9f7f6b0a2dae","modified":1603440099089},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-statis.ejs","hash":"de0d5763ddd64463f43135678b64c044884b8406","modified":1603440099094},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-cover.ejs","hash":"7f583c935253e2bf6421791715ee9de4989add6e","modified":1603440099090},{"_id":"themes/hexo-theme-matery-master/layout/_partial/post-detail-toc.ejs","hash":"ea50a5669847740894d5737a6330bf1013ae2e65","modified":1603440099091},{"_id":"themes/hexo-theme-matery-master/layout/_partial/search.ejs","hash":"c5f1a2de30363f370c8c37994140d6ef4fd0c4b7","modified":1603440099101},{"_id":"themes/hexo-theme-matery-master/layout/_partial/reprint-statement.ejs","hash":"f67bc52bc5a2464ebe30f42c65c0ee38eeec2fda","modified":1603440099097},{"_id":"themes/hexo-theme-matery-master/layout/_partial/share.ejs","hash":"e50fae64b6cfdbed18861eb49eca5018a920c7a4","modified":1603440099102},{"_id":"themes/hexo-theme-matery-master/layout/_partial/prev-next.ejs","hash":"908ddab5b5d5662c50b46ada0e03e06fe0a6c310","modified":1603440099096},{"_id":"themes/hexo-theme-matery-master/layout/_widget/dream.ejs","hash":"d6692f8c81013191fce59f47df1b6171649181ca","modified":1603440099110},{"_id":"themes/hexo-theme-matery-master/layout/_partial/social-link.ejs","hash":"f640583d45179abc1ef57951e7f61fb9e10f44c9","modified":1603440099103},{"_id":"themes/hexo-theme-matery-master/layout/_partial/reward.ejs","hash":"90c2ab31492f8226454537d6b987e9399119047d","modified":1603440099099},{"_id":"themes/hexo-theme-matery-master/layout/_widget/category-cloud.ejs","hash":"3ef458166041a8a12e493cc5963a5af5d98c1dfc","modified":1603440099107},{"_id":"themes/hexo-theme-matery-master/layout/_widget/my-gallery.ejs","hash":"f5259f18a906f2862fe72b90c28125b5f6b7d0b1","modified":1603440099113},{"_id":"themes/hexo-theme-matery-master/layout/_widget/category-radar.ejs","hash":"131e2eabf6b216210efd0746300889adfee357be","modified":1603440099109},{"_id":"themes/hexo-theme-matery-master/layout/_partial/valine.ejs","hash":"ef335be75e3f26580583af8699b8497f350ae200","modified":1603440099105},{"_id":"themes/hexo-theme-matery-master/layout/_widget/post-calendar.ejs","hash":"fb5ee7674070956d134ddca6890a9bd3f398cc0f","modified":1603440099117},{"_id":"themes/hexo-theme-matery-master/layout/_widget/my-skills.ejs","hash":"9edbeb1ec6212762d597ae7a05b5a219f72c8f98","modified":1603440099116},{"_id":"themes/hexo-theme-matery-master/layout/_widget/my-projects.ejs","hash":"141f19a8aa41b7a21436f23ce114bd5fda932512","modified":1603440099114},{"_id":"themes/hexo-theme-matery-master/layout/_widget/post-charts.ejs","hash":"20f0b6155eee348276dd91790f6a52b1005a0518","modified":1603440099119},{"_id":"themes/hexo-theme-matery-master/layout/_widget/recommend.ejs","hash":"ba6f8992c44cd44585af25a283c09403b4fc0aca","modified":1603440099121},{"_id":"themes/hexo-theme-matery-master/layout/_widget/video.ejs","hash":"6eaab5fccff9ad69d1d877a0f0585e2fcb89ba52","modified":1603440099126},{"_id":"themes/hexo-theme-matery-master/source/css/gitment.css","hash":"d5ef623065d1fbc897119f7b70ccf7563e329917","modified":1603440099146},{"_id":"themes/hexo-theme-matery-master/layout/_widget/tag-cloud.ejs","hash":"d32898104477acef56c33d00a68b48db15dcf2e6","modified":1603440099122},{"_id":"themes/hexo-theme-matery-master/source/css/my-gitalk.css","hash":"4e3e855767ac5a48b13af1d6a42df13d8975e03f","modified":1603440099149},{"_id":"themes/hexo-theme-matery-master/layout/_widget/music.ejs","hash":"8fc0e6172abbed7084b06e3ed637ad37e2752c48","modified":1603440099112},{"_id":"themes/hexo-theme-matery-master/source/css/my.css","hash":"b3c32b573a4a9ef3dfeffbd544a9c3f451e67a54","modified":1603440099151},{"_id":"themes/hexo-theme-matery-master/layout/_widget/tag-wordcloud.ejs","hash":"03dcd0a7a9fdbcc2bc38a99a8fad96ae17a340fa","modified":1603440099124},{"_id":"themes/hexo-theme-matery-master/source/js/search.js","hash":"b4e7a09c79aecaa859032a7f39c25d2f6692e75a","modified":1603441088246},{"_id":"themes/hexo-theme-matery-master/source/css/matery.css","hash":"3d1d884dd41b54bf39142b565a3ca5bdfdd1775f","modified":1607561851373},{"_id":"themes/hexo-theme-matery-master/source/js/matery.js","hash":"ddfef10e80a09b8efb48c52ede773e71d5890c78","modified":1603440099154},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1609127654394},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar.png","hash":"d7a23545057457fd2b18a8be4043bd85c7fa133f","modified":1605253551274},{"_id":"themes/hexo-theme-matery-master/source/medias/logo5.png","hash":"1cca61789d6a2cbf210d4adb0bd1a758cd2567f3","modified":1490172414000},{"_id":"themes/hexo-theme-matery-master/source/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1603440099465},{"_id":"themes/hexo-theme-matery-master/source/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1603440099387},{"_id":"themes/hexo-theme-matery-master/source/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1603440099464},{"_id":"themes/hexo-theme-matery-master/source/medias/avatar1.png","hash":"6b6ab0d2be379f0e9d6bcb430ebe7dc013b4a593","modified":1614326300225},{"_id":"themes/hexo-theme-matery-master/source/libs/animate/animate.min.css","hash":"5dfcbcee866e9dc564916416281885f3e320871e","modified":1603440099158},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.css","hash":"ded9739f803d114c9168d3351fded72b3b478b4c","modified":1603440099161},{"_id":"themes/hexo-theme-matery-master/source/libs/aos/aos.js","hash":"5a8e6d07ffa55642418ab3fd4b263aa08284b77a","modified":1603440099163},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.css","hash":"7f4f8913f2d46ade2def5134e2cc8684a4b87939","modified":1603440099164},{"_id":"themes/hexo-theme-matery-master/source/libs/background/canvas-nest.js","hash":"d2569ef80127ed2f4af7ef4d9f82b037794eec69","modified":1603440099236},{"_id":"themes/hexo-theme-matery-master/source/libs/aplayer/APlayer.min.js","hash":"70c0c4a9bf698747b7c058c21287ad617355e5dd","modified":1603440099166},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeBlockFuction.js","hash":"a8133367d48199e7505c2d831ca848b4202b9ba6","modified":1603440099245},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1603440099243},{"_id":"themes/hexo-theme-matery-master/source/libs/cryptojs/crypto-js.min.js","hash":"33810b2b757fc4327bc1d3b83bb5e0d3dc1fec5b","modified":1603440099254},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeShrink.js","hash":"3edbe498f7bb9e7daa77f9db30e1b5eeab40e067","modified":1603440099251},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeLang.js","hash":"066d2c89ad429e44f6467b9267da782ccaad57de","modified":1603440099250},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1603440099242},{"_id":"themes/hexo-theme-matery-master/source/libs/codeBlock/codeCopy.js","hash":"6ab7871d36cab438bbd4d781bc1fe7618b46b6e7","modified":1603440099248},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.css","hash":"5d52d3b34fceb9d7e11f1beaf7ed380b4249dec4","modified":1603440099256},{"_id":"themes/hexo-theme-matery-master/source/libs/background/ribbon-dynamic.js","hash":"8f53dbd5f9a40c377664bf8ca0d5d5ed75b91757","modified":1603440099238},{"_id":"themes/hexo-theme-matery-master/source/libs/instantpage/instantpage.js","hash":"043eba3c85c2e2009a9fabf3c4fc55537852fd86","modified":1603440099286},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"26849509f196a2d21bbfd15696e5d5153163b8f1","modified":1603440099288},{"_id":"themes/hexo-theme-matery-master/source/libs/jqcloud/jqcloud.css","hash":"4e6538c8312aeeab845d361c37a8c1a0931241f0","modified":1603440099290},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment-default.css","hash":"a0625d8b432af8bdc820f8768d36cde439e7257c","modified":1603440099280},{"_id":"themes/hexo-theme-matery-master/source/libs/masonry/masonry.pkgd.min.js","hash":"f81cd7bfcf7aa2d043bd3e6077df42656fc44b82","modified":1603440099315},{"_id":"themes/hexo-theme-matery-master/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1603440099324},{"_id":"themes/hexo-theme-matery-master/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1603440099322},{"_id":"themes/hexo-theme-matery-master/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1603440099326},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1603440099345},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1609127654381},{"_id":"themes/hexo-theme-matery-master/source/libs/tocbot/tocbot.css","hash":"9783581bec83e6bd6cd279f0af23a2862f46a587","modified":1603440099344},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1609127654381},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.css","hash":"9c0bacfbd4519d3859e3bbb06128ba241804d8b1","modified":1603440099270},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1609127654377},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/13.jpg","hash":"5ce6744e22001ea3ae92ffe02e98f4c089154062","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/10.jpg","hash":"1ff884e3490fd62df03d8105ceb1909fd37cdf13","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/15.jpg","hash":"4554279261a8c6f82d05870f64508a415f45ca3f","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/16.jpg","hash":"646bc66b15a68bf64a9903badd955496032a08ee","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1609127654377},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/20.jpg","hash":"3b85e9a6c2b9603f78e98b894d93f73c3a7c3930","modified":1609127654381},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/21.jpg","hash":"54c2c4f4a15b36338ad9a476659746769132c1e5","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/22.jpg","hash":"e05e65785ebde483efd5d5b651a7a66b924cd0e5","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/23.jpg","hash":"3faaa5e369131266816dc5b3997ca89daca14f1e","modified":1609127654380},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/6.jpg","hash":"921658d29cfd2f6124e51782725e36da6cc21c23","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/7.jpg","hash":"7deaceeb3fe6bd548b44f1e8e78f50ed492fa8c4","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1609127654378},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/alipay.jpg","hash":"9cfc1f6338bc41f1c38c84702fad893810c8b9ae","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/8.jpg","hash":"afb00784bdf0f820f9734880565de6a35a4696db","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1603440099470},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/11.jpg","hash":"69a08011a66b1c99326fb620d3cf40037339b4f4","modified":1609127654379},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1603440099195},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1603440099202},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1603440099203},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1603440099295},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"f8cd48e1fff82ecd54a7ce3e69de8dba7c92d113","modified":1603440099312},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1603440099305},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1603440099309},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1603440099308},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1603440099200},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1603440099306},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1603440099332},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1603440099334},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1603440099335},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1603440099298},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1603440099301},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.svg","hash":"67d261ac428761389c895e1da73664e633e14a72","modified":1603440099299},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/jquery.share.min.js","hash":"de34668d902ec082d17ddb6dd7ad24255fb547c5","modified":1603440099339},{"_id":"themes/hexo-theme-matery-master/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1603440099302},{"_id":"themes/hexo-theme-matery-master/source/medias/cover.jpg","hash":"3c672af6b05588eda34fc0b07c0f24754713fbd9","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/libs/dplayer/DPlayer.min.js","hash":"82276be41d2001e820020a219b90ad5b026302d1","modified":1603440099258},{"_id":"themes/hexo-theme-matery-master/source/libs/gitment/gitment.js","hash":"5a13983930b019450e4fe01a407c64b3dd316be4","modified":1603440099282},{"_id":"themes/hexo-theme-matery-master/source/libs/jquery/jquery.min.js","hash":"a8927ac2830b2fdd4a729eb0eb7f80923539ceb9","modified":1603440099293},{"_id":"themes/hexo-theme-matery-master/source/libs/share/js/social-share.min.js","hash":"ba635a17a9d9d132369f9fe4b1fbcaf001ea6ac9","modified":1603440099341},{"_id":"themes/hexo-theme-matery-master/source/libs/share/css/share.min.css","hash":"7126de5cec8371e580b7b1f22512da0985cc39e5","modified":1603440099329},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/Valine.min.js","hash":"5fd4f64a277d64df8f5b8001ca47d06737f9773f","modified":1614326791154},{"_id":"themes/hexo-theme-matery-master/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1603440099336},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1609127654393},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/12.jpg","hash":"6c6d964c076c9beedcc57a238fc263810e34b841","modified":1609127654393},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/14.jpg","hash":"7ec0b8c6f4ffabe4c0c71face3b4a6964bc55c39","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/17.jpg","hash":"699bc6439f799b0e3648a1e0300beead8df29bd1","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/19.jpg","hash":"ec6e0a03fb1f482723fb3be891f6107e04431e26","modified":1609127654394},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1603440099193},{"_id":"themes/hexo-theme-matery-master/source/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1609127654392},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/css/all.css","hash":"6390d0a6e6211ebbd68b49759b4dec8b2a9f04c9","modified":1603440099170},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1603440099187},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1603440099234},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1603440099227},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1603440099175},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1603440099190},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.js","hash":"c843f0dc497314574c608ca28cc742bb041786d5","modified":1603440099320},{"_id":"themes/hexo-theme-matery-master/source/libs/valine/av-min.js","hash":"9cb4babc20eb8fb5a86c4b0cc894fdb0f3cd9534","modified":1603440099352},{"_id":"themes/hexo-theme-matery-master/source/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1603440099317},{"_id":"themes/hexo-theme-matery-master/source/libs/gitalk/gitalk.min.js","hash":"7a3534269fd922d722a76c3affefc68e21246898","modified":1603440099278},{"_id":"themes/hexo-theme-matery-master/source/medias/banner/6.jpg","hash":"0544de7906cae1d501bdb54da24cdebf526036a0","modified":1610180828519},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1603440099198},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1603440099224},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1603440099209},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1603440099183},{"_id":"themes/hexo-theme-matery-master/source/libs/echarts/echarts.min.js","hash":"8789b5e4daf0029a6c88f238f10e54d01c4fce82","modified":1603440099268},{"_id":"themes/hexo-theme-matery-master/source/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1603440099219},{"_id":"public/search.xml","hash":"dcac230cf635668d133379f6a020852ea3c7a705","modified":1617672272568},{"_id":"public/404.html","hash":"dcd4b741b2ed42b02ce394cf794703b28e2e0b4d","modified":1617672272568},{"_id":"public/about/index.html","hash":"9c42864e3aff985cc9c51127939b150033d0669e","modified":1617672272568},{"_id":"public/contact/index.html","hash":"2b2e3361e8cf7b810e567cdbc983a80a80d60df4","modified":1617672272568},{"_id":"public/categories/index.html","hash":"a5ca3f559073700b97e5bc85cb4a7260c9f7eccc","modified":1617672272568},{"_id":"public/tags/index.html","hash":"0344334d7f99dbbfda0c14f73e30427d2a2b906f","modified":1617672272568},{"_id":"public/2021/04/17/2021-04-01博客/index.html","hash":"042d624a64f2c1ff99df8059453f825ccac77413","modified":1617672272568},{"_id":"public/2021/03/31/不是LeetCode的07题/index.html","hash":"02ac28a8185fe36d067233a8468fd40e9fe884ee","modified":1617672272568},{"_id":"public/2021/03/24/不是LeetCode的06题/index.html","hash":"d93821108ff30ea9f5fae322c5524dce905ce094","modified":1617672272568},{"_id":"public/2021/03/22/不是LeetCode的04&05题/index.html","hash":"0d2d4d351848a637dd466fab7b54a81074137adc","modified":1617672272568},{"_id":"public/2021/03/19/不是LeetCode的03题/index.html","hash":"af3178d0d480abe6fa10478b0e00ab1c48eaeea3","modified":1617672272568},{"_id":"public/2021/03/17/2021-03-17博客/index.html","hash":"350cdaebdc8705bc8116e2a8501b76a8176b280a","modified":1617672272568},{"_id":"public/2021/03/10/不是LeetCode的02题/index.html","hash":"ba0f6bf06bbd27937c88b7d7ebf9cf1316408e1b","modified":1617672272568},{"_id":"public/2021/03/09/2021-03-09博客/index.html","hash":"f8e34c722c1297bae23c5f24d13e0ac808af0038","modified":1617672272568},{"_id":"public/2021/03/02/2021-03-02博客/index.html","hash":"5172408130821794afc53d49e567942127a92b00","modified":1617672272568},{"_id":"public/2021/02/25/不是LeetCode的01题/index.html","hash":"3591350e3ff008af5d415e9ba136a30803c87693","modified":1617672272568},{"_id":"public/2021/02/25/2021-02-25博客/index.html","hash":"b4f8ee286dbf7d72c7abdc4211b4360e5a10de3d","modified":1617672272568},{"_id":"public/2021/01/28/无博客无心情/index.html","hash":"8156df61152d4aeb6d4c5c0fbbd343c3f1e291e7","modified":1617672272568},{"_id":"public/2021/01/08/LeetCode 70 Climb Stairs/index.html","hash":"e01b59411874629660d2a58d63fdff86d7d8c889","modified":1617672272568},{"_id":"public/2021/01/08/LeetCode 64 Minimum Path Sum/index.html","hash":"def94af2d2bc7fa23d5ad371e6ce1cd297d8b739","modified":1617672272568},{"_id":"public/2020/12/14/Promise V8 源码分析(二)/index.html","hash":"1109dcc75a3ff72ccb8e8aa78ffb65f3356b8575","modified":1617672272568},{"_id":"public/2020/11/20/彻底理解Promise原理及全功能实现/index.html","hash":"a82f8f63bece9c00055bb71c065d1a9e25213a6e","modified":1617672272568},{"_id":"public/2020/11/17/提上日程的几件事/index.html","hash":"2d68f64a39874cba92c8014215375858b3509db9","modified":1617672272568},{"_id":"public/2020/11/13/理解 JavaScript 的 async&await/index.html","hash":"0ef5a8f0d5399adc6330a95c585e1c0f71c28bc3","modified":1617672272568},{"_id":"public/2020/11/09/一篇来自2018年4月17日的Git笔记/index.html","hash":"c03d7f6ed9d4a8fd1e6daed0a906d652a28f08b5","modified":1617672272568},{"_id":"public/2020/11/07/这个Blog还有我/index.html","hash":"59b68b5063432975a1da772092387e04e8c0933e","modified":1617672272568},{"_id":"public/2020/10/22/使用CSDN-markdown编辑器/index.html","hash":"bef78b89da755d865dca6afd4f21aab977c6a83d","modified":1617672272568},{"_id":"public/archives/index.html","hash":"e70bcfe461245833adf025ef2941d5baca46ba8c","modified":1617672272568},{"_id":"public/archives/page/2/index.html","hash":"91f178293285648df84d2e8b21f88eb6c97038af","modified":1617672272568},{"_id":"public/archives/2020/index.html","hash":"e8d9a194b354b38a015c2e3cd298d2d8b2eab589","modified":1617672272568},{"_id":"public/archives/2020/10/index.html","hash":"a11a2093ec85d0e197c1473210b02573ce21e66c","modified":1617672272568},{"_id":"public/archives/2020/11/index.html","hash":"73e481d9327649d9fce1525fbdfb4c9d112afed6","modified":1617672272568},{"_id":"public/archives/2020/12/index.html","hash":"d1e6ef28dd68010288eb99dd051fcb07bfcdcf03","modified":1617672272568},{"_id":"public/archives/2021/index.html","hash":"4a75f921020b32b40f1527a66b8e2d2a0cc29e60","modified":1617672272568},{"_id":"public/archives/2021/page/2/index.html","hash":"76b41a11fce9ac4868f900a27a43aacdb1661bd7","modified":1617672272568},{"_id":"public/archives/2021/01/index.html","hash":"9c838c82d8be473dc93b67fcc94c8da198faeb0b","modified":1617672272568},{"_id":"public/archives/2021/02/index.html","hash":"396470973cc1254e1baa93c0cd029143c29b1511","modified":1617672272568},{"_id":"public/archives/2021/03/index.html","hash":"3603a959e57948ed5a1f4976375d51d4194b5c6e","modified":1617672272568},{"_id":"public/archives/2021/04/index.html","hash":"e3ec1b9053127d5f0161bac160d264d9f4b4b3ad","modified":1617672272568},{"_id":"public/categories/随笔/index.html","hash":"71ffe042f3880f2d8831969b2b139da65e0a5a88","modified":1617672272568},{"_id":"public/categories/技术/index.html","hash":"19407cbf826838d85323b1adf3deb6902bcf7d03","modified":1617672272568},{"_id":"public/categories/Git/index.html","hash":"bf4008a1dedf0afd8fdb4aa459691bca15c863a4","modified":1617672272568},{"_id":"public/categories/Markdown/index.html","hash":"f544f5915ca22a84654d452fa8c6e76400534bc2","modified":1617672272568},{"_id":"public/categories/致来访者/index.html","hash":"f8d7dd7c075a64c0028c3c7fe1f26a55aa40eeb5","modified":1617672272568},{"_id":"public/index.html","hash":"bcd5a3b5e4b177673bb501f57ade0615f5e012ca","modified":1617672272568},{"_id":"public/page/2/index.html","hash":"cc7c86b966d75674a8c0befc9897e65627dcb6e9","modified":1617672272568},{"_id":"public/tags/随笔/index.html","hash":"1f3e4cf3c5f1adaa8d8cfb2c7f22971b318c20fb","modified":1617672272568},{"_id":"public/tags/JavaScript/index.html","hash":"924f8484f958af69e06119da1267532c9c197f62","modified":1617672272568},{"_id":"public/tags/LeetCode/index.html","hash":"bebee223ab4bea8193468dac54b189c09200f46c","modified":1617672272568},{"_id":"public/tags/学习总结/index.html","hash":"b4f9899c319402e7cbc73d652f6c9f144d5dda5d","modified":1617672272568},{"_id":"public/tags/Git/index.html","hash":"0cdb2958e3d5f6e8c1ed178a9be3815a52aad199","modified":1617672272568},{"_id":"public/tags/Typora/index.html","hash":"1d8a9d34fc5d2af2b9eb55d48fcc492d87e2eefa","modified":1617672272568},{"_id":"public/tags/Markdown/index.html","hash":"b24816e08d5288a1d2c0529490660f684158bb22","modified":1617672272568},{"_id":"public/tags/转载/index.html","hash":"d6628e5bd90179795ad09ffd81f0adac708e6aa2","modified":1617672272568},{"_id":"public/tags/个人简介/index.html","hash":"615e813e03a06aa1dadb34d4ce8381ec913891e3","modified":1617672272568},{"_id":"public/tags/博客简介/index.html","hash":"0e92b1154e8f9de8f1b287e7f846537cab494042","modified":1617672272568},{"_id":"public/favicon.png","hash":"774fee8c6d0be9dbb010b20f36c06848d06e3da0","modified":1617672272568},{"_id":"public/medias/logo.png","hash":"d9095f5ea8719374d9d1ff020279426f5b2a1396","modified":1617672272568},{"_id":"public/medias/icp.png","hash":"27a96f31f7d0413c6ade6f40e06f021f501151c7","modified":1617672272568},{"_id":"public/medias/avatar1.png","hash":"6b6ab0d2be379f0e9d6bcb430ebe7dc013b4a593","modified":1617672272568},{"_id":"public/medias/logo5.png","hash":"1cca61789d6a2cbf210d4adb0bd1a758cd2567f3","modified":1617672272568},{"_id":"public/medias/featureimages/16.jpg","hash":"646bc66b15a68bf64a9903badd955496032a08ee","modified":1617672272568},{"_id":"public/medias/featureimages/15.jpg","hash":"4554279261a8c6f82d05870f64508a415f45ca3f","modified":1617672272568},{"_id":"public/medias/featureimages/13.jpg","hash":"5ce6744e22001ea3ae92ffe02e98f4c089154062","modified":1617672272568},{"_id":"public/medias/featureimages/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1617672272568},{"_id":"public/medias/featureimages/21.jpg","hash":"54c2c4f4a15b36338ad9a476659746769132c1e5","modified":1617672272568},{"_id":"public/medias/featureimages/22.jpg","hash":"e05e65785ebde483efd5d5b651a7a66b924cd0e5","modified":1617672272568},{"_id":"public/medias/featureimages/23.jpg","hash":"3faaa5e369131266816dc5b3997ca89daca14f1e","modified":1617672272568},{"_id":"public/medias/featureimages/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1617672272568},{"_id":"public/medias/featureimages/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1617672272568},{"_id":"public/medias/featureimages/7.jpg","hash":"7deaceeb3fe6bd548b44f1e8e78f50ed492fa8c4","modified":1617672272568},{"_id":"public/medias/featureimages/6.jpg","hash":"921658d29cfd2f6124e51782725e36da6cc21c23","modified":1617672272568},{"_id":"public/medias/reward/alipay.jpg","hash":"9cfc1f6338bc41f1c38c84702fad893810c8b9ae","modified":1617672272568},{"_id":"public/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1617672272568},{"_id":"public/medias/featureimages/8.jpg","hash":"afb00784bdf0f820f9734880565de6a35a4696db","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-regular-400.eot","hash":"439c8afd3373acb4a73135a34e220464a89cd5e2","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff2","hash":"f6f653b4ea8fc487bdb590d39d5a726258a55f40","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-regular-400.woff","hash":"59439d3ad31d856d78ec3e2bd9f1eafa2c7a581c","modified":1617672272568},{"_id":"public/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1617672272568},{"_id":"public/libs/lightGallery/img/video-play.png","hash":"2962e03ddbe04d7e201a5acccac531a2bbccddfc","modified":1617672272568},{"_id":"public/libs/lightGallery/img/vimeo-play.png","hash":"9b72fc0f86a01467ed0b68c9cc4d604ec316d517","modified":1617672272568},{"_id":"public/libs/lightGallery/img/youtube-play.png","hash":"f8d11384d33b7a79ee2ba8d522844f14d5067a80","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-regular-400.ttf","hash":"0f4bd02942a54a6b3200d9078adff88c2812e751","modified":1617672272568},{"_id":"public/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1617672272568},{"_id":"public/medias/banner/2.jpg","hash":"8c7456d762315d5bbd194ddfe77349ec380be4b6","modified":1617672272568},{"_id":"public/libs/share/fonts/iconfont.svg","hash":"1d56c9d5db0273f07c43cc1397e440f98ba7827a","modified":1617672272568},{"_id":"public/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1617672272568},{"_id":"public/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1617672272568},{"_id":"public/libs/lightGallery/fonts/lg.svg","hash":"67d261ac428761389c895e1da73664e633e14a72","modified":1617672272568},{"_id":"public/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1617672272568},{"_id":"public/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1617672272568},{"_id":"public/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1617672272568},{"_id":"public/css/prism-tomorrow.css","hash":"733208631ad1ebf0ba27f7e6f02eb11414d4e284","modified":1617672272568},{"_id":"public/medias/avatar.png","hash":"d7a23545057457fd2b18a8be4043bd85c7fa133f","modified":1617672272568},{"_id":"public/medias/avatar.jpg","hash":"2a6287308628881ce27b9a7de53ba15c2be00d02","modified":1617672272568},{"_id":"public/medias/comment_bg.png","hash":"dfc93d24081884fbc58cab0f8fd19e77d31d6123","modified":1617672272568},{"_id":"public/medias/banner/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1617672272568},{"_id":"public/medias/banner/4.jpg","hash":"0d78ce4ce9258a8254b6a9aa9d1593f09dcdcbc5","modified":1617672272568},{"_id":"public/medias/banner/3.jpg","hash":"8fc7001fc7d0c874d981c27328e358c3ca54fdd5","modified":1617672272568},{"_id":"public/medias/banner/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1617672272568},{"_id":"public/medias/featureimages/0.jpg","hash":"5d68b5af67a7fd630b624cf28e64d8fbbae77a0e","modified":1617672272568},{"_id":"public/medias/featureimages/10.jpg","hash":"1ff884e3490fd62df03d8105ceb1909fd37cdf13","modified":1617672272568},{"_id":"public/medias/featureimages/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1617672272568},{"_id":"public/medias/featureimages/17.jpg","hash":"699bc6439f799b0e3648a1e0300beead8df29bd1","modified":1617672272568},{"_id":"public/medias/featureimages/18.jpg","hash":"64829272ec85bb819d55ff89e5b5fd6f64aa436b","modified":1617672272568},{"_id":"public/medias/featureimages/19.jpg","hash":"ec6e0a03fb1f482723fb3be891f6107e04431e26","modified":1617672272568},{"_id":"public/medias/featureimages/20.jpg","hash":"3b85e9a6c2b9603f78e98b894d93f73c3a7c3930","modified":1617672272568},{"_id":"public/medias/featureimages/5.jpg","hash":"c38712a0b122953432bd10850268e0b559a975d4","modified":1617672272568},{"_id":"public/medias/featureimages/11.jpg","hash":"69a08011a66b1c99326fb620d3cf40037339b4f4","modified":1617672272568},{"_id":"public/medias/featureimages/9.jpg","hash":"b956a2291a04b2132366b53666cf34858b8bdb1f","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff2","hash":"a46bd47ff0a90b812aafafda587d095cdb844271","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff2","hash":"9c081b88b106c6c04ecb895ba7ba7d3dcb3b55ac","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.woff","hash":"18838f5260317da3c5ed29bf844ac8a4f7ad0529","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-regular-400.svg","hash":"3d3a49445343d80f3b553e3e3425b9a7bd49acaf","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.woff","hash":"92803b8753ceda573c6906774677c5a7081d2fbb","modified":1617672272568},{"_id":"public/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1617672272568},{"_id":"public/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1617672272568},{"_id":"public/css/my.css","hash":"10577fbc30f241b126d1b51b1f56136ecba86b19","modified":1617672272568},{"_id":"public/js/search.js","hash":"f49c329e6b1f98a228426876356c945e8dce7e8e","modified":1617672272568},{"_id":"public/js/matery.js","hash":"b86de5fe3e9766b7ff80df12ea41c3a9e30825f7","modified":1617672272568},{"_id":"public/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1617672272568},{"_id":"public/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1617672272568},{"_id":"public/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1617672272568},{"_id":"public/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1617672272568},{"_id":"public/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1617672272568},{"_id":"public/libs/codeBlock/codeBlockFuction.js","hash":"c7ab06d27a525b15b1eb69027135269e9b9132fb","modified":1617672272568},{"_id":"public/libs/codeBlock/codeCopy.js","hash":"6d39a766af62e625f177c4d5cf3adc35eed71e61","modified":1617672272568},{"_id":"public/libs/codeBlock/codeShrink.js","hash":"201e8cd761b4be557247bdaf1ebc7c11c83194f6","modified":1617672272568},{"_id":"public/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1617672272568},{"_id":"public/libs/codeBlock/codeLang.js","hash":"bac88b4d4e3679732d29bd037c34f089cf27cf05","modified":1617672272568},{"_id":"public/libs/instantpage/instantpage.js","hash":"83ce8919b1a69b2f1809ffaf99b52a8627e650e9","modified":1617672272568},{"_id":"public/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1617672272568},{"_id":"public/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1617672272568},{"_id":"public/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1617672272568},{"_id":"public/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1617672272568},{"_id":"public/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1617672272568},{"_id":"public/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1617672272568},{"_id":"public/libs/tocbot/tocbot.css","hash":"9ab8ef576c9a57115194152e79cca79b0a41dd70","modified":1617672272568},{"_id":"public/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1617672272568},{"_id":"public/medias/cover.jpg","hash":"3c672af6b05588eda34fc0b07c0f24754713fbd9","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.eot","hash":"22f9e7d5226408eb2d0a11e118257a3ca22b8670","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.ttf","hash":"91cbeeaceb644a971241c08362898599d6d968ce","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.eot","hash":"cab8e84ae5682d1d556e234df9c790985888def8","modified":1617672272568},{"_id":"public/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1617672272568},{"_id":"public/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1617672272568},{"_id":"public/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1617672272568},{"_id":"public/libs/gitalk/gitalk.css","hash":"940ded3ea12c2fe1ab0820d2831ec405f3f1fe9f","modified":1617672272568},{"_id":"public/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1617672272568},{"_id":"public/libs/share/js/jquery.share.min.js","hash":"41367dcb857e02e3c417ebe68a554ce1d4430806","modified":1617672272568},{"_id":"public/libs/share/js/social-share.min.js","hash":"a3090a02786dcd4efc6355c1c1dc978add8d6827","modified":1617672272568},{"_id":"public/medias/banner/1.jpg","hash":"4a9a5203dc1c757849fc0c8655a04650332de4f6","modified":1617672272568},{"_id":"public/medias/featureimages/12.jpg","hash":"6c6d964c076c9beedcc57a238fc263810e34b841","modified":1617672272568},{"_id":"public/medias/featureimages/14.jpg","hash":"7ec0b8c6f4ffabe4c0c71face3b4a6964bc55c39","modified":1617672272568},{"_id":"public/css/matery.css","hash":"104b1b2582d2cd9321e4a9d529e6854f8bd91ff5","modified":1617672272568},{"_id":"public/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1617672272568},{"_id":"public/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1617672272568},{"_id":"public/medias/banner/6.jpg","hash":"0544de7906cae1d501bdb54da24cdebf526036a0","modified":1617672272568},{"_id":"public/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1617672272568},{"_id":"public/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1617672272568},{"_id":"public/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1617672272568},{"_id":"public/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1617672272568},{"_id":"public/libs/valine/Valine.min.js","hash":"3ce475b258ef198c9c885113eb784631932340df","modified":1617672272568},{"_id":"public/libs/awesome/css/all.css","hash":"ecc41e32ad2696877a1656749841f3b5543bbe3d","modified":1617672272568},{"_id":"public/libs/jquery/jquery.min.js","hash":"2115753ca5fb7032aec498db7bb5dca624dbe6be","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.ttf","hash":"9521ed12274c2cbc910cea77657116fcf6545da3","modified":1617672272568},{"_id":"public/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1617672272568},{"_id":"public/libs/materialize/materialize.min.css","hash":"a69d456e3345e7f59cd0d47d1b3e70fd4a496a05","modified":1617672272568},{"_id":"public/libs/valine/av-min.js","hash":"541efb9edc1ce425cbe3897cfc25803211fe6a05","modified":1617672272568},{"_id":"public/libs/gitalk/gitalk.min.js","hash":"8fefe38f28804f90116bdcb74a0875c9de9f3b7d","modified":1617672272568},{"_id":"public/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-brands-400.svg","hash":"5e2d2a159294576bea69cc3360efb5ffe110ab2d","modified":1617672272568},{"_id":"public/libs/awesome/webfonts/fa-solid-900.svg","hash":"7da88b19e1486f8c968d3cf5ab3f194f01ea17fd","modified":1617672272568},{"_id":"public/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1617672272568}],"Category":[{"name":"随笔","_id":"ckn5cb0cf0004ksup6iqvex7z"},{"name":"技术","_id":"ckn5cb0cp000rksup15ae138r"},{"name":"Git","_id":"ckn5cb0cu0013ksup31ao0hmc"},{"name":"Markdown","_id":"ckn5cb0d0001hksuphsep1dnv"},{"name":"致来访者","_id":"ckn5cb0ds002rksupf9npfb21"}],"Data":[],"Page":[{"title":"404","date":"2020-10-22T08:47:30.000Z","type":"404","layout":"404","description":"Oops～，我崩溃了！找不到你想要的页面 :(","_content":"","source":"404.md","raw":"---\ntitle: 404\ndate: 2020-10-22 16:47:30\ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，我崩溃了！找不到你想要的页面 :(\"\n---","updated":"2020-10-23T08:01:39.030Z","path":"404.html","comments":1,"_id":"ckn5cb0c50000ksup0t3j6g9k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2020-10-22T08:42:02.000Z","type":"about","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2020-10-22 16:42:02\ntype: \"about\"\nlayout: \"about\"\n---","updated":"2020-10-23T08:01:39.035Z","path":"about/index.html","comments":1,"_id":"ckn5cb0cc0002ksupe4n7enbb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"contact","date":"2020-10-22T08:44:33.000Z","type":"contact","layout":"contact","_content":"","source":"contact/index.md","raw":"---\ntitle: contact\ndate: 2020-10-22 16:44:33\ntype: \"contact\"\nlayout: \"contact\"\n---","updated":"2020-10-23T08:01:39.039Z","path":"contact/index.html","comments":1,"_id":"ckn5cb0cg0006ksupfbeuetw4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2020-10-22T08:35:24.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-10-22 16:35:24\ntype: \"categories\"\nlayout: \"categories\"\n---","updated":"2020-10-23T08:01:39.037Z","path":"categories/index.html","comments":1,"_id":"ckn5cb0ch0008ksup06v4he7q","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-10-22T08:41:08.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-10-22 16:41:08\ntype: \"tags\"\nlayout: \"tags\"\n---","updated":"2020-10-23T08:01:39.042Z","path":"tags/index.html","comments":1,"_id":"ckn5cb0ci000aksup7siqhkct","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2021-02-25博客","date":"2021-02-25T08:33:27.000Z","author":"heyXiao","summary":"不是技术相关所以想不出标题","_content":"\n<p style=\"text-indent:2em\">今天是2021-02-25，本周是2月份的最后一周。</p>\n<p style=\"text-indent:2em\">最近想买一个微单相机玩下，发现比耳机圈水深得多，很难买到靠谱的产品，天猫京东自营的话会贵一点，等到618再看一下。</p>\n<p style=\"text-indent:2em\">为什么想买相机呢，打算趁着春暖花开去南京玩下，拍一些风景，但是最近的天气似乎与春天无关。</p>\n<p style=\"text-indent:2em\">而且想和网友(女)面基一下，看下是否能成为朋友关系(正常朋友，总得先到这一步)。不过可能很忙吧，或者对我并不感兴趣的样子，约出来的可能性不大。</p>\n<p style=\"text-indent:2em\">所以只打算邀请一次。3.6/3.7好像会下雨，我不喜欢下雨。</p>\n<p style=\"text-indent:2em\">本周单休，可以做旅行计划了，苏康码的申请，酒店预订等等。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n<p style=\"text-indent:2em\">02-26晚上的约到明天了。不是太开心。</p>\n","source":"_posts/2021-02-25博客.md","raw":"---\ntitle: 2021-02-25博客\ndate: 2021-02-25 16:33:27\nauthor: heyXiao\nsummary: 不是技术相关所以想不出标题\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n\n<p style=\"text-indent:2em\">今天是2021-02-25，本周是2月份的最后一周。</p>\n<p style=\"text-indent:2em\">最近想买一个微单相机玩下，发现比耳机圈水深得多，很难买到靠谱的产品，天猫京东自营的话会贵一点，等到618再看一下。</p>\n<p style=\"text-indent:2em\">为什么想买相机呢，打算趁着春暖花开去南京玩下，拍一些风景，但是最近的天气似乎与春天无关。</p>\n<p style=\"text-indent:2em\">而且想和网友(女)面基一下，看下是否能成为朋友关系(正常朋友，总得先到这一步)。不过可能很忙吧，或者对我并不感兴趣的样子，约出来的可能性不大。</p>\n<p style=\"text-indent:2em\">所以只打算邀请一次。3.6/3.7好像会下雨，我不喜欢下雨。</p>\n<p style=\"text-indent:2em\">本周单休，可以做旅行计划了，苏康码的申请，酒店预订等等。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n<p style=\"text-indent:2em\">02-26晚上的约到明天了。不是太开心。</p>\n","slug":"2021-02-25博客","published":1,"updated":"2021-02-26T06:28:56.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0c80001ksuph2ejb99f","content":"<p style=\"text-indent:2em\">今天是2021-02-25，本周是2月份的最后一周。</p>\n<p style=\"text-indent:2em\">最近想买一个微单相机玩下，发现比耳机圈水深得多，很难买到靠谱的产品，天猫京东自营的话会贵一点，等到618再看一下。</p>\n<p style=\"text-indent:2em\">为什么想买相机呢，打算趁着春暖花开去南京玩下，拍一些风景，但是最近的天气似乎与春天无关。</p>\n<p style=\"text-indent:2em\">而且想和网友(女)面基一下，看下是否能成为朋友关系(正常朋友，总得先到这一步)。不过可能很忙吧，或者对我并不感兴趣的样子，约出来的可能性不大。</p>\n<p style=\"text-indent:2em\">所以只打算邀请一次。3.6/3.7好像会下雨，我不喜欢下雨。</p>\n<p style=\"text-indent:2em\">本周单休，可以做旅行计划了，苏康码的申请，酒店预订等等。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n<p style=\"text-indent:2em\">02-26晚上的约到明天了。不是太开心。</p>\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-indent:2em\">今天是2021-02-25，本周是2月份的最后一周。</p>\n<p style=\"text-indent:2em\">最近想买一个微单相机玩下，发现比耳机圈水深得多，很难买到靠谱的产品，天猫京东自营的话会贵一点，等到618再看一下。</p>\n<p style=\"text-indent:2em\">为什么想买相机呢，打算趁着春暖花开去南京玩下，拍一些风景，但是最近的天气似乎与春天无关。</p>\n<p style=\"text-indent:2em\">而且想和网友(女)面基一下，看下是否能成为朋友关系(正常朋友，总得先到这一步)。不过可能很忙吧，或者对我并不感兴趣的样子，约出来的可能性不大。</p>\n<p style=\"text-indent:2em\">所以只打算邀请一次。3.6/3.7好像会下雨，我不喜欢下雨。</p>\n<p style=\"text-indent:2em\">本周单休，可以做旅行计划了，苏康码的申请，酒店预订等等。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n<p style=\"text-indent:2em\">02-26晚上的约到明天了。不是太开心。</p>\n"},{"title":"2021-03-02博客","date":"2021-03-02T09:15:33.000Z","author":"heyXiao","summary":"电脑宕机","_content":"\n<p style=\"text-indent:2em\">今天是2021-03-02，本周应按计划前往南京，但是现在有些犹豫。</p>\n<p style=\"text-indent:2em\">上周电脑宕机，第一次重装系统盘，很多软件的配置都没了，不太适应。大概跟搬家一个意思，虽然我没搬家过。</p>\n<p style=\"text-indent:2em\">跟 FY 要了他在南京的地址，可以申请苏康码了。买了一些伴手礼零食，不知道谁会吃到。</p>\n<p style=\"text-indent:2em\">周四尝试一下，当天晚上着手旅行计划与门票预约。</p>\n<p style=\"text-indent:2em\">今天周三，博客加密也没用啊- -。</p>\n<p style=\"text-indent:2em\">今天周四，上午尝试了，但现在还没确切的答复吧，如果没戏的话应该会周末再去，毕竟本周要加班。</p>\n<p style=\"text-indent:2em\">今天周五，昨天回复不太理想，不过今天也请周六假了，就好好玩一下吧。不要忘了请 FY 吃饭，想去蓝蛙。</p>\n<p style=\"text-indent:2em\">今天是2021-03-08，周末面基成功，希望现在至少是朋友，不过她真的很忙。我早就应该开始职业规划了，现在开始为时不晚。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n","source":"_posts/2021-03-02博客.md","raw":"---\ntitle: 2021-03-02博客\ndate: 2021-03-02 17:15:33\nauthor: heyXiao\nsummary: 电脑宕机\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n\n<p style=\"text-indent:2em\">今天是2021-03-02，本周应按计划前往南京，但是现在有些犹豫。</p>\n<p style=\"text-indent:2em\">上周电脑宕机，第一次重装系统盘，很多软件的配置都没了，不太适应。大概跟搬家一个意思，虽然我没搬家过。</p>\n<p style=\"text-indent:2em\">跟 FY 要了他在南京的地址，可以申请苏康码了。买了一些伴手礼零食，不知道谁会吃到。</p>\n<p style=\"text-indent:2em\">周四尝试一下，当天晚上着手旅行计划与门票预约。</p>\n<p style=\"text-indent:2em\">今天周三，博客加密也没用啊- -。</p>\n<p style=\"text-indent:2em\">今天周四，上午尝试了，但现在还没确切的答复吧，如果没戏的话应该会周末再去，毕竟本周要加班。</p>\n<p style=\"text-indent:2em\">今天周五，昨天回复不太理想，不过今天也请周六假了，就好好玩一下吧。不要忘了请 FY 吃饭，想去蓝蛙。</p>\n<p style=\"text-indent:2em\">今天是2021-03-08，周末面基成功，希望现在至少是朋友，不过她真的很忙。我早就应该开始职业规划了，现在开始为时不晚。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n","slug":"2021-03-02博客","published":1,"updated":"2021-03-08T09:15:10.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cd0003ksup23nq8bcs","content":"<p style=\"text-indent:2em\">今天是2021-03-02，本周应按计划前往南京，但是现在有些犹豫。</p>\n<p style=\"text-indent:2em\">上周电脑宕机，第一次重装系统盘，很多软件的配置都没了，不太适应。大概跟搬家一个意思，虽然我没搬家过。</p>\n<p style=\"text-indent:2em\">跟 FY 要了他在南京的地址，可以申请苏康码了。买了一些伴手礼零食，不知道谁会吃到。</p>\n<p style=\"text-indent:2em\">周四尝试一下，当天晚上着手旅行计划与门票预约。</p>\n<p style=\"text-indent:2em\">今天周三，博客加密也没用啊- -。</p>\n<p style=\"text-indent:2em\">今天周四，上午尝试了，但现在还没确切的答复吧，如果没戏的话应该会周末再去，毕竟本周要加班。</p>\n<p style=\"text-indent:2em\">今天周五，昨天回复不太理想，不过今天也请周六假了，就好好玩一下吧。不要忘了请 FY 吃饭，想去蓝蛙。</p>\n<p style=\"text-indent:2em\">今天是2021-03-08，周末面基成功，希望现在至少是朋友，不过她真的很忙。我早就应该开始职业规划了，现在开始为时不晚。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-indent:2em\">今天是2021-03-02，本周应按计划前往南京，但是现在有些犹豫。</p>\n<p style=\"text-indent:2em\">上周电脑宕机，第一次重装系统盘，很多软件的配置都没了，不太适应。大概跟搬家一个意思，虽然我没搬家过。</p>\n<p style=\"text-indent:2em\">跟 FY 要了他在南京的地址，可以申请苏康码了。买了一些伴手礼零食，不知道谁会吃到。</p>\n<p style=\"text-indent:2em\">周四尝试一下，当天晚上着手旅行计划与门票预约。</p>\n<p style=\"text-indent:2em\">今天周三，博客加密也没用啊- -。</p>\n<p style=\"text-indent:2em\">今天周四，上午尝试了，但现在还没确切的答复吧，如果没戏的话应该会周末再去，毕竟本周要加班。</p>\n<p style=\"text-indent:2em\">今天周五，昨天回复不太理想，不过今天也请周六假了，就好好玩一下吧。不要忘了请 FY 吃饭，想去蓝蛙。</p>\n<p style=\"text-indent:2em\">今天是2021-03-08，周末面基成功，希望现在至少是朋友，不过她真的很忙。我早就应该开始职业规划了，现在开始为时不晚。</p>\n<p style=\"text-indent:2em\">要自信，要勇敢尝试，要满足自己，要尊重他人。</p>\n"},{"title":"2021-03-09博客","date":"2021-03-09T06:03:01.000Z","author":"heyXiao","summary":"下一篇博客绝对是技术相关，You have my word.","_content":"\n<p style=\"text-indent:2em\">今天是2021-03-09，看了一下体重统计，大约10天瘦1kg，现在69kg，所以大约3个月减到60kg，留些富余量，在七夕左右（08-14）。</p>\n<p style=\"text-indent:2em\">今天项目提交测试了，回复明天开始测试。所以，今天可以写博客了。</p>\n<p style=\"text-indent:2em\">有一件事忘了说：要时刻注意完善自己的简历。</p>\n<p style=\"text-indent:2em\">今天是2021-03-11，最近两天在看 TypeScript 文档和面试题，差距和大厂要求有点大啊，学历硬伤，我现在已经到了一个只至关重要的人生节点。</p>\n<p style=\"text-indent:2em\"></p>\n\n","source":"_posts/2021-03-09博客.md","raw":"---\ntitle: 2021-03-09博客\ndate: 2021-03-09 14:03:01\nauthor: heyXiao\nsummary: 下一篇博客绝对是技术相关，You have my word.\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n\n<p style=\"text-indent:2em\">今天是2021-03-09，看了一下体重统计，大约10天瘦1kg，现在69kg，所以大约3个月减到60kg，留些富余量，在七夕左右（08-14）。</p>\n<p style=\"text-indent:2em\">今天项目提交测试了，回复明天开始测试。所以，今天可以写博客了。</p>\n<p style=\"text-indent:2em\">有一件事忘了说：要时刻注意完善自己的简历。</p>\n<p style=\"text-indent:2em\">今天是2021-03-11，最近两天在看 TypeScript 文档和面试题，差距和大厂要求有点大啊，学历硬伤，我现在已经到了一个只至关重要的人生节点。</p>\n<p style=\"text-indent:2em\"></p>\n\n","slug":"2021-03-09博客","published":1,"updated":"2021-03-11T09:11:23.746Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0ch0007ksup6mvha8d4","content":"<p style=\"text-indent:2em\">今天是2021-03-09，看了一下体重统计，大约10天瘦1kg，现在69kg，所以大约3个月减到60kg，留些富余量，在七夕左右（08-14）。</p>\n<p style=\"text-indent:2em\">今天项目提交测试了，回复明天开始测试。所以，今天可以写博客了。</p>\n<p style=\"text-indent:2em\">有一件事忘了说：要时刻注意完善自己的简历。</p>\n<p style=\"text-indent:2em\">今天是2021-03-11，最近两天在看 TypeScript 文档和面试题，差距和大厂要求有点大啊，学历硬伤，我现在已经到了一个只至关重要的人生节点。</p>\n<p style=\"text-indent:2em\"></p>\n\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-indent:2em\">今天是2021-03-09，看了一下体重统计，大约10天瘦1kg，现在69kg，所以大约3个月减到60kg，留些富余量，在七夕左右（08-14）。</p>\n<p style=\"text-indent:2em\">今天项目提交测试了，回复明天开始测试。所以，今天可以写博客了。</p>\n<p style=\"text-indent:2em\">有一件事忘了说：要时刻注意完善自己的简历。</p>\n<p style=\"text-indent:2em\">今天是2021-03-11，最近两天在看 TypeScript 文档和面试题，差距和大厂要求有点大啊，学历硬伤，我现在已经到了一个只至关重要的人生节点。</p>\n<p style=\"text-indent:2em\"></p>\n\n"},{"title":"2021-03-17博客","date":"2021-03-17T05:27:57.000Z","author":"heyXiao","summary":"似乎可以一篇个人，一篇技术？","_content":"\n### 今天是2021-03-17\n<p style=\"text-indent:2em\">最近还是比较忙的。不过明显感觉到项目变少了，现在似乎还是淡季？不好跳槽啊。</p>\n<p style=\"text-indent:2em\">南京的花都开了，我很想去看，但不想只是为了她。如果没有邀请，我是不会去的。</p>\n<p style=\"text-indent:2em\">我希望有一段美好生活的开始，但是我也不会一直专注于此。</p>\n<p style=\"text-indent:2em\">其实我有时候挺爱念叨点什么的，像前些日子的 I'm a god damn warrior .到现在的 I'm good at killing time / satisfying me . 我很多时候都不知道这些句子是怎么来的。</p>\n<p style=\"text-indent:2em\">今晚体验反曲弓射箭，我不想只会 Coding 和玩游戏。</p>\n\n### 今天是2021-03-18\n<p style=\"text-indent:2em\">昨晚体验良好，但是吃了炸鸡有点罪恶。今天来到公司一堆修改，截止到不久之前心情很不爽。在考虑加大锻炼强度，运动时有感觉，但是之后肌肉不酸痛，是适应性提高了吗，还是没锻炼到位强度不够？周末想去上海的耳机展览会。</p>\n\n### 今天是2021-03-19\n<p style=\"text-indent:2em\">似乎可以闲一下。下午考虑写一篇总结，但愿没有拖延症。 晚上去看电影，感觉应该在水准之上。</p>\n<p style=\"text-indent:2em\">下午暂时没有写，把博客备份到了 Gitee，国内速度就是快。</p>\n\n### 今天是2021-03-22\n<p style=\"text-indent:2em\">昨晚第一次做 HIIT，有点费劲，现在身体还有酸痛。第一天椭圆机+练胸，第二天HIIT+练腹，不知道合不合理，身体能不能受得了。</p>\n<p style=\"text-indent:2em\">还有，从V友那收的尼康 D5300 上手使用了，感觉还可以，入门应该足够了，只不过周六下雨，周末不想出去。可能要到清明节闲逛的时候才能排上用场。</p>\n<p style=\"text-indent:2em\">近期新爱好：逛 github.io~~</p>\n\n### 今天是2021-03-23\n<p style=\"text-indent:2em\">从上周开始就没有太多事情了，看一下 TypeScript 、Vue3 文档，偶尔修改一下问题，然后就是划水。所以这几天大概有很多时间写博客？或许也可以看看面试题。</p>\n<p style=\"text-indent:2em\">还有一件事提上日程，打算清明节去长沙或者苏州玩。倾向苏州，可是我又比较想念长沙。而且我打算邀请她，但是不影响我的行程。</p>\n\n### 今天是2021-03-24\n<p style=\"text-indent:2em\">昨晚决定了去苏州，车票也买好了，长沙端午节（06.12-06.14）去吧。周六晚理发，周末早晨去射箭，然后下周末早晨出发，又可以规划行程了，开心。那么今天写一篇总结？哈哈哈哈哈</p>\n\n### 今天是2021-03-25\n<p style=\"text-indent:2em\">开始忙了起来啊。今晚射箭，周五晚理发，周末休息。今天定了苏州的酒店，好贵！昨天聊天的时候邀请了一下，是真的很忙啊....反正不太明朗吧，老悲观主义者了哈哈哈哈哈</p>\n\n### 今天是2021-03-26\n<p style=\"text-indent:2em\">今天也忙啊...到下周二，明天也要上班。今天腿酸但不痛，有点抗拒晚上的椭圆机了哈哈哈。啊真的想出去玩了，不和她一起也可以了。</p>\n<p style=\"text-indent:2em\">听了很多李志的歌，i/O unplugged 动静，都很棒。</p>\n\n### 今天是2021-03-27\n<p style=\"text-indent:2em\">上班，心情不太好。最近减肥似乎到了瓶颈期，大概是牛肉干吃的有点多，卡路里超标了，需要严格控制饮食。不过我还有几张霸王鸡盒和皇堡的券啊- -。</p>\n<p style=\"text-indent:2em\">昨天吃了 HXD 的一个瓜，心情复杂。虽然我不太在乎。</p>\n\n### 今天是2021-03-31\n<p style=\"text-indent:2em\">本周很忙，很多项目的改动，让人心烦意乱。饮食上可能不太均衡，让我最近脾气也不太好。我不想主动去接触了，太没劲了，爱咋咋吧。</p>\n<p style=\"text-indent:2em\">晚上做下行程攻略，老实两天周末去玩了。我不在乎。</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n\n<p style=\"text-indent:2em\"></p>\n\n","source":"_posts/2021-03-17博客.md","raw":"---\ntitle: 2021-03-17博客\ndate: 2021-03-17 13:27:57\nauthor: heyXiao\nsummary: 似乎可以一篇个人，一篇技术？\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n\n### 今天是2021-03-17\n<p style=\"text-indent:2em\">最近还是比较忙的。不过明显感觉到项目变少了，现在似乎还是淡季？不好跳槽啊。</p>\n<p style=\"text-indent:2em\">南京的花都开了，我很想去看，但不想只是为了她。如果没有邀请，我是不会去的。</p>\n<p style=\"text-indent:2em\">我希望有一段美好生活的开始，但是我也不会一直专注于此。</p>\n<p style=\"text-indent:2em\">其实我有时候挺爱念叨点什么的，像前些日子的 I'm a god damn warrior .到现在的 I'm good at killing time / satisfying me . 我很多时候都不知道这些句子是怎么来的。</p>\n<p style=\"text-indent:2em\">今晚体验反曲弓射箭，我不想只会 Coding 和玩游戏。</p>\n\n### 今天是2021-03-18\n<p style=\"text-indent:2em\">昨晚体验良好，但是吃了炸鸡有点罪恶。今天来到公司一堆修改，截止到不久之前心情很不爽。在考虑加大锻炼强度，运动时有感觉，但是之后肌肉不酸痛，是适应性提高了吗，还是没锻炼到位强度不够？周末想去上海的耳机展览会。</p>\n\n### 今天是2021-03-19\n<p style=\"text-indent:2em\">似乎可以闲一下。下午考虑写一篇总结，但愿没有拖延症。 晚上去看电影，感觉应该在水准之上。</p>\n<p style=\"text-indent:2em\">下午暂时没有写，把博客备份到了 Gitee，国内速度就是快。</p>\n\n### 今天是2021-03-22\n<p style=\"text-indent:2em\">昨晚第一次做 HIIT，有点费劲，现在身体还有酸痛。第一天椭圆机+练胸，第二天HIIT+练腹，不知道合不合理，身体能不能受得了。</p>\n<p style=\"text-indent:2em\">还有，从V友那收的尼康 D5300 上手使用了，感觉还可以，入门应该足够了，只不过周六下雨，周末不想出去。可能要到清明节闲逛的时候才能排上用场。</p>\n<p style=\"text-indent:2em\">近期新爱好：逛 github.io~~</p>\n\n### 今天是2021-03-23\n<p style=\"text-indent:2em\">从上周开始就没有太多事情了，看一下 TypeScript 、Vue3 文档，偶尔修改一下问题，然后就是划水。所以这几天大概有很多时间写博客？或许也可以看看面试题。</p>\n<p style=\"text-indent:2em\">还有一件事提上日程，打算清明节去长沙或者苏州玩。倾向苏州，可是我又比较想念长沙。而且我打算邀请她，但是不影响我的行程。</p>\n\n### 今天是2021-03-24\n<p style=\"text-indent:2em\">昨晚决定了去苏州，车票也买好了，长沙端午节（06.12-06.14）去吧。周六晚理发，周末早晨去射箭，然后下周末早晨出发，又可以规划行程了，开心。那么今天写一篇总结？哈哈哈哈哈</p>\n\n### 今天是2021-03-25\n<p style=\"text-indent:2em\">开始忙了起来啊。今晚射箭，周五晚理发，周末休息。今天定了苏州的酒店，好贵！昨天聊天的时候邀请了一下，是真的很忙啊....反正不太明朗吧，老悲观主义者了哈哈哈哈哈</p>\n\n### 今天是2021-03-26\n<p style=\"text-indent:2em\">今天也忙啊...到下周二，明天也要上班。今天腿酸但不痛，有点抗拒晚上的椭圆机了哈哈哈。啊真的想出去玩了，不和她一起也可以了。</p>\n<p style=\"text-indent:2em\">听了很多李志的歌，i/O unplugged 动静，都很棒。</p>\n\n### 今天是2021-03-27\n<p style=\"text-indent:2em\">上班，心情不太好。最近减肥似乎到了瓶颈期，大概是牛肉干吃的有点多，卡路里超标了，需要严格控制饮食。不过我还有几张霸王鸡盒和皇堡的券啊- -。</p>\n<p style=\"text-indent:2em\">昨天吃了 HXD 的一个瓜，心情复杂。虽然我不太在乎。</p>\n\n### 今天是2021-03-31\n<p style=\"text-indent:2em\">本周很忙，很多项目的改动，让人心烦意乱。饮食上可能不太均衡，让我最近脾气也不太好。我不想主动去接触了，太没劲了，爱咋咋吧。</p>\n<p style=\"text-indent:2em\">晚上做下行程攻略，老实两天周末去玩了。我不在乎。</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n\n<p style=\"text-indent:2em\"></p>\n\n","slug":"2021-03-17博客","published":1,"updated":"2021-03-31T03:56:11.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0ci0009ksup6us9e2rl","content":"<h3 id=\"今天是2021-03-17\"><a href=\"#今天是2021-03-17\" class=\"headerlink\" title=\"今天是2021-03-17\"></a>今天是2021-03-17</h3><p style=\"text-indent:2em\">最近还是比较忙的。不过明显感觉到项目变少了，现在似乎还是淡季？不好跳槽啊。</p>\n<p style=\"text-indent:2em\">南京的花都开了，我很想去看，但不想只是为了她。如果没有邀请，我是不会去的。</p>\n<p style=\"text-indent:2em\">我希望有一段美好生活的开始，但是我也不会一直专注于此。</p>\n<p style=\"text-indent:2em\">其实我有时候挺爱念叨点什么的，像前些日子的 I'm a god damn warrior .到现在的 I'm good at killing time / satisfying me . 我很多时候都不知道这些句子是怎么来的。</p>\n<p style=\"text-indent:2em\">今晚体验反曲弓射箭，我不想只会 Coding 和玩游戏。</p>\n\n<h3 id=\"今天是2021-03-18\"><a href=\"#今天是2021-03-18\" class=\"headerlink\" title=\"今天是2021-03-18\"></a>今天是2021-03-18</h3><p style=\"text-indent:2em\">昨晚体验良好，但是吃了炸鸡有点罪恶。今天来到公司一堆修改，截止到不久之前心情很不爽。在考虑加大锻炼强度，运动时有感觉，但是之后肌肉不酸痛，是适应性提高了吗，还是没锻炼到位强度不够？周末想去上海的耳机展览会。</p>\n\n<h3 id=\"今天是2021-03-19\"><a href=\"#今天是2021-03-19\" class=\"headerlink\" title=\"今天是2021-03-19\"></a>今天是2021-03-19</h3><p style=\"text-indent:2em\">似乎可以闲一下。下午考虑写一篇总结，但愿没有拖延症。 晚上去看电影，感觉应该在水准之上。</p>\n<p style=\"text-indent:2em\">下午暂时没有写，把博客备份到了 Gitee，国内速度就是快。</p>\n\n<h3 id=\"今天是2021-03-22\"><a href=\"#今天是2021-03-22\" class=\"headerlink\" title=\"今天是2021-03-22\"></a>今天是2021-03-22</h3><p style=\"text-indent:2em\">昨晚第一次做 HIIT，有点费劲，现在身体还有酸痛。第一天椭圆机+练胸，第二天HIIT+练腹，不知道合不合理，身体能不能受得了。</p>\n<p style=\"text-indent:2em\">还有，从V友那收的尼康 D5300 上手使用了，感觉还可以，入门应该足够了，只不过周六下雨，周末不想出去。可能要到清明节闲逛的时候才能排上用场。</p>\n<p style=\"text-indent:2em\">近期新爱好：逛 github.io~~</p>\n\n<h3 id=\"今天是2021-03-23\"><a href=\"#今天是2021-03-23\" class=\"headerlink\" title=\"今天是2021-03-23\"></a>今天是2021-03-23</h3><p style=\"text-indent:2em\">从上周开始就没有太多事情了，看一下 TypeScript 、Vue3 文档，偶尔修改一下问题，然后就是划水。所以这几天大概有很多时间写博客？或许也可以看看面试题。</p>\n<p style=\"text-indent:2em\">还有一件事提上日程，打算清明节去长沙或者苏州玩。倾向苏州，可是我又比较想念长沙。而且我打算邀请她，但是不影响我的行程。</p>\n\n<h3 id=\"今天是2021-03-24\"><a href=\"#今天是2021-03-24\" class=\"headerlink\" title=\"今天是2021-03-24\"></a>今天是2021-03-24</h3><p style=\"text-indent:2em\">昨晚决定了去苏州，车票也买好了，长沙端午节（06.12-06.14）去吧。周六晚理发，周末早晨去射箭，然后下周末早晨出发，又可以规划行程了，开心。那么今天写一篇总结？哈哈哈哈哈</p>\n\n<h3 id=\"今天是2021-03-25\"><a href=\"#今天是2021-03-25\" class=\"headerlink\" title=\"今天是2021-03-25\"></a>今天是2021-03-25</h3><p style=\"text-indent:2em\">开始忙了起来啊。今晚射箭，周五晚理发，周末休息。今天定了苏州的酒店，好贵！昨天聊天的时候邀请了一下，是真的很忙啊....反正不太明朗吧，老悲观主义者了哈哈哈哈哈</p>\n\n<h3 id=\"今天是2021-03-26\"><a href=\"#今天是2021-03-26\" class=\"headerlink\" title=\"今天是2021-03-26\"></a>今天是2021-03-26</h3><p style=\"text-indent:2em\">今天也忙啊...到下周二，明天也要上班。今天腿酸但不痛，有点抗拒晚上的椭圆机了哈哈哈。啊真的想出去玩了，不和她一起也可以了。</p>\n<p style=\"text-indent:2em\">听了很多李志的歌，i/O unplugged 动静，都很棒。</p>\n\n<h3 id=\"今天是2021-03-27\"><a href=\"#今天是2021-03-27\" class=\"headerlink\" title=\"今天是2021-03-27\"></a>今天是2021-03-27</h3><p style=\"text-indent:2em\">上班，心情不太好。最近减肥似乎到了瓶颈期，大概是牛肉干吃的有点多，卡路里超标了，需要严格控制饮食。不过我还有几张霸王鸡盒和皇堡的券啊- -。</p>\n<p style=\"text-indent:2em\">昨天吃了 HXD 的一个瓜，心情复杂。虽然我不太在乎。</p>\n\n<h3 id=\"今天是2021-03-31\"><a href=\"#今天是2021-03-31\" class=\"headerlink\" title=\"今天是2021-03-31\"></a>今天是2021-03-31</h3><p style=\"text-indent:2em\">本周很忙，很多项目的改动，让人心烦意乱。饮食上可能不太均衡，让我最近脾气也不太好。我不想主动去接触了，太没劲了，爱咋咋吧。</p>\n<p style=\"text-indent:2em\">晚上做下行程攻略，老实两天周末去玩了。我不在乎。</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n\n<p style=\"text-indent:2em\"></p>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"今天是2021-03-17\"><a href=\"#今天是2021-03-17\" class=\"headerlink\" title=\"今天是2021-03-17\"></a>今天是2021-03-17</h3><p style=\"text-indent:2em\">最近还是比较忙的。不过明显感觉到项目变少了，现在似乎还是淡季？不好跳槽啊。</p>\n<p style=\"text-indent:2em\">南京的花都开了，我很想去看，但不想只是为了她。如果没有邀请，我是不会去的。</p>\n<p style=\"text-indent:2em\">我希望有一段美好生活的开始，但是我也不会一直专注于此。</p>\n<p style=\"text-indent:2em\">其实我有时候挺爱念叨点什么的，像前些日子的 I'm a god damn warrior .到现在的 I'm good at killing time / satisfying me . 我很多时候都不知道这些句子是怎么来的。</p>\n<p style=\"text-indent:2em\">今晚体验反曲弓射箭，我不想只会 Coding 和玩游戏。</p>\n\n<h3 id=\"今天是2021-03-18\"><a href=\"#今天是2021-03-18\" class=\"headerlink\" title=\"今天是2021-03-18\"></a>今天是2021-03-18</h3><p style=\"text-indent:2em\">昨晚体验良好，但是吃了炸鸡有点罪恶。今天来到公司一堆修改，截止到不久之前心情很不爽。在考虑加大锻炼强度，运动时有感觉，但是之后肌肉不酸痛，是适应性提高了吗，还是没锻炼到位强度不够？周末想去上海的耳机展览会。</p>\n\n<h3 id=\"今天是2021-03-19\"><a href=\"#今天是2021-03-19\" class=\"headerlink\" title=\"今天是2021-03-19\"></a>今天是2021-03-19</h3><p style=\"text-indent:2em\">似乎可以闲一下。下午考虑写一篇总结，但愿没有拖延症。 晚上去看电影，感觉应该在水准之上。</p>\n<p style=\"text-indent:2em\">下午暂时没有写，把博客备份到了 Gitee，国内速度就是快。</p>\n\n<h3 id=\"今天是2021-03-22\"><a href=\"#今天是2021-03-22\" class=\"headerlink\" title=\"今天是2021-03-22\"></a>今天是2021-03-22</h3><p style=\"text-indent:2em\">昨晚第一次做 HIIT，有点费劲，现在身体还有酸痛。第一天椭圆机+练胸，第二天HIIT+练腹，不知道合不合理，身体能不能受得了。</p>\n<p style=\"text-indent:2em\">还有，从V友那收的尼康 D5300 上手使用了，感觉还可以，入门应该足够了，只不过周六下雨，周末不想出去。可能要到清明节闲逛的时候才能排上用场。</p>\n<p style=\"text-indent:2em\">近期新爱好：逛 github.io~~</p>\n\n<h3 id=\"今天是2021-03-23\"><a href=\"#今天是2021-03-23\" class=\"headerlink\" title=\"今天是2021-03-23\"></a>今天是2021-03-23</h3><p style=\"text-indent:2em\">从上周开始就没有太多事情了，看一下 TypeScript 、Vue3 文档，偶尔修改一下问题，然后就是划水。所以这几天大概有很多时间写博客？或许也可以看看面试题。</p>\n<p style=\"text-indent:2em\">还有一件事提上日程，打算清明节去长沙或者苏州玩。倾向苏州，可是我又比较想念长沙。而且我打算邀请她，但是不影响我的行程。</p>\n\n<h3 id=\"今天是2021-03-24\"><a href=\"#今天是2021-03-24\" class=\"headerlink\" title=\"今天是2021-03-24\"></a>今天是2021-03-24</h3><p style=\"text-indent:2em\">昨晚决定了去苏州，车票也买好了，长沙端午节（06.12-06.14）去吧。周六晚理发，周末早晨去射箭，然后下周末早晨出发，又可以规划行程了，开心。那么今天写一篇总结？哈哈哈哈哈</p>\n\n<h3 id=\"今天是2021-03-25\"><a href=\"#今天是2021-03-25\" class=\"headerlink\" title=\"今天是2021-03-25\"></a>今天是2021-03-25</h3><p style=\"text-indent:2em\">开始忙了起来啊。今晚射箭，周五晚理发，周末休息。今天定了苏州的酒店，好贵！昨天聊天的时候邀请了一下，是真的很忙啊....反正不太明朗吧，老悲观主义者了哈哈哈哈哈</p>\n\n<h3 id=\"今天是2021-03-26\"><a href=\"#今天是2021-03-26\" class=\"headerlink\" title=\"今天是2021-03-26\"></a>今天是2021-03-26</h3><p style=\"text-indent:2em\">今天也忙啊...到下周二，明天也要上班。今天腿酸但不痛，有点抗拒晚上的椭圆机了哈哈哈。啊真的想出去玩了，不和她一起也可以了。</p>\n<p style=\"text-indent:2em\">听了很多李志的歌，i/O unplugged 动静，都很棒。</p>\n\n<h3 id=\"今天是2021-03-27\"><a href=\"#今天是2021-03-27\" class=\"headerlink\" title=\"今天是2021-03-27\"></a>今天是2021-03-27</h3><p style=\"text-indent:2em\">上班，心情不太好。最近减肥似乎到了瓶颈期，大概是牛肉干吃的有点多，卡路里超标了，需要严格控制饮食。不过我还有几张霸王鸡盒和皇堡的券啊- -。</p>\n<p style=\"text-indent:2em\">昨天吃了 HXD 的一个瓜，心情复杂。虽然我不太在乎。</p>\n\n<h3 id=\"今天是2021-03-31\"><a href=\"#今天是2021-03-31\" class=\"headerlink\" title=\"今天是2021-03-31\"></a>今天是2021-03-31</h3><p style=\"text-indent:2em\">本周很忙，很多项目的改动，让人心烦意乱。饮食上可能不太均衡，让我最近脾气也不太好。我不想主动去接触了，太没劲了，爱咋咋吧。</p>\n<p style=\"text-indent:2em\">晚上做下行程攻略，老实两天周末去玩了。我不在乎。</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n\n<p style=\"text-indent:2em\"></p>\n\n"},{"title":"2021-04-01博客","date":"2021-04-17T02:12:33.000Z","author":"heyXiao","summary":"本月Log","_content":"\n### 今天是2021-04-01\n<p style=\"text-indent:2em\">看样子本周忙完了？昨天晚上没有做攻略，今天可不能忘了。</p>\n<p style=\"text-indent:2em\">啊心情不佳的一周快要过去了，就让我安安静静的放假出去玩吧，无所谓天气了，我现在只想闲逛。</p>\n<p style=\"text-indent:2em\">三月写了六篇总结啊，我想保持每周一篇博客，只要不断更就是好事。</p>\n<p style=\"text-indent:2em\">我现在越来越痛恨自己了。她不是我本周坏心情的源头，求而不得才是。我偏激、故作姿态、附庸风雅，我首先是充满敌意。无聊无趣，但我爱我自己。</p>\n\n### 今天是2021-04-02\n<p style=\"text-indent:2em\">我犯了一个错误。我知道去博物馆需要预约，但是我为什么就不能多提前几天啊？苏州博物馆现在好像不允许无预约排队进入了，看来只能04-17周末补了，不过还是要去看下能否排队。或许能抢到退票也说不定。</p>\n<p style=\"text-indent:2em\">现在是16：28，现在人有点昏昏的，不想写代码了。晚上大概很忙，要理发，大约7点完成，然后7.30左右出发去之心城，逛一下小米之家，看看有没有手环。之后吃点东西，大概是汉堡王？晚上回来要椭圆机锻炼，洗澡，收拾行李，检查一下预订的房间需不需要更改。</p>\n<p style=\"text-indent:2em\">3月消费有点高哦，要注意控制。</p>\n<p style=\"text-indent:2em\">一个心理特征:我得不到所以在意，我在意得不到所以憎恶。</p>\n\n### 今天是2021-04-06\n<p style=\"text-indent:2em\">去苏州逛了一下，总体感觉还不错，景区周边规划的很好。园林风景也好，就是假日人有点多。为了市容不允许投放共享单车，出行就不那么方便。</p>\n<p style=\"text-indent:2em\">虎丘很推荐，早起去逛的话，空气清新人又少。寒山寺不行。哑巴生煎很好吃，不会太甜。</p>\n<p style=\"text-indent:2em\">拙政园很大，留园小一点，这两个地方都推荐，工作日来可能体验好一点。狮子林相形见绌。</p>\n<p style=\"text-indent:2em\">几天没长胖，反而瘦了2kg左右？困惑</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n<p style=\"text-indent:2em\"></p>\n\n","source":"_posts/2021-04-01博客.md","raw":"---\ntitle: 2021-04-01博客\ndate: 2021-04-17 10:12:33\nauthor: heyXiao\nsummary: 本月Log\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n\n### 今天是2021-04-01\n<p style=\"text-indent:2em\">看样子本周忙完了？昨天晚上没有做攻略，今天可不能忘了。</p>\n<p style=\"text-indent:2em\">啊心情不佳的一周快要过去了，就让我安安静静的放假出去玩吧，无所谓天气了，我现在只想闲逛。</p>\n<p style=\"text-indent:2em\">三月写了六篇总结啊，我想保持每周一篇博客，只要不断更就是好事。</p>\n<p style=\"text-indent:2em\">我现在越来越痛恨自己了。她不是我本周坏心情的源头，求而不得才是。我偏激、故作姿态、附庸风雅，我首先是充满敌意。无聊无趣，但我爱我自己。</p>\n\n### 今天是2021-04-02\n<p style=\"text-indent:2em\">我犯了一个错误。我知道去博物馆需要预约，但是我为什么就不能多提前几天啊？苏州博物馆现在好像不允许无预约排队进入了，看来只能04-17周末补了，不过还是要去看下能否排队。或许能抢到退票也说不定。</p>\n<p style=\"text-indent:2em\">现在是16：28，现在人有点昏昏的，不想写代码了。晚上大概很忙，要理发，大约7点完成，然后7.30左右出发去之心城，逛一下小米之家，看看有没有手环。之后吃点东西，大概是汉堡王？晚上回来要椭圆机锻炼，洗澡，收拾行李，检查一下预订的房间需不需要更改。</p>\n<p style=\"text-indent:2em\">3月消费有点高哦，要注意控制。</p>\n<p style=\"text-indent:2em\">一个心理特征:我得不到所以在意，我在意得不到所以憎恶。</p>\n\n### 今天是2021-04-06\n<p style=\"text-indent:2em\">去苏州逛了一下，总体感觉还不错，景区周边规划的很好。园林风景也好，就是假日人有点多。为了市容不允许投放共享单车，出行就不那么方便。</p>\n<p style=\"text-indent:2em\">虎丘很推荐，早起去逛的话，空气清新人又少。寒山寺不行。哑巴生煎很好吃，不会太甜。</p>\n<p style=\"text-indent:2em\">拙政园很大，留园小一点，这两个地方都推荐，工作日来可能体验好一点。狮子林相形见绌。</p>\n<p style=\"text-indent:2em\">几天没长胖，反而瘦了2kg左右？困惑</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n<p style=\"text-indent:2em\"></p>\n\n","slug":"2021-04-01博客","published":1,"updated":"2021-04-06T00:58:27.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cj000bksupf5279fe6","content":"<h3 id=\"今天是2021-04-01\"><a href=\"#今天是2021-04-01\" class=\"headerlink\" title=\"今天是2021-04-01\"></a>今天是2021-04-01</h3><p style=\"text-indent:2em\">看样子本周忙完了？昨天晚上没有做攻略，今天可不能忘了。</p>\n<p style=\"text-indent:2em\">啊心情不佳的一周快要过去了，就让我安安静静的放假出去玩吧，无所谓天气了，我现在只想闲逛。</p>\n<p style=\"text-indent:2em\">三月写了六篇总结啊，我想保持每周一篇博客，只要不断更就是好事。</p>\n<p style=\"text-indent:2em\">我现在越来越痛恨自己了。她不是我本周坏心情的源头，求而不得才是。我偏激、故作姿态、附庸风雅，我首先是充满敌意。无聊无趣，但我爱我自己。</p>\n\n<h3 id=\"今天是2021-04-02\"><a href=\"#今天是2021-04-02\" class=\"headerlink\" title=\"今天是2021-04-02\"></a>今天是2021-04-02</h3><p style=\"text-indent:2em\">我犯了一个错误。我知道去博物馆需要预约，但是我为什么就不能多提前几天啊？苏州博物馆现在好像不允许无预约排队进入了，看来只能04-17周末补了，不过还是要去看下能否排队。或许能抢到退票也说不定。</p>\n<p style=\"text-indent:2em\">现在是16：28，现在人有点昏昏的，不想写代码了。晚上大概很忙，要理发，大约7点完成，然后7.30左右出发去之心城，逛一下小米之家，看看有没有手环。之后吃点东西，大概是汉堡王？晚上回来要椭圆机锻炼，洗澡，收拾行李，检查一下预订的房间需不需要更改。</p>\n<p style=\"text-indent:2em\">3月消费有点高哦，要注意控制。</p>\n<p style=\"text-indent:2em\">一个心理特征:我得不到所以在意，我在意得不到所以憎恶。</p>\n\n<h3 id=\"今天是2021-04-06\"><a href=\"#今天是2021-04-06\" class=\"headerlink\" title=\"今天是2021-04-06\"></a>今天是2021-04-06</h3><p style=\"text-indent:2em\">去苏州逛了一下，总体感觉还不错，景区周边规划的很好。园林风景也好，就是假日人有点多。为了市容不允许投放共享单车，出行就不那么方便。</p>\n<p style=\"text-indent:2em\">虎丘很推荐，早起去逛的话，空气清新人又少。寒山寺不行。哑巴生煎很好吃，不会太甜。</p>\n<p style=\"text-indent:2em\">拙政园很大，留园小一点，这两个地方都推荐，工作日来可能体验好一点。狮子林相形见绌。</p>\n<p style=\"text-indent:2em\">几天没长胖，反而瘦了2kg左右？困惑</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n<p style=\"text-indent:2em\"></p>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"今天是2021-04-01\"><a href=\"#今天是2021-04-01\" class=\"headerlink\" title=\"今天是2021-04-01\"></a>今天是2021-04-01</h3><p style=\"text-indent:2em\">看样子本周忙完了？昨天晚上没有做攻略，今天可不能忘了。</p>\n<p style=\"text-indent:2em\">啊心情不佳的一周快要过去了，就让我安安静静的放假出去玩吧，无所谓天气了，我现在只想闲逛。</p>\n<p style=\"text-indent:2em\">三月写了六篇总结啊，我想保持每周一篇博客，只要不断更就是好事。</p>\n<p style=\"text-indent:2em\">我现在越来越痛恨自己了。她不是我本周坏心情的源头，求而不得才是。我偏激、故作姿态、附庸风雅，我首先是充满敌意。无聊无趣，但我爱我自己。</p>\n\n<h3 id=\"今天是2021-04-02\"><a href=\"#今天是2021-04-02\" class=\"headerlink\" title=\"今天是2021-04-02\"></a>今天是2021-04-02</h3><p style=\"text-indent:2em\">我犯了一个错误。我知道去博物馆需要预约，但是我为什么就不能多提前几天啊？苏州博物馆现在好像不允许无预约排队进入了，看来只能04-17周末补了，不过还是要去看下能否排队。或许能抢到退票也说不定。</p>\n<p style=\"text-indent:2em\">现在是16：28，现在人有点昏昏的，不想写代码了。晚上大概很忙，要理发，大约7点完成，然后7.30左右出发去之心城，逛一下小米之家，看看有没有手环。之后吃点东西，大概是汉堡王？晚上回来要椭圆机锻炼，洗澡，收拾行李，检查一下预订的房间需不需要更改。</p>\n<p style=\"text-indent:2em\">3月消费有点高哦，要注意控制。</p>\n<p style=\"text-indent:2em\">一个心理特征:我得不到所以在意，我在意得不到所以憎恶。</p>\n\n<h3 id=\"今天是2021-04-06\"><a href=\"#今天是2021-04-06\" class=\"headerlink\" title=\"今天是2021-04-06\"></a>今天是2021-04-06</h3><p style=\"text-indent:2em\">去苏州逛了一下，总体感觉还不错，景区周边规划的很好。园林风景也好，就是假日人有点多。为了市容不允许投放共享单车，出行就不那么方便。</p>\n<p style=\"text-indent:2em\">虎丘很推荐，早起去逛的话，空气清新人又少。寒山寺不行。哑巴生煎很好吃，不会太甜。</p>\n<p style=\"text-indent:2em\">拙政园很大，留园小一点，这两个地方都推荐，工作日来可能体验好一点。狮子林相形见绌。</p>\n<p style=\"text-indent:2em\">几天没长胖，反而瘦了2kg左右？困惑</p>\n\n<p style=\"text-indent:2em\">暂时先这样，本月心情大概都会在这里。</p>\n<p style=\"text-indent:2em\"></p>\n\n"},{"title":"LeetCode 64 Minimum Path Sum","date":"2021-01-08T03:50:22.000Z","author":"heyXiao","summary":"LeetCode 题目总结","_content":"\n## 代码\n\n### [LeetCode 64](https://leetcode.com/problems/minimum-path-sum/)\n\n```javascript\n{% raw %}\n\tvar minPathSum = function(grid) {\n\t\t// 如果阵列长度为0\n\t\tif (!grid.length) {\n\t\t\treturn 0\n\t\t}\n\t\t// grid 为\n\t\t// [1, 3, 1],\n\t\t// [1, 5, 6],\n\t\t// [4, 2, 1],\n\n\t\t// 初始化一个二维数组,存储路径和\n\t\tlet dp = [[]];\n\n\t\t// dp[0] 赋值 grid[0] 路径和 (第一行)\n\t\t// grid[0] == [1, 3, 1];\n\t\t// dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n\t\t// dp[0] == [1, 4, 5];\n\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < grid[0].length; i++) {\n\t\t\tsum += grid[0][i]\n\t\t\tdp[0].push(sum)\n\t\t}\n\n\t\t// dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n\t\t// 赋值过后 dp 为\n\t\t// [1, 4, 5],\n\t\t// [2, A, B],\n\t\t// [6, C, D]\n\t\t// 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n\t\tlet sum2 = dp[0][0];\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tsum2 += grid[i][0];\n\t\t\tdp[i] = [];\n\t\t\tdp[i].push(sum2);\n\t\t}\n\t\t// dp\t\t\t\t//grid\n\t\t// [1, 4, 5],\t\t// [1, 3, 1],\n\t\t// [2, A, B],\t\t// [1, 5, 6],\n\t\t// [6, C, D]\t\t// [4, 2, 1]\n\t\t// 计算 A, B, C, D 四个点的路径和\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tfor (let j = 1; j < grid[0].length; j++) {\n\t\t\t\t// 比较右和下两个方向路径和的值,取最小\n\t\t\t\t// 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2,\n\t\t\t\t// 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\t\t\t}\n\t\t}\n\t\t// 最终结果\n\t\t// [1, 4, 5],\n\t\t// [2, 7, 11],\n\t\t// [6, 8, 9]\n\t\t// 取右下角值 结果为 9\n\t\treturn dp[dp.length - 1][dp[0].length - 1]\n\t}\n\tminPathSum([\n\t\t[1, 3, 1],\n\t\t[1, 5, 6],\n\t\t[4, 2, 1],\n\t])\n{% endraw %}\n```\n\n### 做什么\n\n一开始只是写 LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。\n","source":"_posts/LeetCode 64 Minimum Path Sum.md","raw":"---\ntitle: LeetCode 64 Minimum Path Sum\ndate: 2021-01-08 11:50:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: LeetCode 题目总结\ncategories: 技术\ntags:\n  - JavaScript\n  - LeetCode\n  - 学习总结\n---\n\n## 代码\n\n### [LeetCode 64](https://leetcode.com/problems/minimum-path-sum/)\n\n```javascript\n{% raw %}\n\tvar minPathSum = function(grid) {\n\t\t// 如果阵列长度为0\n\t\tif (!grid.length) {\n\t\t\treturn 0\n\t\t}\n\t\t// grid 为\n\t\t// [1, 3, 1],\n\t\t// [1, 5, 6],\n\t\t// [4, 2, 1],\n\n\t\t// 初始化一个二维数组,存储路径和\n\t\tlet dp = [[]];\n\n\t\t// dp[0] 赋值 grid[0] 路径和 (第一行)\n\t\t// grid[0] == [1, 3, 1];\n\t\t// dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n\t\t// dp[0] == [1, 4, 5];\n\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < grid[0].length; i++) {\n\t\t\tsum += grid[0][i]\n\t\t\tdp[0].push(sum)\n\t\t}\n\n\t\t// dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n\t\t// 赋值过后 dp 为\n\t\t// [1, 4, 5],\n\t\t// [2, A, B],\n\t\t// [6, C, D]\n\t\t// 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n\t\tlet sum2 = dp[0][0];\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tsum2 += grid[i][0];\n\t\t\tdp[i] = [];\n\t\t\tdp[i].push(sum2);\n\t\t}\n\t\t// dp\t\t\t\t//grid\n\t\t// [1, 4, 5],\t\t// [1, 3, 1],\n\t\t// [2, A, B],\t\t// [1, 5, 6],\n\t\t// [6, C, D]\t\t// [4, 2, 1]\n\t\t// 计算 A, B, C, D 四个点的路径和\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tfor (let j = 1; j < grid[0].length; j++) {\n\t\t\t\t// 比较右和下两个方向路径和的值,取最小\n\t\t\t\t// 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2,\n\t\t\t\t// 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\t\t\t}\n\t\t}\n\t\t// 最终结果\n\t\t// [1, 4, 5],\n\t\t// [2, 7, 11],\n\t\t// [6, 8, 9]\n\t\t// 取右下角值 结果为 9\n\t\treturn dp[dp.length - 1][dp[0].length - 1]\n\t}\n\tminPathSum([\n\t\t[1, 3, 1],\n\t\t[1, 5, 6],\n\t\t[4, 2, 1],\n\t])\n{% endraw %}\n```\n\n### 做什么\n\n一开始只是写 LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。\n","slug":"LeetCode 64 Minimum Path Sum","published":1,"updated":"2021-02-26T06:11:45.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cl000fksupfllo7sa2","content":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-64\"><a href=\"#LeetCode-64\" class=\"headerlink\" title=\"LeetCode 64\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\">LeetCode 64</a></h3><pre class=\" language-javascript\"><code class=\"language-javascript\">\n\t<span class=\"token keyword\">var</span> minPathSum <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>grid<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 如果阵列长度为0</span>\n\t\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>grid<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// grid 为</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [1, 3, 1],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [1, 5, 6],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [4, 2, 1],</span>\n\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 初始化一个二维数组,存储路径和</span>\n\t\t<span class=\"token keyword\">let</span> dp <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token comment\" spellcheck=\"true\">// dp[0] 赋值 grid[0] 路径和 (第一行)</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// grid[0] == [1, 3, 1];</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// dp[0] == [1, 4, 5];</span>\n\n\t\t<span class=\"token keyword\">let</span> sum <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\tsum <span class=\"token operator\">+</span><span class=\"token operator\">=</span> grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n\t\t\tdp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>sum<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t\t<span class=\"token comment\" spellcheck=\"true\">// dp[i][0] 赋值 grid[i][0] 路径和 (第一列)</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 赋值过后 dp 为</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [1, 4, 5],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [2, A, B],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [6, C, D]</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3</span>\n\t\t<span class=\"token keyword\">let</span> sum2 <span class=\"token operator\">=</span> dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> grid<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\tsum2 <span class=\"token operator\">+</span><span class=\"token operator\">=</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\tdp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t\tdp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>sum2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// dp\t\t\t\t//grid</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [1, 4, 5],\t\t// [1, 3, 1],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [2, A, B],\t\t// [1, 5, 6],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [6, C, D]\t\t// [4, 2, 1]</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 计算 A, B, C, D 四个点的路径和</span>\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> grid<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> grid<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// 比较右和下两个方向路径和的值,取最小</span>\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2,</span>\n\t\t\t\t<span class=\"token comment\" spellcheck=\"true\">// 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7</span>\n\t\t\t\tdp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">min</span><span class=\"token punctuation\">(</span>dp<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> dp<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> grid<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span>\n\t\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 最终结果</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [1, 4, 5],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [2, 7, 11],</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// [6, 8, 9]</span>\n\t\t<span class=\"token comment\" spellcheck=\"true\">// 取右下角值 结果为 9</span>\n\t\t<span class=\"token keyword\">return</span> dp<span class=\"token punctuation\">[</span>dp<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>dp<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token function\">minPathSum</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<h3 id=\"做什么\"><a href=\"#做什么\" class=\"headerlink\" title=\"做什么\"></a>做什么</h3><p>一开始只是写 LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-64\"><a href=\"#LeetCode-64\" class=\"headerlink\" title=\"LeetCode 64\"></a><a href=\"https://leetcode.com/problems/minimum-path-sum/\">LeetCode 64</a></h3><pre><code class=\"javascript\">\n\tvar minPathSum = function(grid) {\n\t\t// 如果阵列长度为0\n\t\tif (!grid.length) {\n\t\t\treturn 0\n\t\t}\n\t\t// grid 为\n\t\t// [1, 3, 1],\n\t\t// [1, 5, 6],\n\t\t// [4, 2, 1],\n\n\t\t// 初始化一个二维数组,存储路径和\n\t\tlet dp = [[]];\n\n\t\t// dp[0] 赋值 grid[0] 路径和 (第一行)\n\t\t// grid[0] == [1, 3, 1];\n\t\t// dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;\n\t\t// dp[0] == [1, 4, 5];\n\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < grid[0].length; i++) {\n\t\t\tsum += grid[0][i]\n\t\t\tdp[0].push(sum)\n\t\t}\n\n\t\t// dp[i][0] 赋值 grid[i][0] 路径和 (第一列)\n\t\t// 赋值过后 dp 为\n\t\t// [1, 4, 5],\n\t\t// [2, A, B],\n\t\t// [6, C, D]\n\t\t// 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3\n\t\tlet sum2 = dp[0][0];\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tsum2 += grid[i][0];\n\t\t\tdp[i] = [];\n\t\t\tdp[i].push(sum2);\n\t\t}\n\t\t// dp\t\t\t\t//grid\n\t\t// [1, 4, 5],\t\t// [1, 3, 1],\n\t\t// [2, A, B],\t\t// [1, 5, 6],\n\t\t// [6, C, D]\t\t// [4, 2, 1]\n\t\t// 计算 A, B, C, D 四个点的路径和\n\t\tfor (let i = 1; i < grid.length; i++) {\n\t\t\tfor (let j = 1; j < grid[0].length; j++) {\n\t\t\t\t// 比较右和下两个方向路径和的值,取最小\n\t\t\t\t// 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2,\n\t\t\t\t// 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7\n\t\t\t\tdp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]\n\t\t\t}\n\t\t}\n\t\t// 最终结果\n\t\t// [1, 4, 5],\n\t\t// [2, 7, 11],\n\t\t// [6, 8, 9]\n\t\t// 取右下角值 结果为 9\n\t\treturn dp[dp.length - 1][dp[0].length - 1]\n\t}\n\tminPathSum([\n\t\t[1, 3, 1],\n\t\t[1, 5, 6],\n\t\t[4, 2, 1],\n\t])\n</code></pre>\n<h3 id=\"做什么\"><a href=\"#做什么\" class=\"headerlink\" title=\"做什么\"></a>做什么</h3><p>一开始只是写 LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。</p>\n"},{"title":"LeetCode 70 Climb Stairs","date":"2021-01-08T06:32:27.000Z","author":"heyXiao","summary":"LeetCode 题目总结","_content":"\n## 代码\n\n### [LeetCode 70](https://leetcode.com/problems/climbing-stairs/)\n\n```javascript\n{% raw %}\n    var climbStairs = function(n) {\n    \tif (n >= 1 && n <= 3) {\n    \t\treturn n\n    \t}\n    \t// 第一种 递归\n    \tlet arr = [0, 1, 2, 3]\n    \tfor (let i = 4; i <= n; i++) {\n    \t\tarr.push(arr[i - 1] + arr[i - 2])\n    \t}\n    \treturn arr[n]\n\n    \t// 第二种 斐波那契优化\n    \tvar a = 1,\n    \t\tb = 1;\n    \twhile (--n > 0) {\n    \t\tb = b + a;\n    \t\ta = b - a;\n    \t}\n    \treturn b;\n\n    \t// 第三种 不知道为什么...\n    \tvar sqrt5 = Math.sqrt(5);\n    \tvar fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    \treturn (fibn / sqrt5);\n    }\n    climbStairs(10)\n{% endraw %}\n```\n","source":"_posts/LeetCode 70 Climb Stairs.md","raw":"---\ntitle: LeetCode 70 Climb Stairs\ndate: 2021-01-08 14:32:27\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: LeetCode 题目总结\ncategories: 技术\ntags:\n  - JavaScript\n  - LeetCode\n  - 学习总结\n---\n\n## 代码\n\n### [LeetCode 70](https://leetcode.com/problems/climbing-stairs/)\n\n```javascript\n{% raw %}\n    var climbStairs = function(n) {\n    \tif (n >= 1 && n <= 3) {\n    \t\treturn n\n    \t}\n    \t// 第一种 递归\n    \tlet arr = [0, 1, 2, 3]\n    \tfor (let i = 4; i <= n; i++) {\n    \t\tarr.push(arr[i - 1] + arr[i - 2])\n    \t}\n    \treturn arr[n]\n\n    \t// 第二种 斐波那契优化\n    \tvar a = 1,\n    \t\tb = 1;\n    \twhile (--n > 0) {\n    \t\tb = b + a;\n    \t\ta = b - a;\n    \t}\n    \treturn b;\n\n    \t// 第三种 不知道为什么...\n    \tvar sqrt5 = Math.sqrt(5);\n    \tvar fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    \treturn (fibn / sqrt5);\n    }\n    climbStairs(10)\n{% endraw %}\n```\n","slug":"LeetCode 70 Climb Stairs","published":1,"updated":"2021-02-26T06:12:17.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cm000hksuphjr56fk0","content":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-70\"><a href=\"#LeetCode-70\" class=\"headerlink\" title=\"LeetCode 70\"></a><a href=\"https://leetcode.com/problems/climbing-stairs/\">LeetCode 70</a></h3><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">var</span> climbStairs <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">>=</span> <span class=\"token number\">1</span> <span class=\"token operator\">&amp;&amp;</span> n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t\t<span class=\"token keyword\">return</span> n\n    \t<span class=\"token punctuation\">}</span>\n    \t<span class=\"token comment\" spellcheck=\"true\">// 第一种 递归</span>\n    \t<span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span>\n    \t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">4</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t\tarr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    \t<span class=\"token punctuation\">}</span>\n    \t<span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span>\n\n    \t<span class=\"token comment\" spellcheck=\"true\">// 第二种 斐波那契优化</span>\n    \t<span class=\"token keyword\">var</span> a <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n    \t\tb <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    \t<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">--</span>n <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    \t\tb <span class=\"token operator\">=</span> b <span class=\"token operator\">+</span> a<span class=\"token punctuation\">;</span>\n    \t\ta <span class=\"token operator\">=</span> b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">;</span>\n    \t<span class=\"token punctuation\">}</span>\n    \t<span class=\"token keyword\">return</span> b<span class=\"token punctuation\">;</span>\n\n    \t<span class=\"token comment\" spellcheck=\"true\">// 第三种 不知道为什么...</span>\n    \t<span class=\"token keyword\">var</span> sqrt5 <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">sqrt</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \t<span class=\"token keyword\">var</span> fibn <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">+</span> sqrt5<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">pow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span> <span class=\"token operator\">-</span> sqrt5<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \t<span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>fibn <span class=\"token operator\">/</span> sqrt5<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">climbStairs</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span>\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><h3 id=\"LeetCode-70\"><a href=\"#LeetCode-70\" class=\"headerlink\" title=\"LeetCode 70\"></a><a href=\"https://leetcode.com/problems/climbing-stairs/\">LeetCode 70</a></h3><pre><code class=\"javascript\">\n    var climbStairs = function(n) {\n    \tif (n >= 1 && n <= 3) {\n    \t\treturn n\n    \t}\n    \t// 第一种 递归\n    \tlet arr = [0, 1, 2, 3]\n    \tfor (let i = 4; i <= n; i++) {\n    \t\tarr.push(arr[i - 1] + arr[i - 2])\n    \t}\n    \treturn arr[n]\n\n    \t// 第二种 斐波那契优化\n    \tvar a = 1,\n    \t\tb = 1;\n    \twhile (--n > 0) {\n    \t\tb = b + a;\n    \t\ta = b - a;\n    \t}\n    \treturn b;\n\n    \t// 第三种 不知道为什么...\n    \tvar sqrt5 = Math.sqrt(5);\n    \tvar fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);\n    \treturn (fibn / sqrt5);\n    }\n    climbStairs(10)\n</code></pre>\n"},{"title":"一篇来自2018年4月17日的Git笔记","date":"2020-11-09T04:27:22.000Z","author":"heyXiao","summary":"一些比较常用的Git指令","_content":"\n## GIT\n\n### 命令行窗口\n- 我们平时使用计算机都是通过可视化的界面来对电脑发送命令\n    + 鼠标右键->新建->新建文件夹\n- 命令行窗口也是一种可以向计算机发送命令的途径\n    + 通过命令的形式告诉计算机我们要做什么\n    + mkdir 文件夹的名字\n- 开启命令行\n    + win + R -> cmd -> enter\n- 常用命令行工具\n    + cmd\n    + powershell\n    + git bash\n\n### 常用命令\n- pwd (print working directory) 查看当前所在的目录\n- cd (change directory) 切换目录\n- ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)\n- clear 清屏（有兼容问题  可以用cls）\n- mkdir (make directory) 创建目录\n- touch 创建文件（有兼容问题 可以用 type nul>文件名）\n- cat 查看文件内容 一次性将所有内容输出\n- less 查看文件内容 每一次查看部分文件内容\n    + 回车 一次向下走一行\n    + 空格 一次向下走一页\n    + b（back）    一次向上走一页\n    + q（quit）    退出\n- rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）\n- rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用\n- mv (move) 移动文件或重命名\n- cp (copy) 复制文件\n- echo '内容' > 文件 输出内容到文件 每次输出都是覆盖原有文件内容\n- ehco '内容' >> 文件 输出内容到文件 每次输出都是追新内容\n- 命令的基本组成部分\n    + rm(删除命令) -rf(选项)\n\n### GIT是什么\n- 版本控制工具\n    + 例子：\n        * 人事专员管理职工信息\n        * 项目功能变更导致的问题\n        * 多人开发一个项目 代码共享时的问题\n\n### GIT三大区域\n- 工作目录\n    + 存放项目代码的目录\n- 暂存区\n    + 临时存放更改的了文件\n    + 防止工作目录中的代码丢失\n- 代码仓库\n    + 当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库\n    + 相当于复制了一份当前的代码存储到了仓库中\n\n### GIT常用命令\n- 配置git用户名和邮箱\n    + git config --global user.name zhangsan\n    + git config --global user.email demotest123@163.com\n- 查看当前的git配置\n    + git config --list\n- 初始化git仓库\n    + git init\n- 查看当前仓库的状态 \n    + git status\n- 将工作目录中的文件添加到暂存区\n    + git add\n- 将暂存区中的代码提交到本地仓库 形成一个版本\n    + git commit -m 备注 \n- 查看本地仓库中的历史提交版本\n    + git log \n- 将暂存区中的文件恢复到工作目录\n    + git rm --cached 文件列表 \n    + 说明:\n        * 必须保证工作目录中的代码和暂存区中的代码一致\n        * 此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理\n- 用暂存区中的文件覆盖工作目录中的文件\n    + git checkout -- 文件列表\n    + 说明：暂存区和工作目录都有此文件 这个文件依然被git管理\n- 回滚到本地仓库中的特定版本并覆盖暂存区和工作目录\n    + git reset --hard commitID\n- 查看分支\n    + git branch\n- 创建分支\n    + git branch 分支名称\n- 切换分支\n    + git checkout 分支名称\n- 创建并切换分支\n    + git checkout -b 分支名称 \n- 删除分支(如果分支没有被合并不允许删除)\n    + git branch -d 分支名称\n- 删除分支(强制删除分支)\n    + git branch -D 分支名称\n- 合并分支\n    + git merge 来源分支\n- 初始化一个裸露仓库(公共代码仓库)\n    + git init --bare \n- 向远程仓库推送代码\n    + git push 远程仓库地址 本地分支名称:远程分支名称\n- 从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)\n    + git pull 远程仓库地址 远程分支名称:本地分支名称\n- 为远程仓库地址创建别名\n    + git remote add 别名 远程仓库地址\n- 查看远程地址的详情信息\n    + git remote -v\n- 查看当前别名所对应的远程仓库地址\n    + git remote show 别名 \n- 删除当前别名及所对应的远程仓库地址\n    + git remote remove 别名 \n- 从远程仓库获取代码(拉取所有版本到本地)\n    + git clone 远程仓库地址 项目名称\n    + 使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发\n- 冲突修复\n    + 模拟冲突\n        * 张三和李四分别克隆代码到本地\n        * 张三改了demo文件并提交到远端仓库\n        * 李四也改了同一个文件\n        * 这时因为张三已经提交了一版代码到远程仓库\n        * 远程仓库的代码要比李四本地的代码新\n        * 所以李四不能直接向远程仓库推送代码\n        * 要先拉去再推送\n        * 此时因为张三和李四改了同一个文件所以产生了冲突\n        * 李四解决冲突并再次提交代码到远程仓库\n- 多人协作开发免登录操作\n    + ssh-keygen\n\n### git使用流程\n-   1.配置账户信息\n    + git config --global user.name 用户名\n    + git config --global user.email 邮箱地址\n    + git config --list 查看当前的git配置\n-   2.初始化本地仓库\n    + git init\n-   3.查看本地仓库的状态\n    + git status\n-   4.将工作目录中的文件提交到暂存区\n    + git add 文件列表\n    + git add . 添加工作目录中所有的文件到暂存区\n-   1. 将暂存区中的代码提交到本地仓库\n    + git commit -m 备注\n    + git commit -m \"first commit\"\n\n### git 忽略清单\n- .gitignore文件","source":"_posts/一篇来自2018年4月17日的Git笔记.md","raw":"---\ntitle: 一篇来自2018年4月17日的Git笔记\ndate: 2020-11-09 12:27:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: 一些比较常用的Git指令\ncategories: Git\ntags:\n  - Git\n---\n\n## GIT\n\n### 命令行窗口\n- 我们平时使用计算机都是通过可视化的界面来对电脑发送命令\n    + 鼠标右键->新建->新建文件夹\n- 命令行窗口也是一种可以向计算机发送命令的途径\n    + 通过命令的形式告诉计算机我们要做什么\n    + mkdir 文件夹的名字\n- 开启命令行\n    + win + R -> cmd -> enter\n- 常用命令行工具\n    + cmd\n    + powershell\n    + git bash\n\n### 常用命令\n- pwd (print working directory) 查看当前所在的目录\n- cd (change directory) 切换目录\n- ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)\n- clear 清屏（有兼容问题  可以用cls）\n- mkdir (make directory) 创建目录\n- touch 创建文件（有兼容问题 可以用 type nul>文件名）\n- cat 查看文件内容 一次性将所有内容输出\n- less 查看文件内容 每一次查看部分文件内容\n    + 回车 一次向下走一行\n    + 空格 一次向下走一页\n    + b（back）    一次向上走一页\n    + q（quit）    退出\n- rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）\n- rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用\n- mv (move) 移动文件或重命名\n- cp (copy) 复制文件\n- echo '内容' > 文件 输出内容到文件 每次输出都是覆盖原有文件内容\n- ehco '内容' >> 文件 输出内容到文件 每次输出都是追新内容\n- 命令的基本组成部分\n    + rm(删除命令) -rf(选项)\n\n### GIT是什么\n- 版本控制工具\n    + 例子：\n        * 人事专员管理职工信息\n        * 项目功能变更导致的问题\n        * 多人开发一个项目 代码共享时的问题\n\n### GIT三大区域\n- 工作目录\n    + 存放项目代码的目录\n- 暂存区\n    + 临时存放更改的了文件\n    + 防止工作目录中的代码丢失\n- 代码仓库\n    + 当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库\n    + 相当于复制了一份当前的代码存储到了仓库中\n\n### GIT常用命令\n- 配置git用户名和邮箱\n    + git config --global user.name zhangsan\n    + git config --global user.email demotest123@163.com\n- 查看当前的git配置\n    + git config --list\n- 初始化git仓库\n    + git init\n- 查看当前仓库的状态 \n    + git status\n- 将工作目录中的文件添加到暂存区\n    + git add\n- 将暂存区中的代码提交到本地仓库 形成一个版本\n    + git commit -m 备注 \n- 查看本地仓库中的历史提交版本\n    + git log \n- 将暂存区中的文件恢复到工作目录\n    + git rm --cached 文件列表 \n    + 说明:\n        * 必须保证工作目录中的代码和暂存区中的代码一致\n        * 此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理\n- 用暂存区中的文件覆盖工作目录中的文件\n    + git checkout -- 文件列表\n    + 说明：暂存区和工作目录都有此文件 这个文件依然被git管理\n- 回滚到本地仓库中的特定版本并覆盖暂存区和工作目录\n    + git reset --hard commitID\n- 查看分支\n    + git branch\n- 创建分支\n    + git branch 分支名称\n- 切换分支\n    + git checkout 分支名称\n- 创建并切换分支\n    + git checkout -b 分支名称 \n- 删除分支(如果分支没有被合并不允许删除)\n    + git branch -d 分支名称\n- 删除分支(强制删除分支)\n    + git branch -D 分支名称\n- 合并分支\n    + git merge 来源分支\n- 初始化一个裸露仓库(公共代码仓库)\n    + git init --bare \n- 向远程仓库推送代码\n    + git push 远程仓库地址 本地分支名称:远程分支名称\n- 从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)\n    + git pull 远程仓库地址 远程分支名称:本地分支名称\n- 为远程仓库地址创建别名\n    + git remote add 别名 远程仓库地址\n- 查看远程地址的详情信息\n    + git remote -v\n- 查看当前别名所对应的远程仓库地址\n    + git remote show 别名 \n- 删除当前别名及所对应的远程仓库地址\n    + git remote remove 别名 \n- 从远程仓库获取代码(拉取所有版本到本地)\n    + git clone 远程仓库地址 项目名称\n    + 使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发\n- 冲突修复\n    + 模拟冲突\n        * 张三和李四分别克隆代码到本地\n        * 张三改了demo文件并提交到远端仓库\n        * 李四也改了同一个文件\n        * 这时因为张三已经提交了一版代码到远程仓库\n        * 远程仓库的代码要比李四本地的代码新\n        * 所以李四不能直接向远程仓库推送代码\n        * 要先拉去再推送\n        * 此时因为张三和李四改了同一个文件所以产生了冲突\n        * 李四解决冲突并再次提交代码到远程仓库\n- 多人协作开发免登录操作\n    + ssh-keygen\n\n### git使用流程\n-   1.配置账户信息\n    + git config --global user.name 用户名\n    + git config --global user.email 邮箱地址\n    + git config --list 查看当前的git配置\n-   2.初始化本地仓库\n    + git init\n-   3.查看本地仓库的状态\n    + git status\n-   4.将工作目录中的文件提交到暂存区\n    + git add 文件列表\n    + git add . 添加工作目录中所有的文件到暂存区\n-   1. 将暂存区中的代码提交到本地仓库\n    + git commit -m 备注\n    + git commit -m \"first commit\"\n\n### git 忽略清单\n- .gitignore文件","slug":"一篇来自2018年4月17日的Git笔记","published":1,"updated":"2020-11-17T08:38:16.685Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cn000mksup9hyjch4y","content":"<h2 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h2><h3 id=\"命令行窗口\"><a href=\"#命令行窗口\" class=\"headerlink\" title=\"命令行窗口\"></a>命令行窗口</h3><ul>\n<li>我们平时使用计算机都是通过可视化的界面来对电脑发送命令<ul>\n<li>鼠标右键-&gt;新建-&gt;新建文件夹</li>\n</ul>\n</li>\n<li>命令行窗口也是一种可以向计算机发送命令的途径<ul>\n<li>通过命令的形式告诉计算机我们要做什么</li>\n<li>mkdir 文件夹的名字</li>\n</ul>\n</li>\n<li>开启命令行<ul>\n<li>win + R -&gt; cmd -&gt; enter</li>\n</ul>\n</li>\n<li>常用命令行工具<ul>\n<li>cmd</li>\n<li>powershell</li>\n<li>git bash</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>pwd (print working directory) 查看当前所在的目录</li>\n<li>cd (change directory) 切换目录</li>\n<li>ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)</li>\n<li>clear 清屏（有兼容问题  可以用cls）</li>\n<li>mkdir (make directory) 创建目录</li>\n<li>touch 创建文件（有兼容问题 可以用 type nul&gt;文件名）</li>\n<li>cat 查看文件内容 一次性将所有内容输出</li>\n<li>less 查看文件内容 每一次查看部分文件内容<ul>\n<li>回车 一次向下走一行</li>\n<li>空格 一次向下走一页</li>\n<li>b（back）    一次向上走一页</li>\n<li>q（quit）    退出</li>\n</ul>\n</li>\n<li>rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）</li>\n<li>rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用</li>\n<li>mv (move) 移动文件或重命名</li>\n<li>cp (copy) 复制文件</li>\n<li>echo ‘内容’ &gt; 文件 输出内容到文件 每次输出都是覆盖原有文件内容</li>\n<li>ehco ‘内容’ &gt;&gt; 文件 输出内容到文件 每次输出都是追新内容</li>\n<li>命令的基本组成部分<ul>\n<li>rm(删除命令) -rf(选项)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT是什么\"><a href=\"#GIT是什么\" class=\"headerlink\" title=\"GIT是什么\"></a>GIT是什么</h3><ul>\n<li>版本控制工具<ul>\n<li>例子：<ul>\n<li>人事专员管理职工信息</li>\n<li>项目功能变更导致的问题</li>\n<li>多人开发一个项目 代码共享时的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT三大区域\"><a href=\"#GIT三大区域\" class=\"headerlink\" title=\"GIT三大区域\"></a>GIT三大区域</h3><ul>\n<li>工作目录<ul>\n<li>存放项目代码的目录</li>\n</ul>\n</li>\n<li>暂存区<ul>\n<li>临时存放更改的了文件</li>\n<li>防止工作目录中的代码丢失</li>\n</ul>\n</li>\n<li>代码仓库<ul>\n<li>当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库</li>\n<li>相当于复制了一份当前的代码存储到了仓库中</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT常用命令\"><a href=\"#GIT常用命令\" class=\"headerlink\" title=\"GIT常用命令\"></a>GIT常用命令</h3><ul>\n<li>配置git用户名和邮箱<ul>\n<li>git config –global user.name zhangsan</li>\n<li>git config –global user.email <a href=\"mailto:&#100;&#101;&#109;&#x6f;&#116;&#101;&#115;&#116;&#49;&#x32;&#x33;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;\">&#100;&#101;&#109;&#x6f;&#116;&#101;&#115;&#116;&#49;&#x32;&#x33;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;</a></li>\n</ul>\n</li>\n<li>查看当前的git配置<ul>\n<li>git config –list</li>\n</ul>\n</li>\n<li>初始化git仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>查看当前仓库的状态 <ul>\n<li>git status</li>\n</ul>\n</li>\n<li>将工作目录中的文件添加到暂存区<ul>\n<li>git add</li>\n</ul>\n</li>\n<li>将暂存区中的代码提交到本地仓库 形成一个版本<ul>\n<li>git commit -m 备注 </li>\n</ul>\n</li>\n<li>查看本地仓库中的历史提交版本<ul>\n<li>git log </li>\n</ul>\n</li>\n<li>将暂存区中的文件恢复到工作目录<ul>\n<li>git rm –cached 文件列表 </li>\n<li>说明:<ul>\n<li>必须保证工作目录中的代码和暂存区中的代码一致</li>\n<li>此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用暂存区中的文件覆盖工作目录中的文件<ul>\n<li>git checkout – 文件列表</li>\n<li>说明：暂存区和工作目录都有此文件 这个文件依然被git管理</li>\n</ul>\n</li>\n<li>回滚到本地仓库中的特定版本并覆盖暂存区和工作目录<ul>\n<li>git reset –hard commitID</li>\n</ul>\n</li>\n<li>查看分支<ul>\n<li>git branch</li>\n</ul>\n</li>\n<li>创建分支<ul>\n<li>git branch 分支名称</li>\n</ul>\n</li>\n<li>切换分支<ul>\n<li>git checkout 分支名称</li>\n</ul>\n</li>\n<li>创建并切换分支<ul>\n<li>git checkout -b 分支名称 </li>\n</ul>\n</li>\n<li>删除分支(如果分支没有被合并不允许删除)<ul>\n<li>git branch -d 分支名称</li>\n</ul>\n</li>\n<li>删除分支(强制删除分支)<ul>\n<li>git branch -D 分支名称</li>\n</ul>\n</li>\n<li>合并分支<ul>\n<li>git merge 来源分支</li>\n</ul>\n</li>\n<li>初始化一个裸露仓库(公共代码仓库)<ul>\n<li>git init –bare </li>\n</ul>\n</li>\n<li>向远程仓库推送代码<ul>\n<li>git push 远程仓库地址 本地分支名称:远程分支名称</li>\n</ul>\n</li>\n<li>从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)<ul>\n<li>git pull 远程仓库地址 远程分支名称:本地分支名称</li>\n</ul>\n</li>\n<li>为远程仓库地址创建别名<ul>\n<li>git remote add 别名 远程仓库地址</li>\n</ul>\n</li>\n<li>查看远程地址的详情信息<ul>\n<li>git remote -v</li>\n</ul>\n</li>\n<li>查看当前别名所对应的远程仓库地址<ul>\n<li>git remote show 别名 </li>\n</ul>\n</li>\n<li>删除当前别名及所对应的远程仓库地址<ul>\n<li>git remote remove 别名 </li>\n</ul>\n</li>\n<li>从远程仓库获取代码(拉取所有版本到本地)<ul>\n<li>git clone 远程仓库地址 项目名称</li>\n<li>使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发</li>\n</ul>\n</li>\n<li>冲突修复<ul>\n<li>模拟冲突<ul>\n<li>张三和李四分别克隆代码到本地</li>\n<li>张三改了demo文件并提交到远端仓库</li>\n<li>李四也改了同一个文件</li>\n<li>这时因为张三已经提交了一版代码到远程仓库</li>\n<li>远程仓库的代码要比李四本地的代码新</li>\n<li>所以李四不能直接向远程仓库推送代码</li>\n<li>要先拉去再推送</li>\n<li>此时因为张三和李四改了同一个文件所以产生了冲突</li>\n<li>李四解决冲突并再次提交代码到远程仓库</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多人协作开发免登录操作<ul>\n<li>ssh-keygen</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git使用流程\"><a href=\"#git使用流程\" class=\"headerlink\" title=\"git使用流程\"></a>git使用流程</h3><ul>\n<li>1.配置账户信息<ul>\n<li>git config –global user.name 用户名</li>\n<li>git config –global user.email 邮箱地址</li>\n<li>git config –list 查看当前的git配置</li>\n</ul>\n</li>\n<li>2.初始化本地仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>3.查看本地仓库的状态<ul>\n<li>git status</li>\n</ul>\n</li>\n<li>4.将工作目录中的文件提交到暂存区<ul>\n<li>git add 文件列表</li>\n<li>git add . 添加工作目录中所有的文件到暂存区</li>\n</ul>\n</li>\n<li><ol>\n<li>将暂存区中的代码提交到本地仓库<ul>\n<li>git commit -m 备注</li>\n<li>git commit -m “first commit”</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"git-忽略清单\"><a href=\"#git-忽略清单\" class=\"headerlink\" title=\"git 忽略清单\"></a>git 忽略清单</h3><ul>\n<li>.gitignore文件</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GIT\"><a href=\"#GIT\" class=\"headerlink\" title=\"GIT\"></a>GIT</h2><h3 id=\"命令行窗口\"><a href=\"#命令行窗口\" class=\"headerlink\" title=\"命令行窗口\"></a>命令行窗口</h3><ul>\n<li>我们平时使用计算机都是通过可视化的界面来对电脑发送命令<ul>\n<li>鼠标右键-&gt;新建-&gt;新建文件夹</li>\n</ul>\n</li>\n<li>命令行窗口也是一种可以向计算机发送命令的途径<ul>\n<li>通过命令的形式告诉计算机我们要做什么</li>\n<li>mkdir 文件夹的名字</li>\n</ul>\n</li>\n<li>开启命令行<ul>\n<li>win + R -&gt; cmd -&gt; enter</li>\n</ul>\n</li>\n<li>常用命令行工具<ul>\n<li>cmd</li>\n<li>powershell</li>\n<li>git bash</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>pwd (print working directory) 查看当前所在的目录</li>\n<li>cd (change directory) 切换目录</li>\n<li>ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)</li>\n<li>clear 清屏（有兼容问题  可以用cls）</li>\n<li>mkdir (make directory) 创建目录</li>\n<li>touch 创建文件（有兼容问题 可以用 type nul&gt;文件名）</li>\n<li>cat 查看文件内容 一次性将所有内容输出</li>\n<li>less 查看文件内容 每一次查看部分文件内容<ul>\n<li>回车 一次向下走一行</li>\n<li>空格 一次向下走一页</li>\n<li>b（back）    一次向上走一页</li>\n<li>q（quit）    退出</li>\n</ul>\n</li>\n<li>rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）</li>\n<li>rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用</li>\n<li>mv (move) 移动文件或重命名</li>\n<li>cp (copy) 复制文件</li>\n<li>echo ‘内容’ &gt; 文件 输出内容到文件 每次输出都是覆盖原有文件内容</li>\n<li>ehco ‘内容’ &gt;&gt; 文件 输出内容到文件 每次输出都是追新内容</li>\n<li>命令的基本组成部分<ul>\n<li>rm(删除命令) -rf(选项)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT是什么\"><a href=\"#GIT是什么\" class=\"headerlink\" title=\"GIT是什么\"></a>GIT是什么</h3><ul>\n<li>版本控制工具<ul>\n<li>例子：<ul>\n<li>人事专员管理职工信息</li>\n<li>项目功能变更导致的问题</li>\n<li>多人开发一个项目 代码共享时的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT三大区域\"><a href=\"#GIT三大区域\" class=\"headerlink\" title=\"GIT三大区域\"></a>GIT三大区域</h3><ul>\n<li>工作目录<ul>\n<li>存放项目代码的目录</li>\n</ul>\n</li>\n<li>暂存区<ul>\n<li>临时存放更改的了文件</li>\n<li>防止工作目录中的代码丢失</li>\n</ul>\n</li>\n<li>代码仓库<ul>\n<li>当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库</li>\n<li>相当于复制了一份当前的代码存储到了仓库中</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GIT常用命令\"><a href=\"#GIT常用命令\" class=\"headerlink\" title=\"GIT常用命令\"></a>GIT常用命令</h3><ul>\n<li>配置git用户名和邮箱<ul>\n<li>git config –global user.name zhangsan</li>\n<li>git config –global user.email <a href=\"mailto:&#100;&#101;&#109;&#x6f;&#116;&#101;&#115;&#116;&#49;&#x32;&#x33;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;\">&#100;&#101;&#109;&#x6f;&#116;&#101;&#115;&#116;&#49;&#x32;&#x33;&#64;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;</a></li>\n</ul>\n</li>\n<li>查看当前的git配置<ul>\n<li>git config –list</li>\n</ul>\n</li>\n<li>初始化git仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>查看当前仓库的状态 <ul>\n<li>git status</li>\n</ul>\n</li>\n<li>将工作目录中的文件添加到暂存区<ul>\n<li>git add</li>\n</ul>\n</li>\n<li>将暂存区中的代码提交到本地仓库 形成一个版本<ul>\n<li>git commit -m 备注 </li>\n</ul>\n</li>\n<li>查看本地仓库中的历史提交版本<ul>\n<li>git log </li>\n</ul>\n</li>\n<li>将暂存区中的文件恢复到工作目录<ul>\n<li>git rm –cached 文件列表 </li>\n<li>说明:<ul>\n<li>必须保证工作目录中的代码和暂存区中的代码一致</li>\n<li>此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用暂存区中的文件覆盖工作目录中的文件<ul>\n<li>git checkout – 文件列表</li>\n<li>说明：暂存区和工作目录都有此文件 这个文件依然被git管理</li>\n</ul>\n</li>\n<li>回滚到本地仓库中的特定版本并覆盖暂存区和工作目录<ul>\n<li>git reset –hard commitID</li>\n</ul>\n</li>\n<li>查看分支<ul>\n<li>git branch</li>\n</ul>\n</li>\n<li>创建分支<ul>\n<li>git branch 分支名称</li>\n</ul>\n</li>\n<li>切换分支<ul>\n<li>git checkout 分支名称</li>\n</ul>\n</li>\n<li>创建并切换分支<ul>\n<li>git checkout -b 分支名称 </li>\n</ul>\n</li>\n<li>删除分支(如果分支没有被合并不允许删除)<ul>\n<li>git branch -d 分支名称</li>\n</ul>\n</li>\n<li>删除分支(强制删除分支)<ul>\n<li>git branch -D 分支名称</li>\n</ul>\n</li>\n<li>合并分支<ul>\n<li>git merge 来源分支</li>\n</ul>\n</li>\n<li>初始化一个裸露仓库(公共代码仓库)<ul>\n<li>git init –bare </li>\n</ul>\n</li>\n<li>向远程仓库推送代码<ul>\n<li>git push 远程仓库地址 本地分支名称:远程分支名称</li>\n</ul>\n</li>\n<li>从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)<ul>\n<li>git pull 远程仓库地址 远程分支名称:本地分支名称</li>\n</ul>\n</li>\n<li>为远程仓库地址创建别名<ul>\n<li>git remote add 别名 远程仓库地址</li>\n</ul>\n</li>\n<li>查看远程地址的详情信息<ul>\n<li>git remote -v</li>\n</ul>\n</li>\n<li>查看当前别名所对应的远程仓库地址<ul>\n<li>git remote show 别名 </li>\n</ul>\n</li>\n<li>删除当前别名及所对应的远程仓库地址<ul>\n<li>git remote remove 别名 </li>\n</ul>\n</li>\n<li>从远程仓库获取代码(拉取所有版本到本地)<ul>\n<li>git clone 远程仓库地址 项目名称</li>\n<li>使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发</li>\n</ul>\n</li>\n<li>冲突修复<ul>\n<li>模拟冲突<ul>\n<li>张三和李四分别克隆代码到本地</li>\n<li>张三改了demo文件并提交到远端仓库</li>\n<li>李四也改了同一个文件</li>\n<li>这时因为张三已经提交了一版代码到远程仓库</li>\n<li>远程仓库的代码要比李四本地的代码新</li>\n<li>所以李四不能直接向远程仓库推送代码</li>\n<li>要先拉去再推送</li>\n<li>此时因为张三和李四改了同一个文件所以产生了冲突</li>\n<li>李四解决冲突并再次提交代码到远程仓库</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>多人协作开发免登录操作<ul>\n<li>ssh-keygen</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"git使用流程\"><a href=\"#git使用流程\" class=\"headerlink\" title=\"git使用流程\"></a>git使用流程</h3><ul>\n<li>1.配置账户信息<ul>\n<li>git config –global user.name 用户名</li>\n<li>git config –global user.email 邮箱地址</li>\n<li>git config –list 查看当前的git配置</li>\n</ul>\n</li>\n<li>2.初始化本地仓库<ul>\n<li>git init</li>\n</ul>\n</li>\n<li>3.查看本地仓库的状态<ul>\n<li>git status</li>\n</ul>\n</li>\n<li>4.将工作目录中的文件提交到暂存区<ul>\n<li>git add 文件列表</li>\n<li>git add . 添加工作目录中所有的文件到暂存区</li>\n</ul>\n</li>\n<li><ol>\n<li>将暂存区中的代码提交到本地仓库<ul>\n<li>git commit -m 备注</li>\n<li>git commit -m “first commit”</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"git-忽略清单\"><a href=\"#git-忽略清单\" class=\"headerlink\" title=\"git 忽略清单\"></a>git 忽略清单</h3><ul>\n<li>.gitignore文件</li>\n</ul>\n"},{"title":"不是 LeetCode 的01题","date":"2021-02-25T09:04:27.000Z","author":"heyXiao","summary":"非 LeetCode 题目的技术总结","_content":"\n### 判定字符是否唯一 easy\n\n实现一个算法，确定一个字符串 s 的所有字符是否全都不同。\n\n示例 1：\n输入: s = \"leetcode\"\n输出: false\n示例 2：\n输入: s = \"abc\"\n输出: true\n限制：\n0 <= len(s) <= 100\n如果你不使用额外的数据结构，会很加分。\n\n```javascript\n{% raw %}\nvar isUnique = function (astr) {\n  // 哈希表解法\n  if (!astr.length) return true;\n  let hash = {};\n  for (let i = 0; i < astr.length; i++) {\n    // 如果 hash 中已有 则 false\n    if (hash[astr[i]]) {\n      return false;\n    } else {\n      // 否则存储\n      hash[astr[i]] = true;\n    }\n  }\n  // 如果一直没 false\n  return true;\n};\n{% endraw %}\n```\n\n果然很 easy....趁着今天有点闲，再水一博。不过很快就要忙了。\n","source":"_posts/不是LeetCode的01题.md","raw":"---\ntitle: 不是 LeetCode 的01题\ndate: 2021-02-25 17:04:27\nauthor: heyXiao\nsummary: 非 LeetCode 题目的技术总结\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 学习总结\n---\n\n### 判定字符是否唯一 easy\n\n实现一个算法，确定一个字符串 s 的所有字符是否全都不同。\n\n示例 1：\n输入: s = \"leetcode\"\n输出: false\n示例 2：\n输入: s = \"abc\"\n输出: true\n限制：\n0 <= len(s) <= 100\n如果你不使用额外的数据结构，会很加分。\n\n```javascript\n{% raw %}\nvar isUnique = function (astr) {\n  // 哈希表解法\n  if (!astr.length) return true;\n  let hash = {};\n  for (let i = 0; i < astr.length; i++) {\n    // 如果 hash 中已有 则 false\n    if (hash[astr[i]]) {\n      return false;\n    } else {\n      // 否则存储\n      hash[astr[i]] = true;\n    }\n  }\n  // 如果一直没 false\n  return true;\n};\n{% endraw %}\n```\n\n果然很 easy....趁着今天有点闲，再水一博。不过很快就要忙了。\n","slug":"不是LeetCode的01题","published":1,"updated":"2021-02-26T06:00:51.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cp000pksup17j1alsf","content":"<h3 id=\"判定字符是否唯一-easy\"><a href=\"#判定字符是否唯一-easy\" class=\"headerlink\" title=\"判定字符是否唯一 easy\"></a>判定字符是否唯一 easy</h3><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>\n<p>示例 1：<br>输入: s = “leetcode”<br>输出: false<br>示例 2：<br>输入: s = “abc”<br>输出: true<br>限制：<br>0 &lt;= len(s) &lt;= 100<br>如果你不使用额外的数据结构，会很加分。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">var</span> isUnique <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>astr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 哈希表解法</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>astr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> hash <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> astr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 如果 hash 中已有 则 false</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>hash<span class=\"token punctuation\">[</span>astr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 否则存储</span>\n      hash<span class=\"token punctuation\">[</span>astr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\" spellcheck=\"true\">// 如果一直没 false</span>\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>果然很 easy….趁着今天有点闲，再水一博。不过很快就要忙了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"判定字符是否唯一-easy\"><a href=\"#判定字符是否唯一-easy\" class=\"headerlink\" title=\"判定字符是否唯一 easy\"></a>判定字符是否唯一 easy</h3><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p>\n<p>示例 1：<br>输入: s = “leetcode”<br>输出: false<br>示例 2：<br>输入: s = “abc”<br>输出: true<br>限制：<br>0 &lt;= len(s) &lt;= 100<br>如果你不使用额外的数据结构，会很加分。</p>\n<pre><code class=\"javascript\">\nvar isUnique = function (astr) {\n  // 哈希表解法\n  if (!astr.length) return true;\n  let hash = {};\n  for (let i = 0; i < astr.length; i++) {\n    // 如果 hash 中已有 则 false\n    if (hash[astr[i]]) {\n      return false;\n    } else {\n      // 否则存储\n      hash[astr[i]] = true;\n    }\n  }\n  // 如果一直没 false\n  return true;\n};\n</code></pre>\n<p>果然很 easy….趁着今天有点闲，再水一博。不过很快就要忙了。</p>\n"},{"title":"不是 LeetCode 的02题","date":"2021-03-10T04:33:40.000Z","author":"heyXiao","summary":"非 LeetCode 题目的技术总结","_content":"\n### 零矩阵 medium\n\n实现一个算法，若 M * N 矩阵中某个元素为 0，则将其所在的行列清零\n\n示例 1：\n输入:\n[\n[1,1,1],\n[1,0,1],\n[1,1,1]\n]\n输出:\n[\n[1,0,1],\n[0,0,0],\n[1,0,1]\n]\n\n示例 2：\n输入:\n[\n[0,1,2,3],\n[4,5,6,7],\n[8,9,1,0]\n]\n输出:\n[\n[0,0,0,0],\n[0,5,6,0],\n[0,0,0,0]\n]\n\n```javascript\n{% raw %}\nvar setZero = function(matrix) {\n    // 标记出来所有需要清零的行和列\n    let row = new Set();\n    let col = new Set();\n    // 循环矩阵 存储行列\n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            if (matrix[i][j] == 0) {\n                row.add(i);\n                col.add(j);\n            }\n        }\n    }\n    console.log(row, col);\n    // 行清零\n    // row[i] 为行数，matrix[row[i]] 为所在行，matrix[row[i]][j] 为所在行的每一个数\n    // matrix[0].length 为矩阵宽度\n    row = Array.from(row);\n    for (let i = 0; i < row.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            matrix[row[i]][j] = 0;\n        }\n    }\n    // 列清零\n    // col[i] 为列数，[col[i]] 为所在列，matrix[j][col[i]] 为所在列的每一个数\n    col = Array.from(col);\n    for (let i = 0; i < col.length; i++) {\n        for (let j = 0; j < matrix.length; j++) {\n            matrix[j][col[i]] = 0;\n        }\n    }\n    console.log(matrix);\n    return matrix;\n};\n{% endraw %}\n```\n<p style=\"text-indent:2em\">最近有在思考职业发展，感觉现在的公司业务面窄，技术栈单一，对个人综合提升没有多大帮助。打算跳一个中大厂吧，要认真努力，看看自己目前能达到的最高的位置。</p>\n<p style=\"text-indent:2em\">今天没有修改的话，下午应该还会做一篇 easy。</p>\n","source":"_posts/不是LeetCode的02题.md","raw":"---\ntitle: 不是 LeetCode 的02题\ndate: 2021-03-10 12:33:40\nauthor: heyXiao\nsummary: 非 LeetCode 题目的技术总结\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 学习总结\n---\n\n### 零矩阵 medium\n\n实现一个算法，若 M * N 矩阵中某个元素为 0，则将其所在的行列清零\n\n示例 1：\n输入:\n[\n[1,1,1],\n[1,0,1],\n[1,1,1]\n]\n输出:\n[\n[1,0,1],\n[0,0,0],\n[1,0,1]\n]\n\n示例 2：\n输入:\n[\n[0,1,2,3],\n[4,5,6,7],\n[8,9,1,0]\n]\n输出:\n[\n[0,0,0,0],\n[0,5,6,0],\n[0,0,0,0]\n]\n\n```javascript\n{% raw %}\nvar setZero = function(matrix) {\n    // 标记出来所有需要清零的行和列\n    let row = new Set();\n    let col = new Set();\n    // 循环矩阵 存储行列\n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            if (matrix[i][j] == 0) {\n                row.add(i);\n                col.add(j);\n            }\n        }\n    }\n    console.log(row, col);\n    // 行清零\n    // row[i] 为行数，matrix[row[i]] 为所在行，matrix[row[i]][j] 为所在行的每一个数\n    // matrix[0].length 为矩阵宽度\n    row = Array.from(row);\n    for (let i = 0; i < row.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            matrix[row[i]][j] = 0;\n        }\n    }\n    // 列清零\n    // col[i] 为列数，[col[i]] 为所在列，matrix[j][col[i]] 为所在列的每一个数\n    col = Array.from(col);\n    for (let i = 0; i < col.length; i++) {\n        for (let j = 0; j < matrix.length; j++) {\n            matrix[j][col[i]] = 0;\n        }\n    }\n    console.log(matrix);\n    return matrix;\n};\n{% endraw %}\n```\n<p style=\"text-indent:2em\">最近有在思考职业发展，感觉现在的公司业务面窄，技术栈单一，对个人综合提升没有多大帮助。打算跳一个中大厂吧，要认真努力，看看自己目前能达到的最高的位置。</p>\n<p style=\"text-indent:2em\">今天没有修改的话，下午应该还会做一篇 easy。</p>\n","slug":"不是LeetCode的02题","published":1,"updated":"2021-03-10T03:34:39.102Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cq000uksup3r9z2cj8","content":"<h3 id=\"零矩阵-medium\"><a href=\"#零矩阵-medium\" class=\"headerlink\" title=\"零矩阵 medium\"></a>零矩阵 medium</h3><p>实现一个算法，若 M * N 矩阵中某个元素为 0，则将其所在的行列清零</p>\n<p>示例 1：<br>输入:<br>[<br>[1,1,1],<br>[1,0,1],<br>[1,1,1]<br>]<br>输出:<br>[<br>[1,0,1],<br>[0,0,0],<br>[1,0,1]<br>]</p>\n<p>示例 2：<br>输入:<br>[<br>[0,1,2,3],<br>[4,5,6,7],<br>[8,9,1,0]<br>]<br>输出:<br>[<br>[0,0,0,0],<br>[0,5,6,0],<br>[0,0,0,0]<br>]</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">var</span> setZero <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 标记出来所有需要清零的行和列</span>\n    <span class=\"token keyword\">let</span> row <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> col <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 循环矩阵 存储行列</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> matrix<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                row<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                col<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">,</span> col<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 行清零</span>\n    <span class=\"token comment\" spellcheck=\"true\">// row[i] 为行数，matrix[row[i]] 为所在行，matrix[row[i]][j] 为所在行的每一个数</span>\n    <span class=\"token comment\" spellcheck=\"true\">// matrix[0].length 为矩阵宽度</span>\n    row <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>row<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> row<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> matrix<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            matrix<span class=\"token punctuation\">[</span>row<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 列清零</span>\n    <span class=\"token comment\" spellcheck=\"true\">// col[i] 为列数，[col[i]] 为所在列，matrix[j][col[i]] 为所在列的每一个数</span>\n    col <span class=\"token operator\">=</span> Array<span class=\"token punctuation\">.</span><span class=\"token keyword\">from</span><span class=\"token punctuation\">(</span>col<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> col<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> matrix<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            matrix<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span>col<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>matrix<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> matrix<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p style=\"text-indent:2em\">最近有在思考职业发展，感觉现在的公司业务面窄，技术栈单一，对个人综合提升没有多大帮助。打算跳一个中大厂吧，要认真努力，看看自己目前能达到的最高的位置。</p>\n<p style=\"text-indent:2em\">今天没有修改的话，下午应该还会做一篇 easy。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"零矩阵-medium\"><a href=\"#零矩阵-medium\" class=\"headerlink\" title=\"零矩阵 medium\"></a>零矩阵 medium</h3><p>实现一个算法，若 M * N 矩阵中某个元素为 0，则将其所在的行列清零</p>\n<p>示例 1：<br>输入:<br>[<br>[1,1,1],<br>[1,0,1],<br>[1,1,1]<br>]<br>输出:<br>[<br>[1,0,1],<br>[0,0,0],<br>[1,0,1]<br>]</p>\n<p>示例 2：<br>输入:<br>[<br>[0,1,2,3],<br>[4,5,6,7],<br>[8,9,1,0]<br>]<br>输出:<br>[<br>[0,0,0,0],<br>[0,5,6,0],<br>[0,0,0,0]<br>]</p>\n<pre><code class=\"javascript\">\nvar setZero = function(matrix) {\n    // 标记出来所有需要清零的行和列\n    let row = new Set();\n    let col = new Set();\n    // 循环矩阵 存储行列\n    for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            if (matrix[i][j] == 0) {\n                row.add(i);\n                col.add(j);\n            }\n        }\n    }\n    console.log(row, col);\n    // 行清零\n    // row[i] 为行数，matrix[row[i]] 为所在行，matrix[row[i]][j] 为所在行的每一个数\n    // matrix[0].length 为矩阵宽度\n    row = Array.from(row);\n    for (let i = 0; i < row.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            matrix[row[i]][j] = 0;\n        }\n    }\n    // 列清零\n    // col[i] 为列数，[col[i]] 为所在列，matrix[j][col[i]] 为所在列的每一个数\n    col = Array.from(col);\n    for (let i = 0; i < col.length; i++) {\n        for (let j = 0; j < matrix.length; j++) {\n            matrix[j][col[i]] = 0;\n        }\n    }\n    console.log(matrix);\n    return matrix;\n};\n</code></pre>\n<p style=\"text-indent:2em\">最近有在思考职业发展，感觉现在的公司业务面窄，技术栈单一，对个人综合提升没有多大帮助。打算跳一个中大厂吧，要认真努力，看看自己目前能达到的最高的位置。</p>\n<p style=\"text-indent:2em\">今天没有修改的话，下午应该还会做一篇 easy。</p>\n"},{"title":"不是 LeetCode 的03题","date":"2021-03-19T02:30:40.000Z","author":"heyXiao","summary":"非 LeetCode 题目的技术总结","_content":"\n### 字符串轮转 easy\n\n给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成。\n\n示例\n\n输入：s1 = 'abcd', s2 = 'cdab'\n输出：True\n\n输入：s1 = 'abcd', s2 = 'bcad'\n输出：False\n\n```javascript\n{% raw %}\nvar isCircle = functionn(s1 , s2){\n    if(s1.length !== s2.length){\n        return false;\n    }\n    if(s1 == s2){\n        return true;\n    }\n    s1 += s1;\n    return s1.indexOf(s2) > =0;\n}\n{% endraw %}\n```\n<p style=\"text-indent:2em\">233333超简单的一题，把 s1 再拼接一下，判断 indexOf 为正就可以了。写总结也要划水，不愧是我了。</p>\n<p style=\"text-indent:2em\">下午如果没事应该再来一篇，可能也是划水~</p>\n","source":"_posts/不是LeetCode的03题.md","raw":"---\ntitle: 不是 LeetCode 的03题\ndate: 2021-03-19 10:30:40\nauthor: heyXiao\nsummary: 非 LeetCode 题目的技术总结\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 学习总结\n---\n\n### 字符串轮转 easy\n\n给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成。\n\n示例\n\n输入：s1 = 'abcd', s2 = 'cdab'\n输出：True\n\n输入：s1 = 'abcd', s2 = 'bcad'\n输出：False\n\n```javascript\n{% raw %}\nvar isCircle = functionn(s1 , s2){\n    if(s1.length !== s2.length){\n        return false;\n    }\n    if(s1 == s2){\n        return true;\n    }\n    s1 += s1;\n    return s1.indexOf(s2) > =0;\n}\n{% endraw %}\n```\n<p style=\"text-indent:2em\">233333超简单的一题，把 s1 再拼接一下，判断 indexOf 为正就可以了。写总结也要划水，不愧是我了。</p>\n<p style=\"text-indent:2em\">下午如果没事应该再来一篇，可能也是划水~</p>\n","slug":"不是LeetCode的03题","published":1,"updated":"2021-03-19T02:40:20.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cr000wksup67me2q2w","content":"<h3 id=\"字符串轮转-easy\"><a href=\"#字符串轮转-easy\" class=\"headerlink\" title=\"字符串轮转 easy\"></a>字符串轮转 easy</h3><p>给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成。</p>\n<p>示例</p>\n<p>输入：s1 = ‘abcd’, s2 = ‘cdab’<br>输出：True</p>\n<p>输入：s1 = ‘abcd’, s2 = ‘bcad’<br>输出：False</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">var</span> isCircle <span class=\"token operator\">=</span> <span class=\"token function\">functionn</span><span class=\"token punctuation\">(</span>s1 <span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">!==</span> s2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>s1 <span class=\"token operator\">==</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    s1 <span class=\"token operator\">+</span><span class=\"token operator\">=</span> s1<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span>s2<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<p style=\"text-indent:2em\">233333超简单的一题，把 s1 再拼接一下，判断 indexOf 为正就可以了。写总结也要划水，不愧是我了。</p>\n<p style=\"text-indent:2em\">下午如果没事应该再来一篇，可能也是划水~</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"字符串轮转-easy\"><a href=\"#字符串轮转-easy\" class=\"headerlink\" title=\"字符串轮转 easy\"></a>字符串轮转 easy</h3><p>给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成。</p>\n<p>示例</p>\n<p>输入：s1 = ‘abcd’, s2 = ‘cdab’<br>输出：True</p>\n<p>输入：s1 = ‘abcd’, s2 = ‘bcad’<br>输出：False</p>\n<pre><code class=\"javascript\">\nvar isCircle = functionn(s1 , s2){\n    if(s1.length !== s2.length){\n        return false;\n    }\n    if(s1 == s2){\n        return true;\n    }\n    s1 += s1;\n    return s1.indexOf(s2) > =0;\n}\n</code></pre>\n<p style=\"text-indent:2em\">233333超简单的一题，把 s1 再拼接一下，判断 indexOf 为正就可以了。写总结也要划水，不愧是我了。</p>\n<p style=\"text-indent:2em\">下午如果没事应该再来一篇，可能也是划水~</p>\n"},{"title":"不是 LeetCode 的07题","date":"2021-03-31T08:53:26.000Z","author":"heyXiao","summary":"非 LeetCode 题目的技术总结","_content":"\n### 最后一块石头的重量 easy\n\n有一堆石头，每块石头的重量都是正整数。\n每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，并且 x <= y。那么粉碎的可能结果如下\n如果 x == y，那么两块石头都会被完全粉碎；\n如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y - x。\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。\n\n提示：\n1 <= stones.length <= 30\n1 <= stones[i] <= 1000\n\n```javascript\n{% raw %}\nvar lastStone = function(stones) {\n    let fn = (arr) => {\n        if(arr.length === 1){\n            return arr[0]\n        }\n        if(arr.length === 2){\n            return arr[0] === arr[1] ? 0 : fn([Math.abs(arr[0] - arr[1])]);\n        }\n        arr.sotr((a,b) => {\n            return b - a;\n        })\n        if(arr[0] === arr[1]){\n            return fn(arr.slice(2));\n        }else{\n            let a = arr.slice(2);\n            a.push(Math.abs(arr[0] - arr[1]));\n            return fn(a);\n        }\n    };\n    return fn(stones)\n};\nconsole.log(lastStone([2, 7, 4, 1, 8, 1]));\n{% endraw %}\n```\n<p style=\"text-indent:2em\">本来今天不想写的，很烦，3月的最后一天。</p>\n","source":"_posts/不是LeetCode的07题.md","raw":"---\ntitle: 不是 LeetCode 的07题\ndate: 2021-03-31 16:53:26\nauthor: heyXiao\nsummary: 非 LeetCode 题目的技术总结\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 学习总结\n---\n\n### 最后一块石头的重量 easy\n\n有一堆石头，每块石头的重量都是正整数。\n每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，并且 x <= y。那么粉碎的可能结果如下\n如果 x == y，那么两块石头都会被完全粉碎；\n如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y - x。\n最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。\n\n提示：\n1 <= stones.length <= 30\n1 <= stones[i] <= 1000\n\n```javascript\n{% raw %}\nvar lastStone = function(stones) {\n    let fn = (arr) => {\n        if(arr.length === 1){\n            return arr[0]\n        }\n        if(arr.length === 2){\n            return arr[0] === arr[1] ? 0 : fn([Math.abs(arr[0] - arr[1])]);\n        }\n        arr.sotr((a,b) => {\n            return b - a;\n        })\n        if(arr[0] === arr[1]){\n            return fn(arr.slice(2));\n        }else{\n            let a = arr.slice(2);\n            a.push(Math.abs(arr[0] - arr[1]));\n            return fn(a);\n        }\n    };\n    return fn(stones)\n};\nconsole.log(lastStone([2, 7, 4, 1, 8, 1]));\n{% endraw %}\n```\n<p style=\"text-indent:2em\">本来今天不想写的，很烦，3月的最后一天。</p>\n","slug":"不是LeetCode的07题","published":1,"updated":"2021-03-31T08:53:32.067Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cs0010ksupe0x884tx","content":"<h3 id=\"最后一块石头的重量-easy\"><a href=\"#最后一块石头的重量-easy\" class=\"headerlink\" title=\"最后一块石头的重量 easy\"></a>最后一块石头的重量 easy</h3><p>有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，并且 x &lt;= y。那么粉碎的可能结果如下<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y - x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p>\n<p>提示：<br>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">var</span> lastStone <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>stones<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> fn <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        arr<span class=\"token punctuation\">.</span><span class=\"token function\">sotr</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> b <span class=\"token operator\">-</span> a<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            a<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">abs</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> arr<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>stones<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">lastStone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p style=\"text-indent:2em\">本来今天不想写的，很烦，3月的最后一天。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"最后一块石头的重量-easy\"><a href=\"#最后一块石头的重量-easy\" class=\"headerlink\" title=\"最后一块石头的重量 easy\"></a>最后一块石头的重量 easy</h3><p>有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，并且 x &lt;= y。那么粉碎的可能结果如下<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y - x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。</p>\n<p>提示：<br>1 &lt;= stones.length &lt;= 30<br>1 &lt;= stones[i] &lt;= 1000</p>\n<pre><code class=\"javascript\">\nvar lastStone = function(stones) {\n    let fn = (arr) => {\n        if(arr.length === 1){\n            return arr[0]\n        }\n        if(arr.length === 2){\n            return arr[0] === arr[1] ? 0 : fn([Math.abs(arr[0] - arr[1])]);\n        }\n        arr.sotr((a,b) => {\n            return b - a;\n        })\n        if(arr[0] === arr[1]){\n            return fn(arr.slice(2));\n        }else{\n            let a = arr.slice(2);\n            a.push(Math.abs(arr[0] - arr[1]));\n            return fn(a);\n        }\n    };\n    return fn(stones)\n};\nconsole.log(lastStone([2, 7, 4, 1, 8, 1]));\n</code></pre>\n<p style=\"text-indent:2em\">本来今天不想写的，很烦，3月的最后一天。</p>\n"},{"title":"这是我的第一篇博客","date":"2020-10-22T05:25:00.000Z","author":"heyXiao","summary":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。","_content":"# 这是我的第一篇博客\n\n- **Markdown和扩展Markdown简洁的语法**\n- **代码块高亮**\n- **图片链接和图片上传**\n- ***LaTex*数学公式**\n- **UML序列图和流程图**\n- **离线写博客**\n- **导入导出Markdown文件**\n- **丰富的快捷键**\n\n-------------------\n\n## 快捷键\n\n - 加粗    `Ctrl + B` \n - 斜体    `Ctrl + I` \n - 引用    `Ctrl + Q`\n - 插入链接    `Ctrl + L`\n - 插入代码    `Ctrl + K`\n - 插入图片    `Ctrl + G`\n - 提升标题    `Ctrl + H`\n - 有序列表    `Ctrl + O`\n - 无序列表    `Ctrl + U`\n - 横线    `Ctrl + R`\n - 撤销    `Ctrl + Z`\n - 重做    `Ctrl + Y`\n\n## Markdown及扩展\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]\n\n使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.csdn.net)等，详细语法参考帮助？。\n\n本编辑器支持 **Markdown Extra** , 　扩展了很多好用的功能。具体请参考[Github][2].  \n\n### 表格\n\n**Markdown　Extra**　表格语法：\n\n项目     | 价格\n-------- | ---\nComputer | $1600\nPhone    | $12\nPipe     | $1\n\n可以使用冒号来定义对齐方式：\n\n| 项目      |    价格 | 数量  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 元 |  5   |\n| Phone     |   12 元 |  12  |\n| Pipe      |    1 元 | 234  |\n\n###定义列表\n\n**Markdown　Extra**　定义列表语法：\n项目１\n项目２\n:   定义 A\n:   定义 B\n\n项目３\n:   定义 C\n\n:   定义 D\n\n\t> 定义D内容\n\n### 代码块\n代码块语法遵循标准markdown代码，例如：\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n>>> message = '''interpreter\n... prompt'''\n```\n\n###脚注\n生成一个脚注[^footnote].\n  [^footnote]: 这里是 **脚注** 的 *内容*.\n  \n### 目录\n用 `[TOC]`来生成目录：\n\n@[toc]\n### 数学公式\n使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].\n\n - 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。\n - 块级公式：\n\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n更多LaTex语法请参考 [这儿][3].\n\n### UML 图:\n\n可以渲染序列图：\n\n```mermaid\nsequenceDiagram\n张三->>李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->>张三: 忙得吐血，哪有时间写。\n```\n\n或者流程图：\n\n```mermaid\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n- 关于 **序列图** 语法，参考 [这儿][4],\n- 关于 **流程图** 语法，参考 [这儿][5].\n\n## 离线写博客\n\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入[write.blog.csdn.net/mdeditor](http://write.blog.csdn.net/mdeditor)即可。**Markdown编辑器**使用浏览器离线存储将内容保存在本地。\n\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\n\n博客发表后，本地缓存将被删除。　\n\n用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\n\n> **注意：**虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，**请务必及时发表或者保存到服务器草稿箱**。\n\n##浏览器兼容\n\n 1. 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。\n 3. IE９以下不支持\n 4. IE９，１０，１１存在以下问题\n    1. 不支持离线功能\n    1. IE9不支持文件导入导出\n    1. IE10不支持拖拽文件导入\n\n---------\n\n[1]: http://math.stackexchange.com/\n[2]: https://github.com/jmcmanus/pagedown-extra \"Pagedown Extra\"\n[3]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n[4]: http://bramp.github.io/js-sequence-diagrams/\n[5]: http://adrai.github.io/flowchart.js/\n[6]: https://github.com/benweet/stackedit\n","source":"_posts/使用CSDN-markdown编辑器.md","raw":"---\ntitle: 这是我的第一篇博客\ndate: 2020-10-22 13:25:00\nauthor: heyXiao\nsummary: Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。\ncategories: Markdown\ntags:\n  - Typora\n  - Markdown\n---\n# 这是我的第一篇博客\n\n- **Markdown和扩展Markdown简洁的语法**\n- **代码块高亮**\n- **图片链接和图片上传**\n- ***LaTex*数学公式**\n- **UML序列图和流程图**\n- **离线写博客**\n- **导入导出Markdown文件**\n- **丰富的快捷键**\n\n-------------------\n\n## 快捷键\n\n - 加粗    `Ctrl + B` \n - 斜体    `Ctrl + I` \n - 引用    `Ctrl + Q`\n - 插入链接    `Ctrl + L`\n - 插入代码    `Ctrl + K`\n - 插入图片    `Ctrl + G`\n - 提升标题    `Ctrl + H`\n - 有序列表    `Ctrl + O`\n - 无序列表    `Ctrl + U`\n - 横线    `Ctrl + R`\n - 撤销    `Ctrl + Z`\n - 重做    `Ctrl + Y`\n\n## Markdown及扩展\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]\n\n使用简单的符号标识不同的标题，将某些文字标记为**粗体**或者*斜体*，创建一个[链接](http://www.csdn.net)等，详细语法参考帮助？。\n\n本编辑器支持 **Markdown Extra** , 　扩展了很多好用的功能。具体请参考[Github][2].  \n\n### 表格\n\n**Markdown　Extra**　表格语法：\n\n项目     | 价格\n-------- | ---\nComputer | $1600\nPhone    | $12\nPipe     | $1\n\n可以使用冒号来定义对齐方式：\n\n| 项目      |    价格 | 数量  |\n| :-------- | --------:| :--: |\n| Computer  | 1600 元 |  5   |\n| Phone     |   12 元 |  12  |\n| Pipe      |    1 元 | 234  |\n\n###定义列表\n\n**Markdown　Extra**　定义列表语法：\n项目１\n项目２\n:   定义 A\n:   定义 B\n\n项目３\n:   定义 C\n\n:   定义 D\n\n\t> 定义D内容\n\n### 代码块\n代码块语法遵循标准markdown代码，例如：\n```python\n@requires_authorization\ndef somefunc(param1='', param2=0):\n    '''A docstring'''\n    if param1 > param2: # interesting\n        print 'Greater'\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n>>> message = '''interpreter\n... prompt'''\n```\n\n###脚注\n生成一个脚注[^footnote].\n  [^footnote]: 这里是 **脚注** 的 *内容*.\n  \n### 目录\n用 `[TOC]`来生成目录：\n\n@[toc]\n### 数学公式\n使用MathJax渲染*LaTex* 数学公式，详见[math.stackexchange.com][1].\n\n - 行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。\n - 块级公式：\n\n$$\tx = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$\n\n更多LaTex语法请参考 [这儿][3].\n\n### UML 图:\n\n可以渲染序列图：\n\n```mermaid\nsequenceDiagram\n张三->>李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->>张三: 忙得吐血，哪有时间写。\n```\n\n或者流程图：\n\n```mermaid\nflowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op\n```\n\n- 关于 **序列图** 语法，参考 [这儿][4],\n- 关于 **流程图** 语法，参考 [这儿][5].\n\n## 离线写博客\n\n即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入[write.blog.csdn.net/mdeditor](http://write.blog.csdn.net/mdeditor)即可。**Markdown编辑器**使用浏览器离线存储将内容保存在本地。\n\n用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。\n\n博客发表后，本地缓存将被删除。　\n\n用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。\n\n> **注意：**虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，**请务必及时发表或者保存到服务器草稿箱**。\n\n##浏览器兼容\n\n 1. 目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。\n 3. IE９以下不支持\n 4. IE９，１０，１１存在以下问题\n    1. 不支持离线功能\n    1. IE9不支持文件导入导出\n    1. IE10不支持拖拽文件导入\n\n---------\n\n[1]: http://math.stackexchange.com/\n[2]: https://github.com/jmcmanus/pagedown-extra \"Pagedown Extra\"\n[3]: http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\n[4]: http://bramp.github.io/js-sequence-diagrams/\n[5]: http://adrai.github.io/flowchart.js/\n[6]: https://github.com/benweet/stackedit\n","slug":"使用CSDN-markdown编辑器","published":1,"updated":"2020-11-07T07:29:09.539Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0ct0011ksupdxx1bpxn","content":"<h1 id=\"这是我的第一篇博客\"><a href=\"#这是我的第一篇博客\" class=\"headerlink\" title=\"这是我的第一篇博客\"></a>这是我的第一篇博客</h1><ul>\n<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>\n<li><strong>代码块高亮</strong></li>\n<li><strong>图片链接和图片上传</strong></li>\n<li><strong><em>LaTex</em>数学公式</strong></li>\n<li><strong>UML序列图和流程图</strong></li>\n<li><strong>离线写博客</strong></li>\n<li><strong>导入导出Markdown文件</strong></li>\n<li><strong>丰富的快捷键</strong></li>\n</ul>\n<hr>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><ul>\n<li>加粗    <code>Ctrl + B</code> </li>\n<li>斜体    <code>Ctrl + I</code> </li>\n<li>引用    <code>Ctrl + Q</code></li>\n<li>插入链接    <code>Ctrl + L</code></li>\n<li>插入代码    <code>Ctrl + K</code></li>\n<li>插入图片    <code>Ctrl + G</code></li>\n<li>提升标题    <code>Ctrl + H</code></li>\n<li>有序列表    <code>Ctrl + O</code></li>\n<li>无序列表    <code>Ctrl + U</code></li>\n<li>横线    <code>Ctrl + R</code></li>\n<li>撤销    <code>Ctrl + Z</code></li>\n<li>重做    <code>Ctrl + Y</code></li>\n</ul>\n<h2 id=\"Markdown及扩展\"><a href=\"#Markdown及扩展\" class=\"headerlink\" title=\"Markdown及扩展\"></a>Markdown及扩展</h2><blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]</p>\n</blockquote>\n<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.csdn.net/\">链接</a>等，详细语法参考帮助？。</p>\n<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href=\"https://github.com/jmcmanus/pagedown-extra\" title=\"Pagedown Extra\">Github</a>.  </p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Computer</td>\n<td>$1600</td>\n</tr>\n<tr>\n<td>Phone</td>\n<td>$12</td>\n</tr>\n<tr>\n<td>Pipe</td>\n<td>$1</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Computer</td>\n<td align=\"right\">1600 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">Phone</td>\n<td align=\"right\">12 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">Pipe</td>\n<td align=\"right\">1 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<p>###定义列表</p>\n<dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p>\n<pre><code>&gt; 定义D内容</code></pre>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>\n<pre class=\" language-python\"><code class=\"language-python\">@requires_authorization\n<span class=\"token keyword\">def</span> <span class=\"token function\">somefunc</span><span class=\"token punctuation\">(</span>param1<span class=\"token operator\">=</span><span class=\"token string\">''</span><span class=\"token punctuation\">,</span> param2<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token triple-quoted-string string\">'''A docstring'''</span>\n    <span class=\"token keyword\">if</span> param1 <span class=\"token operator\">></span> param2<span class=\"token punctuation\">:</span> <span class=\"token comment\" spellcheck=\"true\"># interesting</span>\n        <span class=\"token keyword\">print</span> <span class=\"token string\">'Greater'</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>param2 <span class=\"token operator\">-</span> param1 <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">or</span> None\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">SomeClass</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">pass</span>\n<span class=\"token operator\">>></span><span class=\"token operator\">></span> message <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">'''interpreter\n... prompt'''</span></code></pre>\n<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>\n<p>@[toc]</p>\n<h3 id=\"数学公式\"><a href=\"#数学公式\" class=\"headerlink\" title=\"数学公式\"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href=\"http://math.stackexchange.com/\">math.stackexchange.com</a>.</p>\n<ul>\n<li>行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。</li>\n<li>块级公式：</li>\n</ul>\n<p>$$    x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p>\n<p>更多LaTex语法请参考 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">这儿</a>.</p>\n<h3 id=\"UML-图\"><a href=\"#UML-图\" class=\"headerlink\" title=\"UML 图:\"></a>UML 图:</h3><p>可以渲染序列图：</p>\n<pre class=\" language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n张三->>李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四-->>张三: 忙得吐血，哪有时间写。</code></pre>\n<p>或者流程图：</p>\n<pre class=\" language-mermaid\"><code class=\"language-mermaid\">flowchat\nst=>start: 开始\ne=>end: 结束\nop=>operation: 我的操作\ncond=>condition: 确认？\n\nst->op->cond\ncond(yes)->e\ncond(no)->op</code></pre>\n<ul>\n<li>关于 <strong>序列图</strong> 语法，参考 <a href=\"http://bramp.github.io/js-sequence-diagrams/\">这儿</a>,</li>\n<li>关于 <strong>流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"离线写博客\"><a href=\"#离线写博客\" class=\"headerlink\" title=\"离线写博客\"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href=\"http://write.blog.csdn.net/mdeditor\">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>\n<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>\n<p>博客发表后，本地缓存将被删除。　</p>\n<p>用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>\n<blockquote>\n<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>\n</blockquote>\n<p>##浏览器兼容</p>\n<ol>\n<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>\n<li>IE９以下不支持</li>\n<li>IE９，１０，１１存在以下问题<ol>\n<li>不支持离线功能</li>\n<li>IE9不支持文件导入导出</li>\n<li>IE10不支持拖拽文件导入</li>\n</ol>\n</li>\n</ol>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这是我的第一篇博客\"><a href=\"#这是我的第一篇博客\" class=\"headerlink\" title=\"这是我的第一篇博客\"></a>这是我的第一篇博客</h1><ul>\n<li><strong>Markdown和扩展Markdown简洁的语法</strong></li>\n<li><strong>代码块高亮</strong></li>\n<li><strong>图片链接和图片上传</strong></li>\n<li><strong><em>LaTex</em>数学公式</strong></li>\n<li><strong>UML序列图和流程图</strong></li>\n<li><strong>离线写博客</strong></li>\n<li><strong>导入导出Markdown文件</strong></li>\n<li><strong>丰富的快捷键</strong></li>\n</ul>\n<hr>\n<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><ul>\n<li>加粗    <code>Ctrl + B</code> </li>\n<li>斜体    <code>Ctrl + I</code> </li>\n<li>引用    <code>Ctrl + Q</code></li>\n<li>插入链接    <code>Ctrl + L</code></li>\n<li>插入代码    <code>Ctrl + K</code></li>\n<li>插入图片    <code>Ctrl + G</code></li>\n<li>提升标题    <code>Ctrl + H</code></li>\n<li>有序列表    <code>Ctrl + O</code></li>\n<li>无序列表    <code>Ctrl + U</code></li>\n<li>横线    <code>Ctrl + R</code></li>\n<li>撤销    <code>Ctrl + Z</code></li>\n<li>重做    <code>Ctrl + Y</code></li>\n</ul>\n<h2 id=\"Markdown及扩展\"><a href=\"#Markdown及扩展\" class=\"headerlink\" title=\"Markdown及扩展\"></a>Markdown及扩展</h2><blockquote>\n<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href=\"https://zh.wikipedia.org/wiki/Markdown\" target=\"_blank\"> [ 维基百科 ]</p>\n</blockquote>\n<p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href=\"http://www.csdn.net/\">链接</a>等，详细语法参考帮助？。</p>\n<p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href=\"https://github.com/jmcmanus/pagedown-extra\" title=\"Pagedown Extra\">Github</a>.  </p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p>\n<table>\n<thead>\n<tr>\n<th>项目</th>\n<th>价格</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Computer</td>\n<td>$1600</td>\n</tr>\n<tr>\n<td>Phone</td>\n<td>$12</td>\n</tr>\n<tr>\n<td>Pipe</td>\n<td>$1</td>\n</tr>\n</tbody></table>\n<p>可以使用冒号来定义对齐方式：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">项目</th>\n<th align=\"right\">价格</th>\n<th align=\"center\">数量</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Computer</td>\n<td align=\"right\">1600 元</td>\n<td align=\"center\">5</td>\n</tr>\n<tr>\n<td align=\"left\">Phone</td>\n<td align=\"right\">12 元</td>\n<td align=\"center\">12</td>\n</tr>\n<tr>\n<td align=\"left\">Pipe</td>\n<td align=\"right\">1 元</td>\n<td align=\"center\">234</td>\n</tr>\n</tbody></table>\n<p>###定义列表</p>\n<dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p>\n<pre><code>&gt; 定义D内容</code></pre>\n<h3 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p>\n<pre><code class=\"python\">@requires_authorization\ndef somefunc(param1=&#39;&#39;, param2=0):\n    &#39;&#39;&#39;A docstring&#39;&#39;&#39;\n    if param1 &gt; param2: # interesting\n        print &#39;Greater&#39;\n    return (param2 - param1 + 1) or None\nclass SomeClass:\n    pass\n&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter\n... prompt&#39;&#39;&#39;</code></pre>\n<p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p>\n<p>@[toc]</p>\n<h3 id=\"数学公式\"><a href=\"#数学公式\" class=\"headerlink\" title=\"数学公式\"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href=\"http://math.stackexchange.com/\">math.stackexchange.com</a>.</p>\n<ul>\n<li>行内公式，数学公式为：$\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$。</li>\n<li>块级公式：</li>\n</ul>\n<p>$$    x = \\dfrac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} $$</p>\n<p>更多LaTex语法请参考 <a href=\"http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference\">这儿</a>.</p>\n<h3 id=\"UML-图\"><a href=\"#UML-图\" class=\"headerlink\" title=\"UML 图:\"></a>UML 图:</h3><p>可以渲染序列图：</p>\n<pre><code class=\"mermaid\">sequenceDiagram\n张三-&gt;&gt;李四: 嘿，小四儿, 写博客了没?\nNote right of 李四: 李四愣了一下，说：\n李四--&gt;&gt;张三: 忙得吐血，哪有时间写。</code></pre>\n<p>或者流程图：</p>\n<pre><code class=\"mermaid\">flowchat\nst=&gt;start: 开始\ne=&gt;end: 结束\nop=&gt;operation: 我的操作\ncond=&gt;condition: 确认？\n\nst-&gt;op-&gt;cond\ncond(yes)-&gt;e\ncond(no)-&gt;op</code></pre>\n<ul>\n<li>关于 <strong>序列图</strong> 语法，参考 <a href=\"http://bramp.github.io/js-sequence-diagrams/\">这儿</a>,</li>\n<li>关于 <strong>流程图</strong> 语法，参考 <a href=\"http://adrai.github.io/flowchart.js/\">这儿</a>.</li>\n</ul>\n<h2 id=\"离线写博客\"><a href=\"#离线写博客\" class=\"headerlink\" title=\"离线写博客\"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href=\"http://write.blog.csdn.net/mdeditor\">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p>\n<p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p>\n<p>博客发表后，本地缓存将被删除。　</p>\n<p>用户可以选择 <i class=\"icon-disk\"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p>\n<blockquote>\n<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p>\n</blockquote>\n<p>##浏览器兼容</p>\n<ol>\n<li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li>\n<li>IE９以下不支持</li>\n<li>IE９，１０，１１存在以下问题<ol>\n<li>不支持离线功能</li>\n<li>IE9不支持文件导入导出</li>\n<li>IE10不支持拖拽文件导入</li>\n</ol>\n</li>\n</ol>\n<hr>\n"},{"title":"不是 LeetCode 的 04&05 题","date":"2021-03-22T05:37:56.000Z","author":"heyXiao","summary":"非 LeetCode 题目的技术总结","_content":"\n### 斐波那契 easy\n\n斐波那契数，通常用 F(n) 表示，行程的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), 其中 n > 1\n\n示例1：\n输入：2\n输出：1\nF(2) = F(1) + F(0) = 1 + 0 = 1\n\n示例2：\n输入：3\n输出：2\nF(3) = F(2) + F(1) = 1 + 1 = 2\n\n示例2：\n输入：4\n输出：3\nF(4) = F(3) + F(2) = 2 + 1 = 3\n\n```javascript\n{% raw %}\nfunction fib(n) {\n  if(n === 0){\n    return 0\n  }\n  if(n === 2 || n===1){\n    return 1;\n  }\n  let preOne = 1;\n  let preTwo = 1;\n  let result = 0;\n  for(let i = 3; i <= n; i++){\n    result = preOne + preTwo;\n    preOne = preTwo;\n    preTwo = result;\n  }\n  return result;\n}\n{% endraw %}\n```\n\n### 冒泡排序 easy\n\n比较相邻的两个元素，如果前一个比后一个大，则交换位置。\n比较完第一轮的时候，最后一个元素是最大的元素。\n这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。\n\n示例1：\n输入：[20, 18, 27, 19, 35]\n输出：[18, 19, 20, 27, 35]\n\n```javascript\n{% raw %}\nfunction popSort(arr) {\n  var len = arr.length;\n  for (var i = 0; i < len - 1; i++) {\n    for (var j = 0; j < len - 1 - i; j++) {\n         // 相邻元素两两对比，元素交换，大的元素交换到后面(相反就改成小于号)\n        if (arr[j] > arr[j + 1]) {\n            var temp = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = temp;\n        }\n    }\n  }\n  return arr;\n}\n//举个数组\nmyArr = [20,18,27,19,35];\n//使用函数\npopSort(myArr)\n{% endraw %}\n```\n\n### 题外话\n<p style=\"text-indent:2em\">今天忽然很想写这两题，想起了大学第一次用 C++ 编译这两个函数的时候，我喜欢它们。</p>\n<p style=\"text-indent:2em\"></p>\n\n","source":"_posts/不是LeetCode的04&05题.md","raw":"---\ntitle: 不是 LeetCode 的 04&05 题\ndate: 2021-03-22 13:37:56\nauthor: heyXiao\nsummary: 非 LeetCode 题目的技术总结\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 学习总结\n---\n\n### 斐波那契 easy\n\n斐波那契数，通常用 F(n) 表示，行程的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), 其中 n > 1\n\n示例1：\n输入：2\n输出：1\nF(2) = F(1) + F(0) = 1 + 0 = 1\n\n示例2：\n输入：3\n输出：2\nF(3) = F(2) + F(1) = 1 + 1 = 2\n\n示例2：\n输入：4\n输出：3\nF(4) = F(3) + F(2) = 2 + 1 = 3\n\n```javascript\n{% raw %}\nfunction fib(n) {\n  if(n === 0){\n    return 0\n  }\n  if(n === 2 || n===1){\n    return 1;\n  }\n  let preOne = 1;\n  let preTwo = 1;\n  let result = 0;\n  for(let i = 3; i <= n; i++){\n    result = preOne + preTwo;\n    preOne = preTwo;\n    preTwo = result;\n  }\n  return result;\n}\n{% endraw %}\n```\n\n### 冒泡排序 easy\n\n比较相邻的两个元素，如果前一个比后一个大，则交换位置。\n比较完第一轮的时候，最后一个元素是最大的元素。\n这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。\n\n示例1：\n输入：[20, 18, 27, 19, 35]\n输出：[18, 19, 20, 27, 35]\n\n```javascript\n{% raw %}\nfunction popSort(arr) {\n  var len = arr.length;\n  for (var i = 0; i < len - 1; i++) {\n    for (var j = 0; j < len - 1 - i; j++) {\n         // 相邻元素两两对比，元素交换，大的元素交换到后面(相反就改成小于号)\n        if (arr[j] > arr[j + 1]) {\n            var temp = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = temp;\n        }\n    }\n  }\n  return arr;\n}\n//举个数组\nmyArr = [20,18,27,19,35];\n//使用函数\npopSort(myArr)\n{% endraw %}\n```\n\n### 题外话\n<p style=\"text-indent:2em\">今天忽然很想写这两题，想起了大学第一次用 C++ 编译这两个函数的时候，我喜欢它们。</p>\n<p style=\"text-indent:2em\"></p>\n\n","slug":"不是LeetCode的04&05题","published":1,"updated":"2021-03-22T05:50:36.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cv0015ksup93qu3cpy","content":"<h3 id=\"斐波那契-easy\"><a href=\"#斐波那契-easy\" class=\"headerlink\" title=\"斐波那契 easy\"></a>斐波那契 easy</h3><p>斐波那契数，通常用 F(n) 表示，行程的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。<br>F(0) = 0, F(1) = 1<br>F(n) = F(n - 1) + F(n - 2), 其中 n &gt; 1</p>\n<p>示例1：<br>输入：2<br>输出：1<br>F(2) = F(1) + F(0) = 1 + 0 = 1</p>\n<p>示例2：<br>输入：3<br>输出：2<br>F(3) = F(2) + F(1) = 1 + 1 = 2</p>\n<p>示例2：<br>输入：4<br>输出：3<br>F(4) = F(3) + F(2) = 2 + 1 = 3</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">function</span> <span class=\"token function\">fib</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">===</span> <span class=\"token number\">2</span> <span class=\"token operator\">||</span> n<span class=\"token operator\">===</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">let</span> preOne <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> preTwo <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    result <span class=\"token operator\">=</span> preOne <span class=\"token operator\">+</span> preTwo<span class=\"token punctuation\">;</span>\n    preOne <span class=\"token operator\">=</span> preTwo<span class=\"token punctuation\">;</span>\n    preTwo <span class=\"token operator\">=</span> result<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> result<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"冒泡排序-easy\"><a href=\"#冒泡排序-easy\" class=\"headerlink\" title=\"冒泡排序 easy\"></a>冒泡排序 easy</h3><p>比较相邻的两个元素，如果前一个比后一个大，则交换位置。<br>比较完第一轮的时候，最后一个元素是最大的元素。<br>这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。</p>\n<p>示例1：<br>输入：[20, 18, 27, 19, 35]<br>输出：[18, 19, 20, 27, 35]</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">function</span> <span class=\"token function\">popSort</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> len <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> len <span class=\"token operator\">-</span> <span class=\"token number\">1</span> <span class=\"token operator\">-</span> i<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\" spellcheck=\"true\">// 相邻元素两两对比，元素交换，大的元素交换到后面(相反就改成小于号)</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> arr<span class=\"token punctuation\">[</span>j <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">var</span> temp <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            arr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n            arr<span class=\"token punctuation\">[</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> temp<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\" spellcheck=\"true\">//举个数组</span>\nmyArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">20</span><span class=\"token punctuation\">,</span><span class=\"token number\">18</span><span class=\"token punctuation\">,</span><span class=\"token number\">27</span><span class=\"token punctuation\">,</span><span class=\"token number\">19</span><span class=\"token punctuation\">,</span><span class=\"token number\">35</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\" spellcheck=\"true\">//使用函数</span>\n<span class=\"token function\">popSort</span><span class=\"token punctuation\">(</span>myArr<span class=\"token punctuation\">)</span>\n</code></pre>\n<h3 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h3><p style=\"text-indent:2em\">今天忽然很想写这两题，想起了大学第一次用 C++ 编译这两个函数的时候，我喜欢它们。</p>\n<p style=\"text-indent:2em\"></p>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"斐波那契-easy\"><a href=\"#斐波那契-easy\" class=\"headerlink\" title=\"斐波那契 easy\"></a>斐波那契 easy</h3><p>斐波那契数，通常用 F(n) 表示，行程的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。<br>F(0) = 0, F(1) = 1<br>F(n) = F(n - 1) + F(n - 2), 其中 n &gt; 1</p>\n<p>示例1：<br>输入：2<br>输出：1<br>F(2) = F(1) + F(0) = 1 + 0 = 1</p>\n<p>示例2：<br>输入：3<br>输出：2<br>F(3) = F(2) + F(1) = 1 + 1 = 2</p>\n<p>示例2：<br>输入：4<br>输出：3<br>F(4) = F(3) + F(2) = 2 + 1 = 3</p>\n<pre><code class=\"javascript\">\nfunction fib(n) {\n  if(n === 0){\n    return 0\n  }\n  if(n === 2 || n===1){\n    return 1;\n  }\n  let preOne = 1;\n  let preTwo = 1;\n  let result = 0;\n  for(let i = 3; i <= n; i++){\n    result = preOne + preTwo;\n    preOne = preTwo;\n    preTwo = result;\n  }\n  return result;\n}\n</code></pre>\n<h3 id=\"冒泡排序-easy\"><a href=\"#冒泡排序-easy\" class=\"headerlink\" title=\"冒泡排序 easy\"></a>冒泡排序 easy</h3><p>比较相邻的两个元素，如果前一个比后一个大，则交换位置。<br>比较完第一轮的时候，最后一个元素是最大的元素。<br>这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。</p>\n<p>示例1：<br>输入：[20, 18, 27, 19, 35]<br>输出：[18, 19, 20, 27, 35]</p>\n<pre><code class=\"javascript\">\nfunction popSort(arr) {\n  var len = arr.length;\n  for (var i = 0; i < len - 1; i++) {\n    for (var j = 0; j < len - 1 - i; j++) {\n         // 相邻元素两两对比，元素交换，大的元素交换到后面(相反就改成小于号)\n        if (arr[j] > arr[j + 1]) {\n            var temp = arr[j];\n            arr[j] = arr[j+1];\n            arr[j+1] = temp;\n        }\n    }\n  }\n  return arr;\n}\n//举个数组\nmyArr = [20,18,27,19,35];\n//使用函数\npopSort(myArr)\n</code></pre>\n<h3 id=\"题外话\"><a href=\"#题外话\" class=\"headerlink\" title=\"题外话\"></a>题外话</h3><p style=\"text-indent:2em\">今天忽然很想写这两题，想起了大学第一次用 C++ 编译这两个函数的时候，我喜欢它们。</p>\n<p style=\"text-indent:2em\"></p>\n\n"},{"title":"无博客无心情","date":"2021-01-28T06:42:27.000Z","author":"heyXiao","summary":"随便写写","_content":"### 一\n三无博客可以查到了，虽然要打全拼。小小的鼓励。\n\n### 二\n最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。\n\n### 三\nCourtship but friendship at least.\n\n### 四\n在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。\n\n### 五\n如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。\n\n### 六\n不用拖延了，因为本周又有事情做。\n\n### 七\n惊闻小伙伴已放假，使我大口恰柠檬。 21.02.06\n\n### 八\n放假前又想分给我任务，我已经做完两个了，赶紧推掉。\n\n### 九\n逛到了一个比较钟意的博客主题，记录一下，假期后切换看看。[hexo-theme-kaze](https://github.com/theme-kaze/hexo-theme-kaze)","source":"_posts/无博客无心情.md","raw":"---\ntitle: 无博客无心情\ndate: 2021-01-28 14:42:27\nauthor: heyXiao\nsummary: 随便写写\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 随笔\ntags:\n  - 随笔\n---\n### 一\n三无博客可以查到了，虽然要打全拼。小小的鼓励。\n\n### 二\n最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。\n\n### 三\nCourtship but friendship at least.\n\n### 四\n在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。\n\n### 五\n如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。\n\n### 六\n不用拖延了，因为本周又有事情做。\n\n### 七\n惊闻小伙伴已放假，使我大口恰柠檬。 21.02.06\n\n### 八\n放假前又想分给我任务，我已经做完两个了，赶紧推掉。\n\n### 九\n逛到了一个比较钟意的博客主题，记录一下，假期后切换看看。[hexo-theme-kaze](https://github.com/theme-kaze/hexo-theme-kaze)","slug":"无博客无心情","published":1,"updated":"2021-02-07T09:17:29.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cw0017ksup3jihdert","content":"<h3 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h3><p>三无博客可以查到了，虽然要打全拼。小小的鼓励。</p>\n<h3 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h3><p>最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。</p>\n<h3 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h3><p>Courtship but friendship at least.</p>\n<h3 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h3><p>在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。</p>\n<h3 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h3><p>如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。</p>\n<h3 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h3><p>不用拖延了，因为本周又有事情做。</p>\n<h3 id=\"七\"><a href=\"#七\" class=\"headerlink\" title=\"七\"></a>七</h3><p>惊闻小伙伴已放假，使我大口恰柠檬。 21.02.06</p>\n<h3 id=\"八\"><a href=\"#八\" class=\"headerlink\" title=\"八\"></a>八</h3><p>放假前又想分给我任务，我已经做完两个了，赶紧推掉。</p>\n<h3 id=\"九\"><a href=\"#九\" class=\"headerlink\" title=\"九\"></a>九</h3><p>逛到了一个比较钟意的博客主题，记录一下，假期后切换看看。<a href=\"https://github.com/theme-kaze/hexo-theme-kaze\">hexo-theme-kaze</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h3><p>三无博客可以查到了，虽然要打全拼。小小的鼓励。</p>\n<h3 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h3><p>最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。</p>\n<h3 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h3><p>Courtship but friendship at least.</p>\n<h3 id=\"四\"><a href=\"#四\" class=\"headerlink\" title=\"四\"></a>四</h3><p>在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。</p>\n<h3 id=\"五\"><a href=\"#五\" class=\"headerlink\" title=\"五\"></a>五</h3><p>如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。</p>\n<h3 id=\"六\"><a href=\"#六\" class=\"headerlink\" title=\"六\"></a>六</h3><p>不用拖延了，因为本周又有事情做。</p>\n<h3 id=\"七\"><a href=\"#七\" class=\"headerlink\" title=\"七\"></a>七</h3><p>惊闻小伙伴已放假，使我大口恰柠檬。 21.02.06</p>\n<h3 id=\"八\"><a href=\"#八\" class=\"headerlink\" title=\"八\"></a>八</h3><p>放假前又想分给我任务，我已经做完两个了，赶紧推掉。</p>\n<h3 id=\"九\"><a href=\"#九\" class=\"headerlink\" title=\"九\"></a>九</h3><p>逛到了一个比较钟意的博客主题，记录一下，假期后切换看看。<a href=\"https://github.com/theme-kaze/hexo-theme-kaze\">hexo-theme-kaze</a></p>\n"},{"title":"不是 LeetCode 的06题","date":"2021-03-24T07:00:47.000Z","author":"heyXiao","summary":"非 LeetCode 题目的技术总结","_content":"\n### 删除字符串中的所有相邻重复项 medium\n\n给定一个字符串 s，\"k 倍重复项删除操作\" 将会从 s 中选择 k 个相邻且相等的字母，并使被删除的字符串的左侧和右侧连在一起。\n你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。\n在执行完所有删除操作后，返回最终得到的字符串。\n\n示例\n\n输入：s = 'abcd'，k = 2\n输出：'abcd'\n解释：没有要删除的内容\n\n输入：s = 'deeedbbcccbdaa'，k = 3\n输出：'aa'\n解释：先删除 'eee' 和 'ccc'，得到 'ddbbbdaa'\n再删除 'bbb'，得到 'dddaa'\n最后删除 'ddd'，得到 'aa'\n\n输入：s = 'pbbcggttciiippooaais'，k = 2\n输出：'ps'\n解释：先删除 'bb'、'gg'、'tt'、'ii'、'pp'、'oo'、'aa'，得到 'pcciis'\n再删除 'cc'、'ii'，得到 'ps'\n\n```javascript\n{% raw %}\nvar delMult = function(s, k) {\n    let arr = s.split('');\n    let fn = function (arr, k) {\n        if (arr.length < k) {\n            return arr.join('');\n        }\n        // 这里还是拿 s = 'abcd'，k = 2 来举例，只需判断 4 - 2 + 1 = 3 次\n        // 从 s[i] = 'a' 与 s[i + j] = 'b' 对比 \n        for (let i = 0; i < arr.length - k + 1; i++) {\n            let flag = true;\n            for (let j = 1; j < k; j++) {\n                if (arr[i + j] !== arr[i]) {\n                    flag = false;\n                    break;\n                }\n            }\n            // 如果是从第 i 个起，重复 k 个。删除这 k 个字符，递归。\n            if (flag) {\n                arr.splice(i, k);\n                fn(arr, k);\n            }\n        }\n        return arr.join('');\n    };\n    return fn(arr, k);\n};\n{% endraw %}\n```\n<p style=\"text-indent:2em\">本来是从上午 09:52:40 开始写的，中间忙了一会，到下午 3 点才写完.....说实话还是想了一下</p>\n","source":"_posts/不是LeetCode的06题.md","raw":"---\ntitle: 不是 LeetCode 的06题\ndate: 2021-03-24 15:00:47\nauthor: heyXiao\nsummary: 非 LeetCode 题目的技术总结\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 学习总结\n---\n\n### 删除字符串中的所有相邻重复项 medium\n\n给定一个字符串 s，\"k 倍重复项删除操作\" 将会从 s 中选择 k 个相邻且相等的字母，并使被删除的字符串的左侧和右侧连在一起。\n你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。\n在执行完所有删除操作后，返回最终得到的字符串。\n\n示例\n\n输入：s = 'abcd'，k = 2\n输出：'abcd'\n解释：没有要删除的内容\n\n输入：s = 'deeedbbcccbdaa'，k = 3\n输出：'aa'\n解释：先删除 'eee' 和 'ccc'，得到 'ddbbbdaa'\n再删除 'bbb'，得到 'dddaa'\n最后删除 'ddd'，得到 'aa'\n\n输入：s = 'pbbcggttciiippooaais'，k = 2\n输出：'ps'\n解释：先删除 'bb'、'gg'、'tt'、'ii'、'pp'、'oo'、'aa'，得到 'pcciis'\n再删除 'cc'、'ii'，得到 'ps'\n\n```javascript\n{% raw %}\nvar delMult = function(s, k) {\n    let arr = s.split('');\n    let fn = function (arr, k) {\n        if (arr.length < k) {\n            return arr.join('');\n        }\n        // 这里还是拿 s = 'abcd'，k = 2 来举例，只需判断 4 - 2 + 1 = 3 次\n        // 从 s[i] = 'a' 与 s[i + j] = 'b' 对比 \n        for (let i = 0; i < arr.length - k + 1; i++) {\n            let flag = true;\n            for (let j = 1; j < k; j++) {\n                if (arr[i + j] !== arr[i]) {\n                    flag = false;\n                    break;\n                }\n            }\n            // 如果是从第 i 个起，重复 k 个。删除这 k 个字符，递归。\n            if (flag) {\n                arr.splice(i, k);\n                fn(arr, k);\n            }\n        }\n        return arr.join('');\n    };\n    return fn(arr, k);\n};\n{% endraw %}\n```\n<p style=\"text-indent:2em\">本来是从上午 09:52:40 开始写的，中间忙了一会，到下午 3 点才写完.....说实话还是想了一下</p>\n","slug":"不是LeetCode的06题","published":1,"updated":"2021-03-24T07:12:28.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cy001cksup21lw6l3v","content":"<h3 id=\"删除字符串中的所有相邻重复项-medium\"><a href=\"#删除字符串中的所有相邻重复项-medium\" class=\"headerlink\" title=\"删除字符串中的所有相邻重复项 medium\"></a>删除字符串中的所有相邻重复项 medium</h3><p>给定一个字符串 s，”k 倍重复项删除操作” 将会从 s 中选择 k 个相邻且相等的字母，并使被删除的字符串的左侧和右侧连在一起。<br>你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。<br>在执行完所有删除操作后，返回最终得到的字符串。</p>\n<p>示例</p>\n<p>输入：s = ‘abcd’，k = 2<br>输出：’abcd’<br>解释：没有要删除的内容</p>\n<p>输入：s = ‘deeedbbcccbdaa’，k = 3<br>输出：’aa’<br>解释：先删除 ‘eee’ 和 ‘ccc’，得到 ‘ddbbbdaa’<br>再删除 ‘bbb’，得到 ‘dddaa’<br>最后删除 ‘ddd’，得到 ‘aa’</p>\n<p>输入：s = ‘pbbcggttciiippooaais’，k = 2<br>输出：’ps’<br>解释：先删除 ‘bb’、’gg’、’tt’、’ii’、’pp’、’oo’、’aa’，得到 ‘pcciis’<br>再删除 ‘cc’、’ii’，得到 ‘ps’</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n<span class=\"token keyword\">var</span> delMult <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> arr <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> fn <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 这里还是拿 s = 'abcd'，k = 2 来举例，只需判断 4 - 2 + 1 = 3 次</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 从 s[i] = 'a' 与 s[i + j] = 'b' 对比 </span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">let</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> k<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>i <span class=\"token operator\">+</span> j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!==</span> arr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 如果是从第 i 个起，重复 k 个。删除这 k 个字符，递归。</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                arr<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> arr<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p style=\"text-indent:2em\">本来是从上午 09:52:40 开始写的，中间忙了一会，到下午 3 点才写完.....说实话还是想了一下</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"删除字符串中的所有相邻重复项-medium\"><a href=\"#删除字符串中的所有相邻重复项-medium\" class=\"headerlink\" title=\"删除字符串中的所有相邻重复项 medium\"></a>删除字符串中的所有相邻重复项 medium</h3><p>给定一个字符串 s，”k 倍重复项删除操作” 将会从 s 中选择 k 个相邻且相等的字母，并使被删除的字符串的左侧和右侧连在一起。<br>你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。<br>在执行完所有删除操作后，返回最终得到的字符串。</p>\n<p>示例</p>\n<p>输入：s = ‘abcd’，k = 2<br>输出：’abcd’<br>解释：没有要删除的内容</p>\n<p>输入：s = ‘deeedbbcccbdaa’，k = 3<br>输出：’aa’<br>解释：先删除 ‘eee’ 和 ‘ccc’，得到 ‘ddbbbdaa’<br>再删除 ‘bbb’，得到 ‘dddaa’<br>最后删除 ‘ddd’，得到 ‘aa’</p>\n<p>输入：s = ‘pbbcggttciiippooaais’，k = 2<br>输出：’ps’<br>解释：先删除 ‘bb’、’gg’、’tt’、’ii’、’pp’、’oo’、’aa’，得到 ‘pcciis’<br>再删除 ‘cc’、’ii’，得到 ‘ps’</p>\n<pre><code class=\"javascript\">\nvar delMult = function(s, k) {\n    let arr = s.split('');\n    let fn = function (arr, k) {\n        if (arr.length < k) {\n            return arr.join('');\n        }\n        // 这里还是拿 s = 'abcd'，k = 2 来举例，只需判断 4 - 2 + 1 = 3 次\n        // 从 s[i] = 'a' 与 s[i + j] = 'b' 对比 \n        for (let i = 0; i < arr.length - k + 1; i++) {\n            let flag = true;\n            for (let j = 1; j < k; j++) {\n                if (arr[i + j] !== arr[i]) {\n                    flag = false;\n                    break;\n                }\n            }\n            // 如果是从第 i 个起，重复 k 个。删除这 k 个字符，递归。\n            if (flag) {\n                arr.splice(i, k);\n                fn(arr, k);\n            }\n        }\n        return arr.join('');\n    };\n    return fn(arr, k);\n};\n</code></pre>\n<p style=\"text-indent:2em\">本来是从上午 09:52:40 开始写的，中间忙了一会，到下午 3 点才写完.....说实话还是想了一下</p>\n"},{"title":"理解 JavaScript 的 async/await","date":"2020-11-12T23:26:22.000Z","author":"heyXiao","_content":"\n# [理解 JavaScript 的 async/await]()\n\nJavaScript 中的 async/await 是 [AsyncFunction 特性](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction) 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 [这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility) 查看。\n\n---\n\n我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。\n\n我之前在[《闲谈异步调用“扁平”化》](https://segmentfault.com/a/1190000003742890) 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 [Task 或 Task<Result>](https://msdn.microsoft.com/library/dd321424.aspx) 类，而 JavaScript 的 async/await 实现，也离不开 [Promise](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise)。\n\n现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。\n\n## 1\\. async 和 await 在干什么\n\n任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？\n\n如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……\n\n如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？\n\n### 1.1. async 起什么作用\n\n这个问题的关键在于，async 函数是怎么处理它的返回值的！\n\n我们当然希望它能直接通过 `return` 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：\n\n```javascript\n{% raw %}\n    async function testAsync() {\n        return \"hello async\";\n    }\n\n    const result = testAsync();\n    console.log(result);\n{% endraw %}\n```\n\n看到输出就恍然大悟了——输出的是一个 Promise 对象。\n\n```javascript\n{% raw %}\n    c:\\var\\test> node --harmony_async_await .\n    Promise { 'hello async' }\n{% endraw %}\n```\n\n所以，async 函数返回的是一个 Promise 对象。从[文档](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function)中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\n> 补充知识点 _\\[2020-06-04\\]_\n>\n> `Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样\n\n```javascript\n{% raw %}\n    testAsync().then(v => {\n        console.log(v);    // 输出 hello async\n    });\n{% endraw %}\n```\n\n现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n那么下一个关键点就在于 await 关键字了。\n\n### 1.2. await 到底在等啥\n\n一般来说，都认为 await 是在等待一个 async 函数完成。不过按[语法说明](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await)，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行\n\n```javascript\n{% raw %}\n    function getSomething() {\n        return \"something\";\n    }\n\n    async function testAsync() {\n        return Promise.resolve(\"hello async\");\n    }\n\n    async function test() {\n        const v1 = await getSomething();\n        const v2 = await testAsync();\n        console.log(v1, v2);\n    }\n\n    test();\n{% endraw %}\n```\n\n### 1.3. await 等到了要等的，然后呢\n\nawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，`await` 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。\n\n如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n\n如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n> 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n## 2\\. async/await 帮我们干了啥\n\n### 2.1. 作个简单的比较\n\n上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。\n\n现在举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写\n\n```javascript\n{% raw %}\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    takeLongTime().then(v => {\n        console.log(\"got\", v);\n    });\n{% endraw %}\n```\n\n如果改用 async/await 呢，会是这样\n\n```javascript\n{% raw %}\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    async function test() {\n        const v = await takeLongTime();\n        console.log(v);\n    }\n\n    test();\n{% endraw %}\n```\n\n眼尖的同学已经发现 `takeLongTime()` 没有申明为 `async`。实际上，`takeLongTime()` 本身就是返回的 Promise 对象，加不加 `async` 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。\n\n又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？\n\n### 2.2. async/await 的优势在于处理 then 链\n\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：\n\n```javascript\n{% raw %}\n    /**\n     * 传入参数 n，表示这个函数执行的时间（毫秒）\n     * 执行的结果是 n + 200，这个值将用于下一步骤\n     */\n    function takeLongTime(n) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(n + 200), n);\n        });\n    }\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(n) {\n        console.log(`step2 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step3(n) {\n        console.log(`step3 with ${n}`);\n        return takeLongTime(n);\n    }\n{% endraw %}\n```\n\n现在用 Promise 方式来实现这三个步骤的处理\n\n```javascript\n{% raw %}\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => step2(time2))\n            .then(time3 => step3(time3))\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 500\n    // step3 with 700\n    // result is 900\n    // doIt: 1507.251ms\n{% endraw %}\n```\n\n输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样\n\n```javascript\n{% raw %}\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time2);\n        const result = await step3(time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n{% endraw %}\n```\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n### 2.3. 还有更酷的\n\n现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。\n\n```javascript\n{% raw %}\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(m, n) {\n        console.log(`step2 with ${m} and ${n}`);\n        return takeLongTime(m + n);\n    }\n\n    function step3(k, m, n) {\n        console.log(`step3 with ${k}, ${m} and ${n}`);\n        return takeLongTime(k + m + n);\n    }\n{% endraw %}\n```\n\n这回先用 async/await 来写：\n\n```javascript\n{% raw %}\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time1, time2);\n        const result = await step3(time1, time2, time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 800 = 300 + 500\n    // step3 with 1800 = 300 + 500 + 1000\n    // result is 2000\n    // doIt: 2907.387ms\n{% endraw %}\n```\n\n除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？\n\n```javascript\n{% raw %}\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => {\n                return step2(time1, time2)\n                    .then(time3 => [time1, time2, time3]);\n            })\n            .then(times => {\n                const [time1, time2, time3] = times;\n                return step3(time1, time2, time3);\n            })\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n{% endraw %}\n```\n\n有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！\n\n## 3\\. 洗洗睡吧\n\n就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理 3 个步骤，再等待所有结果，又该怎么处理呢？\n\n[阮一峰老师已经说过了](http://www.ruanyifeng.com/blog/2015/05/async.html)，我就懒得说了。\n\n## 4\\. 推荐相关文章\n\n- [在微信小程序中使用 async/await](https://segmentfault.com/a/1190000021966277) 2020-03-10\n- [代码审查，异步调用的常见问题剖析](https://segmentfault.com/a/1190000022349639) 2020-04-12\n- [Proxy 封装微信小程序的异步调用](https://segmentfault.com/a/1190000022315137) 2020-04-9\n- [改进异步封装：处理带返回值的异步调用](https://segmentfault.com/a/1190000022467002) 2020-04-25\n- [从地狱到天堂，Node 回调向 async/await 转变](https://segmentfault.com/a/1190000007987187) 2017-01-02\n- [异步编程需要“意识”](https://segmentfault.com/a/1190000013337421) 2018-02-23\n- [从不用 try-catch 实现的 async/await 语法说错误处理](https://segmentfault.com/a/1190000011802045) 2017-10-31\n\n## 5\\. 关于转载\n\n转载自[思否](https://segmentfault.com/a/1190000007535316) 作者[边城](https://segmentfault.com/u/jamesfancy)\n","source":"_posts/理解 JavaScript 的 async&await.md","raw":"---\ntitle: 理解 JavaScript 的 async/await\ndate: 2020-11-13 07:26:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\ncategories: 技术\ntags:\n  - JavaScript\n  - 转载\n---\n\n# [理解 JavaScript 的 async/await]()\n\nJavaScript 中的 async/await 是 [AsyncFunction 特性](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction) 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 [这里](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility) 查看。\n\n---\n\n我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。\n\n我之前在[《闲谈异步调用“扁平”化》](https://segmentfault.com/a/1190000003742890) 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 [Task 或 Task<Result>](https://msdn.microsoft.com/library/dd321424.aspx) 类，而 JavaScript 的 async/await 实现，也离不开 [Promise](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise)。\n\n现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。\n\n## 1\\. async 和 await 在干什么\n\n任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？\n\n如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……\n\n如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？\n\n### 1.1. async 起什么作用\n\n这个问题的关键在于，async 函数是怎么处理它的返回值的！\n\n我们当然希望它能直接通过 `return` 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：\n\n```javascript\n{% raw %}\n    async function testAsync() {\n        return \"hello async\";\n    }\n\n    const result = testAsync();\n    console.log(result);\n{% endraw %}\n```\n\n看到输出就恍然大悟了——输出的是一个 Promise 对象。\n\n```javascript\n{% raw %}\n    c:\\var\\test> node --harmony_async_await .\n    Promise { 'hello async' }\n{% endraw %}\n```\n\n所以，async 函数返回的是一个 Promise 对象。从[文档](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function)中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 `return` 一个直接量，async 会把这个直接量通过 `Promise.resolve()` 封装成 Promise 对象。\n\n> 补充知识点 _\\[2020-06-04\\]_\n>\n> `Promise.resolve(x)` 可以看作是 `new Promise(resolve => resolve(x))` 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。\n\nasync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：`then()` 链来处理这个 Promise 对象，就像这样\n\n```javascript\n{% raw %}\n    testAsync().then(v => {\n        console.log(v);    // 输出 hello async\n    });\n{% endraw %}\n```\n\n现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 `Promise.resolve(undefined)`。\n\n联想一下 Promise 的特点——无等待，所以在没有 `await` 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\n\n那么下一个关键点就在于 await 关键字了。\n\n### 1.2. await 到底在等啥\n\n一般来说，都认为 await 是在等待一个 async 函数完成。不过按[语法说明](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await)，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行\n\n```javascript\n{% raw %}\n    function getSomething() {\n        return \"something\";\n    }\n\n    async function testAsync() {\n        return Promise.resolve(\"hello async\");\n    }\n\n    async function test() {\n        const v1 = await getSomething();\n        const v2 = await testAsync();\n        console.log(v1, v2);\n    }\n\n    test();\n{% endraw %}\n```\n\n### 1.3. await 等到了要等的，然后呢\n\nawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，`await` 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。\n\n如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\n\n如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\n\n> 看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n## 2\\. async/await 帮我们干了啥\n\n### 2.1. 作个简单的比较\n\n上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。\n\n现在举例，用 `setTimeout` 模拟耗时的异步操作，先来看看不用 async/await 会怎么写\n\n```javascript\n{% raw %}\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    takeLongTime().then(v => {\n        console.log(\"got\", v);\n    });\n{% endraw %}\n```\n\n如果改用 async/await 呢，会是这样\n\n```javascript\n{% raw %}\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    async function test() {\n        const v = await takeLongTime();\n        console.log(v);\n    }\n\n    test();\n{% endraw %}\n```\n\n眼尖的同学已经发现 `takeLongTime()` 没有申明为 `async`。实际上，`takeLongTime()` 本身就是返回的 Promise 对象，加不加 `async` 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。\n\n又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？\n\n### 2.2. async/await 的优势在于处理 then 链\n\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 `setTimeout` 来模拟异步操作：\n\n```javascript\n{% raw %}\n    /**\n     * 传入参数 n，表示这个函数执行的时间（毫秒）\n     * 执行的结果是 n + 200，这个值将用于下一步骤\n     */\n    function takeLongTime(n) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(n + 200), n);\n        });\n    }\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(n) {\n        console.log(`step2 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step3(n) {\n        console.log(`step3 with ${n}`);\n        return takeLongTime(n);\n    }\n{% endraw %}\n```\n\n现在用 Promise 方式来实现这三个步骤的处理\n\n```javascript\n{% raw %}\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => step2(time2))\n            .then(time3 => step3(time3))\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 500\n    // step3 with 700\n    // result is 900\n    // doIt: 1507.251ms\n{% endraw %}\n```\n\n输出结果 `result` 是 `step3()` 的参数 `700 + 200` = `900`。`doIt()` 顺序执行了三个步骤，一共用了 `300 + 500 + 700 = 1500` 毫秒，和 `console.time()/console.timeEnd()` 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样\n\n```javascript\n{% raw %}\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time2);\n        const result = await step3(time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n{% endraw %}\n```\n\n结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\n\n### 2.3. 还有更酷的\n\n现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。\n\n```javascript\n{% raw %}\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(m, n) {\n        console.log(`step2 with ${m} and ${n}`);\n        return takeLongTime(m + n);\n    }\n\n    function step3(k, m, n) {\n        console.log(`step3 with ${k}, ${m} and ${n}`);\n        return takeLongTime(k + m + n);\n    }\n{% endraw %}\n```\n\n这回先用 async/await 来写：\n\n```javascript\n{% raw %}\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time1, time2);\n        const result = await step3(time1, time2, time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 800 = 300 + 500\n    // step3 with 1800 = 300 + 500 + 1000\n    // result is 2000\n    // doIt: 2907.387ms\n{% endraw %}\n```\n\n除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？\n\n```javascript\n{% raw %}\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => {\n                return step2(time1, time2)\n                    .then(time3 => [time1, time2, time3]);\n            })\n            .then(times => {\n                const [time1, time2, time3] = times;\n                return step3(time1, time2, time3);\n            })\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n{% endraw %}\n```\n\n有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！\n\n## 3\\. 洗洗睡吧\n\n就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理 3 个步骤，再等待所有结果，又该怎么处理呢？\n\n[阮一峰老师已经说过了](http://www.ruanyifeng.com/blog/2015/05/async.html)，我就懒得说了。\n\n## 4\\. 推荐相关文章\n\n- [在微信小程序中使用 async/await](https://segmentfault.com/a/1190000021966277) 2020-03-10\n- [代码审查，异步调用的常见问题剖析](https://segmentfault.com/a/1190000022349639) 2020-04-12\n- [Proxy 封装微信小程序的异步调用](https://segmentfault.com/a/1190000022315137) 2020-04-9\n- [改进异步封装：处理带返回值的异步调用](https://segmentfault.com/a/1190000022467002) 2020-04-25\n- [从地狱到天堂，Node 回调向 async/await 转变](https://segmentfault.com/a/1190000007987187) 2017-01-02\n- [异步编程需要“意识”](https://segmentfault.com/a/1190000013337421) 2018-02-23\n- [从不用 try-catch 实现的 async/await 语法说错误处理](https://segmentfault.com/a/1190000011802045) 2017-10-31\n\n## 5\\. 关于转载\n\n转载自[思否](https://segmentfault.com/a/1190000007535316) 作者[边城](https://segmentfault.com/u/jamesfancy)\n","slug":"理解 JavaScript 的 async&await","published":1,"updated":"2021-02-26T06:10:54.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0cz001fksupcn8t4xm1","content":"<h1 id=\"理解-JavaScript-的-async-await\"><a href=\"#理解-JavaScript-的-async-await\" class=\"headerlink\" title=\"理解 JavaScript 的 async/await\"></a><a href=\"\">理解 JavaScript 的 async/await</a></h1><p>JavaScript 中的 async/await 是 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction 特性</a> 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility\">这里</a> 查看。</p>\n<hr>\n<p>我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p>\n<p>我之前在<a href=\"https://segmentfault.com/a/1190000003742890\">《闲谈异步调用“扁平”化》</a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href=\"https://msdn.microsoft.com/library/dd321424.aspx\">Task 或 Task<Result></a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>。</p>\n<p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p>\n<h2 id=\"1-async-和-await-在干什么\"><a href=\"#1-async-和-await-在干什么\" class=\"headerlink\" title=\"1. async 和 await 在干什么\"></a>1. async 和 await 在干什么</h2><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p>\n<p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p>\n<p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p>\n<h3 id=\"1-1-async-起什么作用\"><a href=\"#1-1-async-起什么作用\" class=\"headerlink\" title=\"1.1. async 起什么作用\"></a>1.1. async 起什么作用</h3><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p>\n<p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">testAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"hello async\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token function\">testAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    c<span class=\"token punctuation\">:</span>\\<span class=\"token keyword\">var</span>\\test<span class=\"token operator\">></span> node <span class=\"token operator\">--</span>harmony_async_await <span class=\"token punctuation\">.</span>\n    Promise <span class=\"token punctuation\">{</span> <span class=\"token string\">'hello async'</span> <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>所以，async 函数返回的是一个 Promise 对象。从<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function\">文档</a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>\n<blockquote>\n<p>补充知识点 <em>[2020-06-04]</em></p>\n<p><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>\n</blockquote>\n<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token function\">testAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\" spellcheck=\"true\">// 输出 hello async</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>\n<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<p>那么下一个关键点就在于 await 关键字了。</p>\n<h3 id=\"1-2-await-到底在等啥\"><a href=\"#1-2-await-到底在等啥\" class=\"headerlink\" title=\"1.2. await 到底在等啥\"></a>1.2. await 到底在等啥</h3><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await\">语法说明</a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>\n<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">getSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"something\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">testAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello async\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> v1 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">getSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> v2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">testAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>v1<span class=\"token punctuation\">,</span> v2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h3 id=\"1-3-await-等到了要等的，然后呢\"><a href=\"#1-3-await-等到了要等的，然后呢\" class=\"headerlink\" title=\"1.3. await 等到了要等的，然后呢\"></a>1.3. await 等到了要等的，然后呢</h3><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p>\n<p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p>\n<p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p>\n<blockquote>\n<p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n</blockquote>\n<h2 id=\"2-async-await-帮我们干了啥\"><a href=\"#2-async-await-帮我们干了啥\" class=\"headerlink\" title=\"2. async/await 帮我们干了啥\"></a>2. async/await 帮我们干了啥</h2><h3 id=\"2-1-作个简单的比较\"><a href=\"#2-1-作个简单的比较\" class=\"headerlink\" title=\"2.1. 作个简单的比较\"></a>2.1. 作个简单的比较</h3><p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>\n<p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"long_time_value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>v <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"got\"</span><span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>如果改用 async/await 呢，会是这样</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"long_time_value\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> v <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p>\n<p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p>\n<h3 id=\"2-2-async-await-的优势在于处理-then-链\"><a href=\"#2-2-async-await-的优势在于处理-then-链\" class=\"headerlink\" title=\"2.2. async/await 的优势在于处理 then 链\"></a>2.2. async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>\n<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">/**\n     * 传入参数 n，表示这个函数执行的时间（毫秒）\n     * 执行的结果是 n + 200，这个值将用于下一步骤\n     */</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span>resolve <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">+</span> <span class=\"token number\">200</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`step1 with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`step2 with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`step3 with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>现在用 Promise 方式来实现这三个步骤的处理</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time1 <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>time2 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>time2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>time3 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>time3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`result is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>result<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// c:\\var\\test>node --harmony_async_await .</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step1 with 300</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step2 with 500</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step3 with 700</span>\n    <span class=\"token comment\" spellcheck=\"true\">// result is 900</span>\n    <span class=\"token comment\" spellcheck=\"true\">// doIt: 1507.251ms</span>\n</code></pre>\n<p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p>\n<p>如果用 async/await 来实现呢，会是这样</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time1 <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time3 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>time2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>time3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`result is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>result<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h3 id=\"2-3-还有更酷的\"><a href=\"#2-3-还有更酷的\" class=\"headerlink\" title=\"2.3. 还有更酷的\"></a>2.3. 还有更酷的</h3><p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`step1 with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`step2 with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>m<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> and </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>k<span class=\"token punctuation\">,</span> m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`step3 with </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>k<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>m<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> and </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>n<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">takeLongTime</span><span class=\"token punctuation\">(</span>k <span class=\"token operator\">+</span> m <span class=\"token operator\">+</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>这回先用 async/await 来写：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time1 <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time2 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time3 <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">,</span> time3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`result is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>result<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// c:\\var\\test>node --harmony_async_await .</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step1 with 300</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step2 with 800 = 300 + 500</span>\n    <span class=\"token comment\" spellcheck=\"true\">// step3 with 1800 = 300 + 500 + 1000</span>\n    <span class=\"token comment\" spellcheck=\"true\">// result is 2000</span>\n    <span class=\"token comment\" spellcheck=\"true\">// doIt: 2907.387ms</span>\n</code></pre>\n<p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">function</span> <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">time</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> time1 <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span>\n        <span class=\"token function\">step1</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>time2 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>time3 <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">,</span> time3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>times <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">,</span> time3<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> times<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>time1<span class=\"token punctuation\">,</span> time2<span class=\"token punctuation\">,</span> time3<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>result <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token string\">`result is </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>result<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                console<span class=\"token punctuation\">.</span><span class=\"token function\">timeEnd</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"doIt\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token function\">doIt</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p>\n<h2 id=\"3-洗洗睡吧\"><a href=\"#3-洗洗睡吧\" class=\"headerlink\" title=\"3. 洗洗睡吧\"></a>3. 洗洗睡吧</h2><p>就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理 3 个步骤，再等待所有结果，又该怎么处理呢？</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\">阮一峰老师已经说过了</a>，我就懒得说了。</p>\n<h2 id=\"4-推荐相关文章\"><a href=\"#4-推荐相关文章\" class=\"headerlink\" title=\"4. 推荐相关文章\"></a>4. 推荐相关文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000021966277\">在微信小程序中使用 async/await</a> 2020-03-10</li>\n<li><a href=\"https://segmentfault.com/a/1190000022349639\">代码审查，异步调用的常见问题剖析</a> 2020-04-12</li>\n<li><a href=\"https://segmentfault.com/a/1190000022315137\">Proxy 封装微信小程序的异步调用</a> 2020-04-9</li>\n<li><a href=\"https://segmentfault.com/a/1190000022467002\">改进异步封装：处理带返回值的异步调用</a> 2020-04-25</li>\n<li><a href=\"https://segmentfault.com/a/1190000007987187\">从地狱到天堂，Node 回调向 async/await 转变</a> 2017-01-02</li>\n<li><a href=\"https://segmentfault.com/a/1190000013337421\">异步编程需要“意识”</a> 2018-02-23</li>\n<li><a href=\"https://segmentfault.com/a/1190000011802045\">从不用 try-catch 实现的 async/await 语法说错误处理</a> 2017-10-31</li>\n</ul>\n<h2 id=\"5-关于转载\"><a href=\"#5-关于转载\" class=\"headerlink\" title=\"5. 关于转载\"></a>5. 关于转载</h2><p>转载自<a href=\"https://segmentfault.com/a/1190000007535316\">思否</a> 作者<a href=\"https://segmentfault.com/u/jamesfancy\">边城</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"理解-JavaScript-的-async-await\"><a href=\"#理解-JavaScript-的-async-await\" class=\"headerlink\" title=\"理解 JavaScript 的 async/await\"></a><a href=\"\">理解 JavaScript 的 async/await</a></h1><p>JavaScript 中的 async/await 是 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction\">AsyncFunction 特性</a> 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility\">这里</a> 查看。</p>\n<hr>\n<p>我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p>\n<p>我之前在<a href=\"https://segmentfault.com/a/1190000003742890\">《闲谈异步调用“扁平”化》</a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href=\"https://msdn.microsoft.com/library/dd321424.aspx\">Task 或 Task<Result></a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promise</a>。</p>\n<p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p>\n<h2 id=\"1-async-和-await-在干什么\"><a href=\"#1-async-和-await-在干什么\" class=\"headerlink\" title=\"1. async 和 await 在干什么\"></a>1. async 和 await 在干什么</h2><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p>\n<p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p>\n<p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p>\n<h3 id=\"1-1-async-起什么作用\"><a href=\"#1-1-async-起什么作用\" class=\"headerlink\" title=\"1.1. async 起什么作用\"></a>1.1. async 起什么作用</h3><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p>\n<p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p>\n<pre><code class=\"javascript\">\n    async function testAsync() {\n        return \"hello async\";\n    }\n\n    const result = testAsync();\n    console.log(result);\n</code></pre>\n<p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p>\n<pre><code class=\"javascript\">\n    c:\\var\\test> node --harmony_async_await .\n    Promise { 'hello async' }\n</code></pre>\n<p>所以，async 函数返回的是一个 Promise 对象。从<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function\">文档</a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>\n<blockquote>\n<p>补充知识点 <em>[2020-06-04]</em></p>\n<p><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>\n</blockquote>\n<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p>\n<pre><code class=\"javascript\">\n    testAsync().then(v => {\n        console.log(v);    // 输出 hello async\n    });\n</code></pre>\n<p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>\n<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>\n<p>那么下一个关键点就在于 await 关键字了。</p>\n<h3 id=\"1-2-await-到底在等啥\"><a href=\"#1-2-await-到底在等啥\" class=\"headerlink\" title=\"1.2. await 到底在等啥\"></a>1.2. await 到底在等啥</h3><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await\">语法说明</a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>\n<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p>\n<pre><code class=\"javascript\">\n    function getSomething() {\n        return \"something\";\n    }\n\n    async function testAsync() {\n        return Promise.resolve(\"hello async\");\n    }\n\n    async function test() {\n        const v1 = await getSomething();\n        const v2 = await testAsync();\n        console.log(v1, v2);\n    }\n\n    test();\n</code></pre>\n<h3 id=\"1-3-await-等到了要等的，然后呢\"><a href=\"#1-3-await-等到了要等的，然后呢\" class=\"headerlink\" title=\"1.3. await 等到了要等的，然后呢\"></a>1.3. await 等到了要等的，然后呢</h3><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p>\n<p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p>\n<p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p>\n<blockquote>\n<p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n</blockquote>\n<h2 id=\"2-async-await-帮我们干了啥\"><a href=\"#2-async-await-帮我们干了啥\" class=\"headerlink\" title=\"2. async/await 帮我们干了啥\"></a>2. async/await 帮我们干了啥</h2><h3 id=\"2-1-作个简单的比较\"><a href=\"#2-1-作个简单的比较\" class=\"headerlink\" title=\"2.1. 作个简单的比较\"></a>2.1. 作个简单的比较</h3><p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>\n<p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p>\n<pre><code class=\"javascript\">\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    takeLongTime().then(v => {\n        console.log(\"got\", v);\n    });\n</code></pre>\n<p>如果改用 async/await 呢，会是这样</p>\n<pre><code class=\"javascript\">\n    function takeLongTime() {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(\"long_time_value\"), 1000);\n        });\n    }\n\n    async function test() {\n        const v = await takeLongTime();\n        console.log(v);\n    }\n\n    test();\n</code></pre>\n<p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p>\n<p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p>\n<h3 id=\"2-2-async-await-的优势在于处理-then-链\"><a href=\"#2-2-async-await-的优势在于处理-then-链\" class=\"headerlink\" title=\"2.2. async/await 的优势在于处理 then 链\"></a>2.2. async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p>\n<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p>\n<pre><code class=\"javascript\">\n    /**\n     * 传入参数 n，表示这个函数执行的时间（毫秒）\n     * 执行的结果是 n + 200，这个值将用于下一步骤\n     */\n    function takeLongTime(n) {\n        return new Promise(resolve => {\n            setTimeout(() => resolve(n + 200), n);\n        });\n    }\n\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(n) {\n        console.log(`step2 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step3(n) {\n        console.log(`step3 with ${n}`);\n        return takeLongTime(n);\n    }\n</code></pre>\n<p>现在用 Promise 方式来实现这三个步骤的处理</p>\n<pre><code class=\"javascript\">\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => step2(time2))\n            .then(time3 => step3(time3))\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 500\n    // step3 with 700\n    // result is 900\n    // doIt: 1507.251ms\n</code></pre>\n<p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p>\n<p>如果用 async/await 来实现呢，会是这样</p>\n<pre><code class=\"javascript\">\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time2);\n        const result = await step3(time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n</code></pre>\n<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>\n<h3 id=\"2-3-还有更酷的\"><a href=\"#2-3-还有更酷的\" class=\"headerlink\" title=\"2.3. 还有更酷的\"></a>2.3. 还有更酷的</h3><p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p>\n<pre><code class=\"javascript\">\n    function step1(n) {\n        console.log(`step1 with ${n}`);\n        return takeLongTime(n);\n    }\n\n    function step2(m, n) {\n        console.log(`step2 with ${m} and ${n}`);\n        return takeLongTime(m + n);\n    }\n\n    function step3(k, m, n) {\n        console.log(`step3 with ${k}, ${m} and ${n}`);\n        return takeLongTime(k + m + n);\n    }\n</code></pre>\n<p>这回先用 async/await 来写：</p>\n<pre><code class=\"javascript\">\n    async function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        const time2 = await step1(time1);\n        const time3 = await step2(time1, time2);\n        const result = await step3(time1, time2, time3);\n        console.log(`result is ${result}`);\n        console.timeEnd(\"doIt\");\n    }\n\n    doIt();\n\n    // c:\\var\\test>node --harmony_async_await .\n    // step1 with 300\n    // step2 with 800 = 300 + 500\n    // step3 with 1800 = 300 + 500 + 1000\n    // result is 2000\n    // doIt: 2907.387ms\n</code></pre>\n<p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p>\n<pre><code class=\"javascript\">\n    function doIt() {\n        console.time(\"doIt\");\n        const time1 = 300;\n        step1(time1)\n            .then(time2 => {\n                return step2(time1, time2)\n                    .then(time3 => [time1, time2, time3]);\n            })\n            .then(times => {\n                const [time1, time2, time3] = times;\n                return step3(time1, time2, time3);\n            })\n            .then(result => {\n                console.log(`result is ${result}`);\n                console.timeEnd(\"doIt\");\n            });\n    }\n\n    doIt();\n</code></pre>\n<p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p>\n<h2 id=\"3-洗洗睡吧\"><a href=\"#3-洗洗睡吧\" class=\"headerlink\" title=\"3. 洗洗睡吧\"></a>3. 洗洗睡吧</h2><p>就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理 3 个步骤，再等待所有结果，又该怎么处理呢？</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2015/05/async.html\">阮一峰老师已经说过了</a>，我就懒得说了。</p>\n<h2 id=\"4-推荐相关文章\"><a href=\"#4-推荐相关文章\" class=\"headerlink\" title=\"4. 推荐相关文章\"></a>4. 推荐相关文章</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000021966277\">在微信小程序中使用 async/await</a> 2020-03-10</li>\n<li><a href=\"https://segmentfault.com/a/1190000022349639\">代码审查，异步调用的常见问题剖析</a> 2020-04-12</li>\n<li><a href=\"https://segmentfault.com/a/1190000022315137\">Proxy 封装微信小程序的异步调用</a> 2020-04-9</li>\n<li><a href=\"https://segmentfault.com/a/1190000022467002\">改进异步封装：处理带返回值的异步调用</a> 2020-04-25</li>\n<li><a href=\"https://segmentfault.com/a/1190000007987187\">从地狱到天堂，Node 回调向 async/await 转变</a> 2017-01-02</li>\n<li><a href=\"https://segmentfault.com/a/1190000013337421\">异步编程需要“意识”</a> 2018-02-23</li>\n<li><a href=\"https://segmentfault.com/a/1190000011802045\">从不用 try-catch 实现的 async/await 语法说错误处理</a> 2017-10-31</li>\n</ul>\n<h2 id=\"5-关于转载\"><a href=\"#5-关于转载\" class=\"headerlink\" title=\"5. 关于转载\"></a>5. 关于转载</h2><p>转载自<a href=\"https://segmentfault.com/a/1190000007535316\">思否</a> 作者<a href=\"https://segmentfault.com/u/jamesfancy\">边城</a></p>\n"},{"title":"提上日程的几件事","date":"2020-11-17T08:37:15.000Z","author":"heyXiao","password":"025796e1db8c9c0f5ce8825e521e76692a7c03a73d8e77462e620ae458a88fe3","summary":"快要结束的一年的总结","indexing":false,"_content":"\n# 提上日程的几件事\n\n<font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font>\n<br/>\n<font color=\"#999999\">本周单休</font>\n\n## 年终总结\n<p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n","source":"_posts/提上日程的几件事.md","raw":"---\ntitle: 提上日程的几件事\ndate: 2020-11-17 16:37:15\nauthor: heyXiao\npassword: 025796e1db8c9c0f5ce8825e521e76692a7c03a73d8e77462e620ae458a88fe3\n# cover: true\nsummary: 快要结束的一年的总结\ncategories: 随笔\nindexing: false\ntags:\n  - 随笔\n---\n\n# 提上日程的几件事\n\n<font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font>\n<br/>\n<font color=\"#999999\">本周单休</font>\n\n## 年终总结\n<p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n","slug":"提上日程的几件事","published":1,"updated":"2021-01-06T03:33:07.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0d1001kksuphc7s30sz","content":"<h1 id=\"提上日程的几件事\"><a href=\"#提上日程的几件事\" class=\"headerlink\" title=\"提上日程的几件事\"></a>提上日程的几件事</h1><p><font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font><br><br/><br><font color=\"#999999\">本周单休</font></p>\n<h2 id=\"年终总结\"><a href=\"#年终总结\" class=\"headerlink\" title=\"年终总结\"></a>年终总结</h2><p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"提上日程的几件事\"><a href=\"#提上日程的几件事\" class=\"headerlink\" title=\"提上日程的几件事\"></a>提上日程的几件事</h1><p><font color=\"#999999\">现在时间2020年11月17日 周二 下午 16:04 </font><br><br/><br><font color=\"#999999\">本周单休</font></p>\n<h2 id=\"年终总结\"><a href=\"#年终总结\" class=\"headerlink\" title=\"年终总结\"></a>年终总结</h2><p>没记错是去年11月19日,老板关闭了我在长沙工作一年的小公司.迫于生活,我在年前的两个月里任职一家公司的前端,我很清楚我不会留下来,这一点他们也知道.</p>\n<p>我15年9月毕业,但是从14年下半年就已经是半工作.在外面久了,有时候也会想家,觉得不如就此回去.</p>\n<p>20年1月19日回到老家,和家人去了南京玩了一趟,刚好赶在疫情戒严前返程,开始宅家生活到5月末.</p>\n<p>20年5月末来到合肥,面试入职现在的公司,之前拿到南京外包的Offer,没去.</p>\n<p>2020-12-01 最近工作越来越烦心,应该是在自己最讨厌的项目组吧,跟我差不多时间入职的同事将要被辞退,博客也没心情写. SAD</p>\n<p>U2FsdGVkX19XxAvTG4V7zN7b9huLeqFwTh+M25PsYY+KN97VoLcnmBZsYHt9ApGx\n8np3Qoyboa4pTC7iT1SFvgAESw9nTIhsH0GJN062zvO3uZlPd918j2R8a0uSF/PC\nqupriWYHUa2iZbBhH9JDGTTstN+WuJLD+DDW04adW5TDNCjHjXbyZEoKAp0k5FNa\nKeMUuKZE3vZu99dOlqnhPOsnWNn08Tk58rPGX40Er5keZua0QcZnqHBkwXbbSrcF\n3Oau+uSffI/Lc6gbYPkPas0kb6IiCgUMWtIugEjzPYav62o+yVlzjTPppQyvJcS8\nglucE7j9uGlFxM1n5Im3RrNm5j2OQENnwGWvVd7oMzyRu86sXKiWjzJbgDNwCxmA\nocmBwTMG7u1DsaUZhchz+Q==  AES</p>\n<p>2020-12-08 第一次相亲基本上可以宣告失败,感觉不太好,主要让我回忆起了之前分手的感觉.在加上今天的一些事情,我感觉SAD到了一个高度</p>\n<p>2020-12-25 有点困惑是不是应该不那么尽心的工作,项目公司,工作是做不完的,马不停蹄的一个接一个,年后提加薪吧,别让自己太累</p>\n\n<p>未完</p>\n\n\n\n\n\n\n"},{"title":"这个Blog还有我","date":"2020-11-07T08:27:22.000Z","author":"heyXiao","summary":"主要是个人简介与博客的介绍","_content":"# 这个Blog还有我\n\n-------------------\n## 个人简介\n\n**我** 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。\n**兴趣爱好：** 听音乐，排球，羽毛球，骑车\n**Favor：** 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。\n**联系方式：** 手机：18856980690 邮箱：heylheyz@163.com\n\n##### 技能简介\n**技术栈** H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。\n**PC端** 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。\n**移动端** 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。\n**业务能力** 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。\n\n##### 自我评价\n待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。\n\n## 博客简介\n**这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。**\n\n## 其他的事情\n很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。\n感谢 [blinkfox](https://github.com/blinkfox)和[hexo-theme-matery](https://github.com/blinkfox/hexo-theme-matery)，Ta的文章与Hexo主题帮助我建立了这个博客。\n","source":"_posts/这个Blog还有我.md","raw":"---\ntitle: 这个Blog还有我\ndate: 2020-11-07 16:27:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: 主要是个人简介与博客的介绍\ncategories: 致来访者\ntags:\n  - 个人简介\n  - 博客简介\n---\n# 这个Blog还有我\n\n-------------------\n## 个人简介\n\n**我** 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。\n**兴趣爱好：** 听音乐，排球，羽毛球，骑车\n**Favor：** 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。\n**联系方式：** 手机：18856980690 邮箱：heylheyz@163.com\n\n##### 技能简介\n**技术栈** H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。\n**PC端** 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。\n**移动端** 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。\n**业务能力** 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。\n\n##### 自我评价\n待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。\n\n## 博客简介\n**这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。**\n\n## 其他的事情\n很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。\n感谢 [blinkfox](https://github.com/blinkfox)和[hexo-theme-matery](https://github.com/blinkfox/hexo-theme-matery)，Ta的文章与Hexo主题帮助我建立了这个博客。\n","slug":"这个Blog还有我","published":1,"updated":"2021-01-06T03:16:01.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0do002pksuphnsjco56","content":"<h1 id=\"这个Blog还有我\"><a href=\"#这个Blog还有我\" class=\"headerlink\" title=\"这个Blog还有我\"></a>这个Blog还有我</h1><hr>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p><strong>我</strong> 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。<br><strong>兴趣爱好：</strong> 听音乐，排球，羽毛球，骑车<br><strong>Favor：</strong> 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。<br><strong>联系方式：</strong> 手机：18856980690 邮箱：<a href=\"mailto:&#104;&#x65;&#121;&#108;&#x68;&#101;&#x79;&#x7a;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;\">&#104;&#x65;&#121;&#108;&#x68;&#101;&#x79;&#x7a;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>\n<h5 id=\"技能简介\"><a href=\"#技能简介\" class=\"headerlink\" title=\"技能简介\"></a>技能简介</h5><p><strong>技术栈</strong> H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。<br><strong>PC端</strong> 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。<br><strong>移动端</strong> 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。<br><strong>业务能力</strong> 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。</p>\n<h5 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h5><p>待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。</p>\n<h2 id=\"博客简介\"><a href=\"#博客简介\" class=\"headerlink\" title=\"博客简介\"></a>博客简介</h2><p><strong>这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。</strong></p>\n<h2 id=\"其他的事情\"><a href=\"#其他的事情\" class=\"headerlink\" title=\"其他的事情\"></a>其他的事情</h2><p>很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。<br>感谢 <a href=\"https://github.com/blinkfox\">blinkfox</a>和<a href=\"https://github.com/blinkfox/hexo-theme-matery\">hexo-theme-matery</a>，Ta的文章与Hexo主题帮助我建立了这个博客。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"这个Blog还有我\"><a href=\"#这个Blog还有我\" class=\"headerlink\" title=\"这个Blog还有我\"></a>这个Blog还有我</h1><hr>\n<h2 id=\"个人简介\"><a href=\"#个人简介\" class=\"headerlink\" title=\"个人简介\"></a>个人简介</h2><p><strong>我</strong> 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。<br><strong>兴趣爱好：</strong> 听音乐，排球，羽毛球，骑车<br><strong>Favor：</strong> 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。<br><strong>联系方式：</strong> 手机：18856980690 邮箱：<a href=\"mailto:&#104;&#x65;&#121;&#108;&#x68;&#101;&#x79;&#x7a;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;\">&#104;&#x65;&#121;&#108;&#x68;&#101;&#x79;&#x7a;&#64;&#49;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>\n<h5 id=\"技能简介\"><a href=\"#技能简介\" class=\"headerlink\" title=\"技能简介\"></a>技能简介</h5><p><strong>技术栈</strong> H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。<br><strong>PC端</strong> 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。<br><strong>移动端</strong> 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。<br><strong>业务能力</strong> 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。</p>\n<h5 id=\"自我评价\"><a href=\"#自我评价\" class=\"headerlink\" title=\"自我评价\"></a>自我评价</h5><p>待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。</p>\n<h2 id=\"博客简介\"><a href=\"#博客简介\" class=\"headerlink\" title=\"博客简介\"></a>博客简介</h2><p><strong>这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。</strong></p>\n<h2 id=\"其他的事情\"><a href=\"#其他的事情\" class=\"headerlink\" title=\"其他的事情\"></a>其他的事情</h2><p>很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。<br>感谢 <a href=\"https://github.com/blinkfox\">blinkfox</a>和<a href=\"https://github.com/blinkfox/hexo-theme-matery\">hexo-theme-matery</a>，Ta的文章与Hexo主题帮助我建立了这个博客。</p>\n"},{"title":"Promise V8 源码分析(二)","date":"2020-12-14T06:14:22.000Z","author":"heyXiao","summary":"基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。","_content":"\n基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。\n\n## reject\n\n```javascript\n{% raw %}\n    new Promise((resolve, reject) => {\n      setTimeout(_ => reject('rejected'), 5000)\n    }).then(_ => {\n      console.log('fulfilled')\n    }, reason => {\n      console.log(reason)\n    })\n{% endraw %}\n```\n\n上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 [RejectPromise](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210) 函数，源码如下：\n\n```javascript\n{% raw %}\n    transitioning builtin\n    RejectPromise(implicit context: Context)(\n        promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny {\n      // 取出 Promise 的处理对象 PromiseReaction\n      const reactions =\n          UnsafeCast<(Zero | PromiseReaction)>(promise.reactions_or_result);\n      // 这里的 reason 就是 reject 函数的参数\n      promise.reactions_or_result = reason;\n      // 设置 Promise 的状态为 rejected\n      promise.SetStatus(PromiseState::kRejected);\n      TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n      return Undefined;\n    }\n{% endraw %}\n```\n\n[TriggerPromiseReactions](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140) 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：\n\n```javascript\n{% raw %}\n    // https://tc39.es/ecma262/#sec-triggerpromisereactions\n    transitioning macro TriggerPromiseReactions(implicit context: Context)(\n        reactions: Zero|PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      // 删减了链表反转的代码\n      let current = reactions;\n      // reactions 是一个链表，下面的 while 循环遍历链表\n      while (true) {\n        typeswitch (current) {\n          case (Zero): {\n            break;\n          }\n          case (currentReaction: PromiseReaction): {\n            // 取出链表下一个结点\n            current = currentReaction.next;\n            // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n            MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n          }\n        }\n      }\n    }\n{% endraw %}\n```\n\n[MorphAndEnqueuePromiseReaction](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84) 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。\n\nMorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。\n\n```javascript\n{% raw %}\n    transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n        promiseReaction: PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      let primaryHandler: Callable|Undefined;\n      let secondaryHandler: Callable|Undefined;\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        primaryHandler = promiseReaction.fulfill_handler;\n        secondaryHandler = promiseReaction.reject_handler;\n      } else {\n        primaryHandler = promiseReaction.reject_handler;\n        secondaryHandler = promiseReaction.fulfill_handler;\n      }\n      const handlerContext: Context =\n          ExtractHandlerContext(primaryHandler, secondaryHandler);\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        // 删\n      } else {\n        * UnsafeConstCast(& promiseReaction.map) =\n            PromiseRejectReactionJobTaskMapConstant();\n        const promiseReactionJobTask =\n            UnsafeCast<PromiseRejectReactionJobTask>(promiseReaction);\n        // argument 是 reject 的参数\n        promiseReactionJobTask.argument = argument;\n        promiseReactionJobTask.context = handlerContext;\n        // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n        promiseReactionJobTask.handler = primaryHandler;\n        // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n        // EnqueueMicrotask 将 microtask 插入 microtask 队列\n        EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n      }\n    }\n{% endraw %}\n```\n\nreject 和 resolve 的逻辑基本相同，分为 3 步：\n\n- 设置 Promise 的 value/reason，也就是 resolve/reject 的参数\n- 设置 Promise 的状态：fulfilled/rejected\n- 从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列\n\n## catch\n\n```javascript\n{% raw %}\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        console.log('rejected')\n    })\n{% endraw %}\n```\n\n以上面代码为例，当 catch 方法执行时，调用了 V8 的 [PromisePrototypeCatch](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100) 方法，源码如下：\n\n```javascript\n{% raw %}\n    transitioning javascript builtin\n    PromisePrototypeCatch(\n        js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny {\n      const nativeContext = LoadNativeContext(context);\n      return UnsafeCast<JSAny>(\n          InvokeThen(nativeContext, receiver, Undefined, onRejected));\n    }\n{% endraw %}\n```\n\nPromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，[InvokeThen](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199) 源码如下：\n\n```javascript\n{% raw %}\n    transitioning\n    macro InvokeThen<F: type>(implicit context: Context)(\n        nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n        callFunctor: F): JSAny {\n      if (!Is<Smi>(receiver) &&\n          IsPromiseThenLookupChainIntact(\n              nativeContext, UnsafeCast<HeapObject>(receiver).map)) {\n        const then =\n            UnsafeCast<JSAny>(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n        // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n        return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n      } else\n        deferred {\n          const then = UnsafeCast<JSAny>(GetProperty(receiver, kThenString));\n          // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n          return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n        }\n    }\n{% endraw %}\n```\n\nInvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。\n\n既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。\n\n```javascript\n{% raw %}\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        throw 'rejected'\n    }).catch(_ => {\n        console.log('last catch')\n    })\n{% endraw %}\n```\n\n上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。\n\n> catch 方法通过底层调用 then 方法来实现  \n> 假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)\n\n## then 的链式调用与 microtask 队列\n\n```javascript\n{% raw %}\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n{% endraw %}\n```\n\n以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。\n\n```javascript\n{% raw %}\n    const p0 = Promise.resolve('123')\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n{% endraw %}\n```\n\nthen 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。\n\np0 开始便处于 fulfilled 状态，当执行\n\n```javascript\n{% raw %}\n    const p1 = p0.then(() => {throw new Error('456')})\n{% endraw %}\n```\n\n时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n跑完余下所有的代码。\n\n```javascript\n{% raw %}\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n{% endraw %}\n```\n\np1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n开始执行 microtask 队列，核心方法是 [MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114)，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。\n\n在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 [PromiseReactionJob](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43)，源码如下：\n\n```javascript\n{% raw %}\n    transitioning\n    macro PromiseReactionJob(\n        context: Context, argument: JSAny, handler: Callable|Undefined,\n        promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n        reactionType: constexpr PromiseReactionType): JSAny {\n      if (handler == Undefined) {\n        // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n        if constexpr (reactionType == kPromiseReactionFulfill) {\n          // 基本类同 JS 层的 resolve\n          return FuflfillPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        } else {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        }\n      } else {\n        try {\n          // 试图调用 Promise 处理函数，相当于 handler(argument)\n          const result =\n              Call(context, UnsafeCast<Callable>(handler), Undefined, argument);\n            // 基本类同 JS 层的 resolve\n            return FuflfillPromiseReactionJob(\n                context, promiseOrCapability, result, reactionType);\n        } catch (e) {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, e, reactionType);\n        }\n      }\n    }\n{% endraw %}\n```\n\nPromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 '123'，handler 是函数 () => {throw new Error('456')}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。\n\nhandler 有值，进入 else 分支，在 try...catch 包裹下，试图调用 handler。handler 里 throw new Error('456') 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。\n\n新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：\n\n![](https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg)\n\nhandler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。\n\n开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error('456')，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error('456')，自己没有相应状态的处理函数，把从 p0 收到的 Error('456') 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg)\n\n还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error('456')，handler 是 (e) => console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try...catch 中试图 handler，handler 不再抛异常，打印 Error('456')，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg)\n\n后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) => console.log(e) 的返回值是 undefined，所以 (data) => console.log(data) 打印 undefined。\n\n执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。\n\n![](https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg)\n\n回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=> console.log(data) 得到执行的机会。\n\n```javascript\n{% raw %}\n    // 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n    // 调用本级的 handler，将本级的 argument 和状态传给下一级\n    // 有点类似数组的 reduce 方法\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n        // 恢复成 fulfilled 状态\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n{% endraw %}\n```\n\n## 总结与感想\n\n本文看似篇幅略长，其实大部分内容是 [Promise A+](https://promisesaplus.com/#notes) 规范的 2.2.7 节，规范简直字字珠玑，膜拜。\n\n![](https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg)\n\n## 转载说明\n\n本文经由作者同意，转载自知乎用户[徐鹏跃](https://www.zhihu.com/people/kan-a-79)\n<a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a>\n","source":"_posts/Promise V8 源码分析(二).md","raw":"---\ntitle: Promise V8 源码分析(二)\ndate: 2020-12-14 14:14:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: 基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。\ncategories: 技术\ntags:\n  - JavaScript\n  - 转载\n---\n\n基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。\n\n## reject\n\n```javascript\n{% raw %}\n    new Promise((resolve, reject) => {\n      setTimeout(_ => reject('rejected'), 5000)\n    }).then(_ => {\n      console.log('fulfilled')\n    }, reason => {\n      console.log(reason)\n    })\n{% endraw %}\n```\n\n上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 [RejectPromise](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210) 函数，源码如下：\n\n```javascript\n{% raw %}\n    transitioning builtin\n    RejectPromise(implicit context: Context)(\n        promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny {\n      // 取出 Promise 的处理对象 PromiseReaction\n      const reactions =\n          UnsafeCast<(Zero | PromiseReaction)>(promise.reactions_or_result);\n      // 这里的 reason 就是 reject 函数的参数\n      promise.reactions_or_result = reason;\n      // 设置 Promise 的状态为 rejected\n      promise.SetStatus(PromiseState::kRejected);\n      TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n      return Undefined;\n    }\n{% endraw %}\n```\n\n[TriggerPromiseReactions](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140) 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：\n\n```javascript\n{% raw %}\n    // https://tc39.es/ecma262/#sec-triggerpromisereactions\n    transitioning macro TriggerPromiseReactions(implicit context: Context)(\n        reactions: Zero|PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      // 删减了链表反转的代码\n      let current = reactions;\n      // reactions 是一个链表，下面的 while 循环遍历链表\n      while (true) {\n        typeswitch (current) {\n          case (Zero): {\n            break;\n          }\n          case (currentReaction: PromiseReaction): {\n            // 取出链表下一个结点\n            current = currentReaction.next;\n            // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n            MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n          }\n        }\n      }\n    }\n{% endraw %}\n```\n\n[MorphAndEnqueuePromiseReaction](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84) 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。\n\nMorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。\n\n```javascript\n{% raw %}\n    transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n        promiseReaction: PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      let primaryHandler: Callable|Undefined;\n      let secondaryHandler: Callable|Undefined;\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        primaryHandler = promiseReaction.fulfill_handler;\n        secondaryHandler = promiseReaction.reject_handler;\n      } else {\n        primaryHandler = promiseReaction.reject_handler;\n        secondaryHandler = promiseReaction.fulfill_handler;\n      }\n      const handlerContext: Context =\n          ExtractHandlerContext(primaryHandler, secondaryHandler);\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        // 删\n      } else {\n        * UnsafeConstCast(& promiseReaction.map) =\n            PromiseRejectReactionJobTaskMapConstant();\n        const promiseReactionJobTask =\n            UnsafeCast<PromiseRejectReactionJobTask>(promiseReaction);\n        // argument 是 reject 的参数\n        promiseReactionJobTask.argument = argument;\n        promiseReactionJobTask.context = handlerContext;\n        // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n        promiseReactionJobTask.handler = primaryHandler;\n        // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n        // EnqueueMicrotask 将 microtask 插入 microtask 队列\n        EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n      }\n    }\n{% endraw %}\n```\n\nreject 和 resolve 的逻辑基本相同，分为 3 步：\n\n- 设置 Promise 的 value/reason，也就是 resolve/reject 的参数\n- 设置 Promise 的状态：fulfilled/rejected\n- 从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列\n\n## catch\n\n```javascript\n{% raw %}\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        console.log('rejected')\n    })\n{% endraw %}\n```\n\n以上面代码为例，当 catch 方法执行时，调用了 V8 的 [PromisePrototypeCatch](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100) 方法，源码如下：\n\n```javascript\n{% raw %}\n    transitioning javascript builtin\n    PromisePrototypeCatch(\n        js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny {\n      const nativeContext = LoadNativeContext(context);\n      return UnsafeCast<JSAny>(\n          InvokeThen(nativeContext, receiver, Undefined, onRejected));\n    }\n{% endraw %}\n```\n\nPromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，[InvokeThen](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199) 源码如下：\n\n```javascript\n{% raw %}\n    transitioning\n    macro InvokeThen<F: type>(implicit context: Context)(\n        nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n        callFunctor: F): JSAny {\n      if (!Is<Smi>(receiver) &&\n          IsPromiseThenLookupChainIntact(\n              nativeContext, UnsafeCast<HeapObject>(receiver).map)) {\n        const then =\n            UnsafeCast<JSAny>(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n        // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n        return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n      } else\n        deferred {\n          const then = UnsafeCast<JSAny>(GetProperty(receiver, kThenString));\n          // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n          return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n        }\n    }\n{% endraw %}\n```\n\nInvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。\n\n既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。\n\n```javascript\n{% raw %}\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        throw 'rejected'\n    }).catch(_ => {\n        console.log('last catch')\n    })\n{% endraw %}\n```\n\n上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。\n\n> catch 方法通过底层调用 then 方法来实现  \n> 假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)\n\n## then 的链式调用与 microtask 队列\n\n```javascript\n{% raw %}\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n{% endraw %}\n```\n\n以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。\n\n```javascript\n{% raw %}\n    const p0 = Promise.resolve('123')\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n{% endraw %}\n```\n\nthen 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。\n\np0 开始便处于 fulfilled 状态，当执行\n\n```javascript\n{% raw %}\n    const p1 = p0.then(() => {throw new Error('456')})\n{% endraw %}\n```\n\n时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n跑完余下所有的代码。\n\n```javascript\n{% raw %}\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n{% endraw %}\n```\n\np1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是\n\n![](https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg)\n\n![](https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg)\n\n开始执行 microtask 队列，核心方法是 [MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114)，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。\n\n在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 [PromiseReactionJob](https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43)，源码如下：\n\n```javascript\n{% raw %}\n    transitioning\n    macro PromiseReactionJob(\n        context: Context, argument: JSAny, handler: Callable|Undefined,\n        promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n        reactionType: constexpr PromiseReactionType): JSAny {\n      if (handler == Undefined) {\n        // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n        if constexpr (reactionType == kPromiseReactionFulfill) {\n          // 基本类同 JS 层的 resolve\n          return FuflfillPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        } else {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        }\n      } else {\n        try {\n          // 试图调用 Promise 处理函数，相当于 handler(argument)\n          const result =\n              Call(context, UnsafeCast<Callable>(handler), Undefined, argument);\n            // 基本类同 JS 层的 resolve\n            return FuflfillPromiseReactionJob(\n                context, promiseOrCapability, result, reactionType);\n        } catch (e) {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, e, reactionType);\n        }\n      }\n    }\n{% endraw %}\n```\n\nPromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 '123'，handler 是函数 () => {throw new Error('456')}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。\n\nhandler 有值，进入 else 分支，在 try...catch 包裹下，试图调用 handler。handler 里 throw new Error('456') 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。\n\n新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：\n\n![](https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg)\n\nhandler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。\n\n开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error('456')，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error('456')，自己没有相应状态的处理函数，把从 p0 收到的 Error('456') 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg)\n\n还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error('456')，handler 是 (e) => console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try...catch 中试图 handler，handler 不再抛异常，打印 Error('456')，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：\n\n![](https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg)\n\n![](https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg)\n\n后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) => console.log(e) 的返回值是 undefined，所以 (data) => console.log(data) 打印 undefined。\n\n执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。\n\n![](https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg)\n\n回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=> console.log(data) 得到执行的机会。\n\n```javascript\n{% raw %}\n    // 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n    // 调用本级的 handler，将本级的 argument 和状态传给下一级\n    // 有点类似数组的 reduce 方法\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n        // 恢复成 fulfilled 状态\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n{% endraw %}\n```\n\n## 总结与感想\n\n本文看似篇幅略长，其实大部分内容是 [Promise A+](https://promisesaplus.com/#notes) 规范的 2.2.7 节，规范简直字字珠玑，膜拜。\n\n![](https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg)\n\n![](https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg)\n\n## 转载说明\n\n本文经由作者同意，转载自知乎用户[徐鹏跃](https://www.zhihu.com/people/kan-a-79)\n<a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a>\n","slug":"Promise V8 源码分析(二)","published":1,"updated":"2021-02-26T06:15:38.356Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0dr002qksup54z4dcbo","content":"<p>基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。</p>\n<h2 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject\"></a>reject</h2><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'rejected'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">5000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fulfilled'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210\">RejectPromise</a> 函数，源码如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    transitioning builtin\n    <span class=\"token function\">RejectPromise</span><span class=\"token punctuation\">(</span>implicit context<span class=\"token punctuation\">:</span> Context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n        promise<span class=\"token punctuation\">:</span> JSPromise<span class=\"token punctuation\">,</span> reason<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span> debugEvent<span class=\"token punctuation\">:</span> Boolean<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> JSAny <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 取出 Promise 的处理对象 PromiseReaction</span>\n      <span class=\"token keyword\">const</span> reactions <span class=\"token operator\">=</span>\n          UnsafeCast<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">(</span>Zero <span class=\"token operator\">|</span> PromiseReaction<span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">.</span>reactions_or_result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 这里的 reason 就是 reject 函数的参数</span>\n      promise<span class=\"token punctuation\">.</span>reactions_or_result <span class=\"token operator\">=</span> reason<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 设置 Promise 的状态为 rejected</span>\n      promise<span class=\"token punctuation\">.</span><span class=\"token function\">SetStatus</span><span class=\"token punctuation\">(</span>PromiseState<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>kRejected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">TriggerPromiseReactions</span><span class=\"token punctuation\">(</span>reactions<span class=\"token punctuation\">,</span> reason<span class=\"token punctuation\">,</span> kPromiseReactionReject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> Undefined<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140\">TriggerPromiseReactions</a> 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// https://tc39.es/ecma262/#sec-triggerpromisereactions</span>\n    transitioning macro <span class=\"token function\">TriggerPromiseReactions</span><span class=\"token punctuation\">(</span>implicit context<span class=\"token punctuation\">:</span> Context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n        reactions<span class=\"token punctuation\">:</span> Zero<span class=\"token operator\">|</span>PromiseReaction<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span>\n        reactionType<span class=\"token punctuation\">:</span> constexpr PromiseReactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// 删减了链表反转的代码</span>\n      <span class=\"token keyword\">let</span> current <span class=\"token operator\">=</span> reactions<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\" spellcheck=\"true\">// reactions 是一个链表，下面的 while 循环遍历链表</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        typeswitch <span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span>Zero<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">case</span> <span class=\"token punctuation\">(</span>currentReaction<span class=\"token punctuation\">:</span> PromiseReaction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 取出链表下一个结点</span>\n            current <span class=\"token operator\">=</span> currentReaction<span class=\"token punctuation\">.</span>next<span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列</span>\n            <span class=\"token function\">MorphAndEnqueuePromiseReaction</span><span class=\"token punctuation\">(</span>currentReaction<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">,</span> reactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84\">MorphAndEnqueuePromiseReaction</a> 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。</p>\n<p>MorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    transitioning macro <span class=\"token function\">MorphAndEnqueuePromiseReaction</span><span class=\"token punctuation\">(</span>implicit context<span class=\"token punctuation\">:</span> Context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n        promiseReaction<span class=\"token punctuation\">:</span> PromiseReaction<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span>\n        reactionType<span class=\"token punctuation\">:</span> constexpr PromiseReactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> primaryHandler<span class=\"token punctuation\">:</span> Callable<span class=\"token operator\">|</span>Undefined<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">let</span> secondaryHandler<span class=\"token punctuation\">:</span> Callable<span class=\"token operator\">|</span>Undefined<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> constexpr <span class=\"token punctuation\">(</span>reactionType <span class=\"token operator\">==</span> kPromiseReactionFulfill<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        primaryHandler <span class=\"token operator\">=</span> promiseReaction<span class=\"token punctuation\">.</span>fulfill_handler<span class=\"token punctuation\">;</span>\n        secondaryHandler <span class=\"token operator\">=</span> promiseReaction<span class=\"token punctuation\">.</span>reject_handler<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        primaryHandler <span class=\"token operator\">=</span> promiseReaction<span class=\"token punctuation\">.</span>reject_handler<span class=\"token punctuation\">;</span>\n        secondaryHandler <span class=\"token operator\">=</span> promiseReaction<span class=\"token punctuation\">.</span>fulfill_handler<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">const</span> handlerContext<span class=\"token punctuation\">:</span> Context <span class=\"token operator\">=</span>\n          <span class=\"token function\">ExtractHandlerContext</span><span class=\"token punctuation\">(</span>primaryHandler<span class=\"token punctuation\">,</span> secondaryHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> constexpr <span class=\"token punctuation\">(</span>reactionType <span class=\"token operator\">==</span> kPromiseReactionFulfill<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 删</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token operator\">*</span> <span class=\"token function\">UnsafeConstCast</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span> promiseReaction<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span>\n            <span class=\"token function\">PromiseRejectReactionJobTaskMapConstant</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">const</span> promiseReactionJobTask <span class=\"token operator\">=</span>\n            UnsafeCast<span class=\"token operator\">&lt;</span>PromiseRejectReactionJobTask<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>promiseReaction<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// argument 是 reject 的参数</span>\n        promiseReactionJobTask<span class=\"token punctuation\">.</span>argument <span class=\"token operator\">=</span> argument<span class=\"token punctuation\">;</span>\n        promiseReactionJobTask<span class=\"token punctuation\">.</span>context <span class=\"token operator\">=</span> handlerContext<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数</span>\n        promiseReactionJobTask<span class=\"token punctuation\">.</span>handler <span class=\"token operator\">=</span> primaryHandler<span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask</span>\n        <span class=\"token comment\" spellcheck=\"true\">// EnqueueMicrotask 将 microtask 插入 microtask 队列</span>\n        <span class=\"token function\">EnqueueMicrotask</span><span class=\"token punctuation\">(</span>handlerContext<span class=\"token punctuation\">,</span> promiseReactionJobTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>reject 和 resolve 的逻辑基本相同，分为 3 步：</p>\n<ul>\n<li>设置 Promise 的 value/reason，也就是 resolve/reject 的参数</li>\n<li>设置 Promise 的状态：fulfilled/rejected</li>\n<li>从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列</li>\n</ul>\n<h2 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch\"></a>catch</h2><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'rejected'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>以上面代码为例，当 catch 方法执行时，调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100\">PromisePrototypeCatch</a> 方法，源码如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    transitioning javascript builtin\n    <span class=\"token function\">PromisePrototypeCatch</span><span class=\"token punctuation\">(</span>\n        js<span class=\"token operator\">-</span>implicit context<span class=\"token punctuation\">:</span> Context<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>onRejected<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> JSAny <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> nativeContext <span class=\"token operator\">=</span> <span class=\"token function\">LoadNativeContext</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> UnsafeCast<span class=\"token operator\">&lt;</span>JSAny<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>\n          <span class=\"token function\">InvokeThen</span><span class=\"token punctuation\">(</span>nativeContext<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">,</span> Undefined<span class=\"token punctuation\">,</span> onRejected<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>PromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，<a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199\">InvokeThen</a> 源码如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    transitioning\n    macro InvokeThen<span class=\"token operator\">&lt;</span>F<span class=\"token punctuation\">:</span> type<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>implicit context<span class=\"token punctuation\">:</span> Context<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>\n        nativeContext<span class=\"token punctuation\">:</span> NativeContext<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span>\n        callFunctor<span class=\"token punctuation\">:</span> F<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> JSAny <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>Is<span class=\"token operator\">&lt;</span>Smi<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>receiver<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n          <span class=\"token function\">IsPromiseThenLookupChainIntact</span><span class=\"token punctuation\">(</span>\n              nativeContext<span class=\"token punctuation\">,</span> UnsafeCast<span class=\"token operator\">&lt;</span>HeapObject<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>receiver<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> then <span class=\"token operator\">=</span>\n            UnsafeCast<span class=\"token operator\">&lt;</span>JSAny<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>nativeContext<span class=\"token punctuation\">[</span>NativeContextSlot<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>PROMISE_THEN_INDEX<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 重点在下面一行，调用 then 方法并返回，两个分支都一样</span>\n        <span class=\"token keyword\">return</span> callFunctor<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span>nativeContext<span class=\"token punctuation\">,</span> then<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span>\n        deferred <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">const</span> then <span class=\"token operator\">=</span> UnsafeCast<span class=\"token operator\">&lt;</span>JSAny<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token function\">GetProperty</span><span class=\"token punctuation\">(</span>receiver<span class=\"token punctuation\">,</span> kThenString<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 重点在下面一行，调用 then 方法并返回，两个分支都一样</span>\n          <span class=\"token keyword\">return</span> callFunctor<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span>nativeContext<span class=\"token punctuation\">,</span> then<span class=\"token punctuation\">,</span> receiver<span class=\"token punctuation\">,</span> arg1<span class=\"token punctuation\">,</span> arg2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>InvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。</p>\n<p>既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">,</span> <span class=\"token number\">2000</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token string\">'rejected'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'last catch'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。</p>\n<blockquote>\n<p>catch 方法通过底层调用 then 方法来实现<br>假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)</p>\n</blockquote>\n<h2 id=\"then-的链式调用与-microtask-队列\"><a href=\"#then-的链式调用与-microtask-队列\" class=\"headerlink\" title=\"then 的链式调用与 microtask 队列\"></a>then 的链式调用与 microtask 队列</h2><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'shouldnot be here'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">const</span> p0 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p1 <span class=\"token operator\">=</span> p0<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p2 <span class=\"token operator\">=</span> p1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'shouldnot be here'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p3 <span class=\"token operator\">=</span> p2<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p4 <span class=\"token operator\">=</span> p3<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>then 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。</p>\n<p>p0 开始便处于 fulfilled 状态，当执行</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">const</span> p1 <span class=\"token operator\">=</span> p0<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<p>时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>跑完余下所有的代码。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">const</span> p1 <span class=\"token operator\">=</span> p0<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p2 <span class=\"token operator\">=</span> p1<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'shouldnot be here'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p3 <span class=\"token operator\">=</span> p2<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> p4 <span class=\"token operator\">=</span> p3<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<p>p1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>开始执行 microtask 队列，核心方法是 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114\">MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask</a>，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。</p>\n<p>在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43\">PromiseReactionJob</a>，源码如下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    transitioning\n    macro <span class=\"token function\">PromiseReactionJob</span><span class=\"token punctuation\">(</span>\n        context<span class=\"token punctuation\">:</span> Context<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">:</span> JSAny<span class=\"token punctuation\">,</span> handler<span class=\"token punctuation\">:</span> Callable<span class=\"token operator\">|</span>Undefined<span class=\"token punctuation\">,</span>\n        promiseOrCapability<span class=\"token punctuation\">:</span> JSPromise<span class=\"token operator\">|</span>PromiseCapability<span class=\"token operator\">|</span>Undefined<span class=\"token punctuation\">,</span>\n        reactionType<span class=\"token punctuation\">:</span> constexpr PromiseReactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> JSAny <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handler <span class=\"token operator\">==</span> Undefined<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 没有处理函数的 case，透传上一个 Promise 的 argument 和状态</span>\n        <span class=\"token keyword\">if</span> constexpr <span class=\"token punctuation\">(</span>reactionType <span class=\"token operator\">==</span> kPromiseReactionFulfill<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 基本类同 JS 层的 resolve</span>\n          <span class=\"token keyword\">return</span> <span class=\"token function\">FuflfillPromiseReactionJob</span><span class=\"token punctuation\">(</span>\n              context<span class=\"token punctuation\">,</span> promiseOrCapability<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">,</span> reactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 基本类同 JS 层的 reject</span>\n          <span class=\"token keyword\">return</span> <span class=\"token function\">RejectPromiseReactionJob</span><span class=\"token punctuation\">(</span>\n              context<span class=\"token punctuation\">,</span> promiseOrCapability<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">,</span> reactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 试图调用 Promise 处理函数，相当于 handler(argument)</span>\n          <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span>\n              <span class=\"token function\">Call</span><span class=\"token punctuation\">(</span>context<span class=\"token punctuation\">,</span> UnsafeCast<span class=\"token operator\">&lt;</span>Callable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>handler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> Undefined<span class=\"token punctuation\">,</span> argument<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 基本类同 JS 层的 resolve</span>\n            <span class=\"token keyword\">return</span> <span class=\"token function\">FuflfillPromiseReactionJob</span><span class=\"token punctuation\">(</span>\n                context<span class=\"token punctuation\">,</span> promiseOrCapability<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">,</span> reactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 基本类同 JS 层的 reject</span>\n          <span class=\"token keyword\">return</span> <span class=\"token function\">RejectPromiseReactionJob</span><span class=\"token punctuation\">(</span>\n              context<span class=\"token punctuation\">,</span> promiseOrCapability<span class=\"token punctuation\">,</span> e<span class=\"token punctuation\">,</span> reactionType<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<p>PromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 ‘123’，handler 是函数 () =&gt; {throw new Error(‘456’)}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。</p>\n<p>handler 有值，进入 else 分支，在 try…catch 包裹下，试图调用 handler。handler 里 throw new Error(‘456’) 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。</p>\n<p>新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：</p>\n<p><img src=\"https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg\"></p>\n<p>handler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。</p>\n<p>开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error(‘456’)，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error(‘456’)，自己没有相应状态的处理函数，把从 p0 收到的 Error(‘456’) 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg\"></p>\n<p>还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error(‘456’)，handler 是 (e) =&gt; console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try…catch 中试图 handler，handler 不再抛异常，打印 Error(‘456’)，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg\"></p>\n<p>后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) =&gt; console.log(e) 的返回值是 undefined，所以 (data) =&gt; console.log(data) 打印 undefined。</p>\n<p>执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg\"></p>\n<p>回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=&gt; console.log(data) 得到执行的机会。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 调用本级的 handler，将本级的 argument 和状态传给下一级</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 有点类似数组的 reduce 方法</span>\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'123'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span><span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">'456'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>_ <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'shouldnot be here'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\" spellcheck=\"true\">// catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 恢复成 fulfilled 状态</span>\n        <span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<h2 id=\"总结与感想\"><a href=\"#总结与感想\" class=\"headerlink\" title=\"总结与感想\"></a>总结与感想</h2><p>本文看似篇幅略长，其实大部分内容是 <a href=\"https://promisesaplus.com/#notes\">Promise A+</a> 规范的 2.2.7 节，规范简直字字珠玑，膜拜。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg\"></p>\n<h2 id=\"转载说明\"><a href=\"#转载说明\" class=\"headerlink\" title=\"转载说明\"></a>转载说明</h2><p>本文经由作者同意，转载自知乎用户<a href=\"https://www.zhihu.com/people/kan-a-79\">徐鹏跃</a><br><a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。</p>\n<h2 id=\"reject\"><a href=\"#reject\" class=\"headerlink\" title=\"reject\"></a>reject</h2><pre><code class=\"javascript\">\n    new Promise((resolve, reject) => {\n      setTimeout(_ => reject('rejected'), 5000)\n    }).then(_ => {\n      console.log('fulfilled')\n    }, reason => {\n      console.log(reason)\n    })\n</code></pre>\n<p>上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210\">RejectPromise</a> 函数，源码如下：</p>\n<pre><code class=\"javascript\">\n    transitioning builtin\n    RejectPromise(implicit context: Context)(\n        promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny {\n      // 取出 Promise 的处理对象 PromiseReaction\n      const reactions =\n          UnsafeCast<(Zero | PromiseReaction)>(promise.reactions_or_result);\n      // 这里的 reason 就是 reject 函数的参数\n      promise.reactions_or_result = reason;\n      // 设置 Promise 的状态为 rejected\n      promise.SetStatus(PromiseState::kRejected);\n      TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);\n      return Undefined;\n    }\n</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140\">TriggerPromiseReactions</a> 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：</p>\n<pre><code class=\"javascript\">\n    // https://tc39.es/ecma262/#sec-triggerpromisereactions\n    transitioning macro TriggerPromiseReactions(implicit context: Context)(\n        reactions: Zero|PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      // 删减了链表反转的代码\n      let current = reactions;\n      // reactions 是一个链表，下面的 while 循环遍历链表\n      while (true) {\n        typeswitch (current) {\n          case (Zero): {\n            break;\n          }\n          case (currentReaction: PromiseReaction): {\n            // 取出链表下一个结点\n            current = currentReaction.next;\n            // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列\n            MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);\n          }\n        }\n      }\n    }\n</code></pre>\n<p><a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84\">MorphAndEnqueuePromiseReaction</a> 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。</p>\n<p>MorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。</p>\n<pre><code class=\"javascript\">\n    transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(\n        promiseReaction: PromiseReaction, argument: JSAny,\n        reactionType: constexpr PromiseReactionType): void {\n      let primaryHandler: Callable|Undefined;\n      let secondaryHandler: Callable|Undefined;\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        primaryHandler = promiseReaction.fulfill_handler;\n        secondaryHandler = promiseReaction.reject_handler;\n      } else {\n        primaryHandler = promiseReaction.reject_handler;\n        secondaryHandler = promiseReaction.fulfill_handler;\n      }\n      const handlerContext: Context =\n          ExtractHandlerContext(primaryHandler, secondaryHandler);\n      if constexpr (reactionType == kPromiseReactionFulfill) {\n        // 删\n      } else {\n        * UnsafeConstCast(& promiseReaction.map) =\n            PromiseRejectReactionJobTaskMapConstant();\n        const promiseReactionJobTask =\n            UnsafeCast<PromiseRejectReactionJobTask>(promiseReaction);\n        // argument 是 reject 的参数\n        promiseReactionJobTask.argument = argument;\n        promiseReactionJobTask.context = handlerContext;\n        // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数\n        promiseReactionJobTask.handler = primaryHandler;\n        // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask\n        // EnqueueMicrotask 将 microtask 插入 microtask 队列\n        EnqueueMicrotask(handlerContext, promiseReactionJobTask);\n      }\n    }\n</code></pre>\n<p>reject 和 resolve 的逻辑基本相同，分为 3 步：</p>\n<ul>\n<li>设置 Promise 的 value/reason，也就是 resolve/reject 的参数</li>\n<li>设置 Promise 的状态：fulfilled/rejected</li>\n<li>从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列</li>\n</ul>\n<h2 id=\"catch\"><a href=\"#catch\" class=\"headerlink\" title=\"catch\"></a>catch</h2><pre><code class=\"javascript\">\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        console.log('rejected')\n    })\n</code></pre>\n<p>以上面代码为例，当 catch 方法执行时，调用了 V8 的 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100\">PromisePrototypeCatch</a> 方法，源码如下：</p>\n<pre><code class=\"javascript\">\n    transitioning javascript builtin\n    PromisePrototypeCatch(\n        js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny {\n      const nativeContext = LoadNativeContext(context);\n      return UnsafeCast<JSAny>(\n          InvokeThen(nativeContext, receiver, Undefined, onRejected));\n    }\n</code></pre>\n<p>PromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，<a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199\">InvokeThen</a> 源码如下：</p>\n<pre><code class=\"javascript\">\n    transitioning\n    macro InvokeThen<F: type>(implicit context: Context)(\n        nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,\n        callFunctor: F): JSAny {\n      if (!Is<Smi>(receiver) &&\n          IsPromiseThenLookupChainIntact(\n              nativeContext, UnsafeCast<HeapObject>(receiver).map)) {\n        const then =\n            UnsafeCast<JSAny>(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);\n        // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n        return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n      } else\n        deferred {\n          const then = UnsafeCast<JSAny>(GetProperty(receiver, kThenString));\n          // 重点在下面一行，调用 then 方法并返回，两个分支都一样\n          return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);\n        }\n    }\n</code></pre>\n<p>InvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。</p>\n<p>既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。</p>\n<pre><code class=\"javascript\">\n    new Promise((resolve, reject) => {\n        setTimeout(reject, 2000)\n    }).catch(_ => {\n        throw 'rejected'\n    }).catch(_ => {\n        console.log('last catch')\n    })\n</code></pre>\n<p>上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。</p>\n<blockquote>\n<p>catch 方法通过底层调用 then 方法来实现<br>假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)</p>\n</blockquote>\n<h2 id=\"then-的链式调用与-microtask-队列\"><a href=\"#then-的链式调用与-microtask-队列\" class=\"headerlink\" title=\"then 的链式调用与 microtask 队列\"></a>then 的链式调用与 microtask 队列</h2><pre><code class=\"javascript\">\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n</code></pre>\n<p>以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。</p>\n<pre><code class=\"javascript\">\n    const p0 = Promise.resolve('123')\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n</code></pre>\n<p>then 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。</p>\n<p>p0 开始便处于 fulfilled 状态，当执行</p>\n<pre><code class=\"javascript\">\n    const p1 = p0.then(() => {throw new Error('456')})\n</code></pre>\n<p>时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>跑完余下所有的代码。</p>\n<pre><code class=\"javascript\">\n    const p1 = p0.then(() => {throw new Error('456')})\n    const p2 = p1.then(_ => {\n        console.log('shouldnot be here')\n    })\n    const p3 = p2.catch((e) => console.log(e))\n    const p4 = p3.then((data) => console.log(data));\n</code></pre>\n<p>p1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是</p>\n<p><img src=\"https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg\"></p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg\"></p>\n<p>开始执行 microtask 队列，核心方法是 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114\">MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask</a>，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。</p>\n<p>在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 <a href=\"https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43\">PromiseReactionJob</a>，源码如下：</p>\n<pre><code class=\"javascript\">\n    transitioning\n    macro PromiseReactionJob(\n        context: Context, argument: JSAny, handler: Callable|Undefined,\n        promiseOrCapability: JSPromise|PromiseCapability|Undefined,\n        reactionType: constexpr PromiseReactionType): JSAny {\n      if (handler == Undefined) {\n        // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态\n        if constexpr (reactionType == kPromiseReactionFulfill) {\n          // 基本类同 JS 层的 resolve\n          return FuflfillPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        } else {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, argument, reactionType);\n        }\n      } else {\n        try {\n          // 试图调用 Promise 处理函数，相当于 handler(argument)\n          const result =\n              Call(context, UnsafeCast<Callable>(handler), Undefined, argument);\n            // 基本类同 JS 层的 resolve\n            return FuflfillPromiseReactionJob(\n                context, promiseOrCapability, result, reactionType);\n        } catch (e) {\n          // 基本类同 JS 层的 reject\n          return RejectPromiseReactionJob(\n              context, promiseOrCapability, e, reactionType);\n        }\n      }\n    }\n</code></pre>\n<p>PromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 ‘123’，handler 是函数 () =&gt; {throw new Error(‘456’)}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。</p>\n<p>handler 有值，进入 else 分支，在 try…catch 包裹下，试图调用 handler。handler 里 throw new Error(‘456’) 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。</p>\n<p>新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：</p>\n<p><img src=\"https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg\"></p>\n<p>handler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。</p>\n<p>开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error(‘456’)，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error(‘456’)，自己没有相应状态的处理函数，把从 p0 收到的 Error(‘456’) 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg\"></p>\n<p>还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error(‘456’)，handler 是 (e) =&gt; console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try…catch 中试图 handler，handler 不再抛异常，打印 Error(‘456’)，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p>\n<p><img src=\"https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg\"></p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg\"></p>\n<p>后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) =&gt; console.log(e) 的返回值是 undefined，所以 (data) =&gt; console.log(data) 打印 undefined。</p>\n<p>执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg\"></p>\n<p>回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=&gt; console.log(data) 得到执行的机会。</p>\n<pre><code class=\"javascript\">\n    // 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)\n    // 调用本级的 handler，将本级的 argument 和状态传给下一级\n    // 有点类似数组的 reduce 方法\n    Promise.resolve('123')\n        .then(() => {throw new Error('456')})\n        .then(_ => {\n            console.log('shouldnot be here')\n        })\n        // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路\n        // 恢复成 fulfilled 状态\n        .catch((e) => console.log(e))\n        .then((data) => console.log(data));\n</code></pre>\n<h2 id=\"总结与感想\"><a href=\"#总结与感想\" class=\"headerlink\" title=\"总结与感想\"></a>总结与感想</h2><p>本文看似篇幅略长，其实大部分内容是 <a href=\"https://promisesaplus.com/#notes\">Promise A+</a> 规范的 2.2.7 节，规范简直字字珠玑，膜拜。</p>\n<p><img src=\"https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg\"></p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg\"></p>\n<h2 id=\"转载说明\"><a href=\"#转载说明\" class=\"headerlink\" title=\"转载说明\"></a>转载说明</h2><p>本文经由作者同意，转载自知乎用户<a href=\"https://www.zhihu.com/people/kan-a-79\">徐鹏跃</a><br><a href=\"https://sm.ms/image/Xvb1CJr7QTI26ei\" target=\"_blank\"><img src=\"https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png\" ></a></p>\n"},{"title":"彻底理解Promise原理及全功能实现","date":"2020-11-20T04:26:22.000Z","author":"heyXiao","summary":"Promise 作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影","_content":"\n# 彻底理解 Promise 原理及全功能实现\n\n## 开篇\n\n**Promise**作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如**Vue**的批量处理等。今天我们就按照**Promise A+** 规范来完整实现**Promise**全功能，话不多说，上代码。\n\n## Promise 实现\n\n### status 状态定义\n\n**Promise**的设定是一个不可逆的状态机，包含：\n\n```javascript\n{% raw %}\n    const PENDDING = \"PENDDING\"; // 初始化pendding状态\n    const RESOLVED = \"RESOLVED\"; // 正确完成resolve状态\n    const REJECTED = \"REJECTED\"; // 错误完成reject状态\n{% endraw %}\n```\n\n### MyPromise\n\n创建**MyPromise**类函数和初始化相对应的值和状态\n\n```javascript\n{% raw %}\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.status = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n          executor(resolve,reject)\n        }catch(e){\n          reject(e)\n        }\n      }\n    }\n{% endraw %}\n```\n\n### MyPromise.then\n\n#### 同步和异步\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 完成状态，推入完成队列\n        if (this.status === RESOLVED) {\n          resolve(this.value);\n        }\n\n        // 拒绝状态，推入拒绝队列\n        if (this.status === REJECTED) {\n          reject(this.reason);\n        }\n\n        // 异步情况\n        if (this.status === PENDDING) {\n          this.resolves.push(resolve);\n          this.rejects.push(reject);\n        }\n      }\n      // ...\n    }\n\n    // 测试同步任务\n\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('promise sync')\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise sync\n\n    // 测试异步任务\n    const promise = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('promise async)\n        }, 500)\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise async\n{% endraw %}\n```\n\n#### Promise A+规范场景\n\n> 根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。\n\n```javascript\n{% raw %}\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      resolve(\"first\");\n    });\n\n    // 第一种场景：返回常规值\n    promise\n      .then((res) => {\n        console.log(res);\n\n        return \"second\";\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // second\n\n    // 第二种场景：返回promise\n    promise\n      .then((res) => {\n        console.log(res);\n        return new Promise((resolve) => {\n          resolve(\"promise\");\n        });\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // promise\n\n    // 第三种场景：值穿透\n    promise\n      .then((res) => {\n        console.log(res);\n        return res;\n      })\n      .then()\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // first\n{% endraw %}\n```\n\n#### 实现 then\n\n根据以上规范定义，我们来改造一下**then**方法：\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason )\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('first')\n    })\n\n    promise.then(res => {\n        console.log(res)\n        return new MyPromise((resolve, reject) => {\n            resolve('promise second')\n        })\n    }).then().then(res => {\n        console.log(res)\n        return 'third'\n    }).then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // first\n    // promise second\n    // third\n{% endraw %}\n```\n\n#### 小结\n\n测试成功，**promise**的改造就算符合规范了。这个难点在于**then**内函数的返回值如果是**promise**，那么我们会先让他执行注册一次**then**，让**promise**接着往下执行。\n\n### MyPromise.catch\n\n**catch**方法相对比较简单，将拒绝的值放到**reject**方法里执行就可以。\n\n#### Promise A+规范场景\n\n```javascript\n{% raw %}\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      reject(\"promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // promise reject\n{% endraw %}\n```\n\n#### 实现 catch\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n      reject(\"my promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // my promise reject\n{% endraw %}\n```\n\n#### 小结\n\n**catch**方法在于执行回调去获取**reject**的结果，所以只需执行一下**then**并传入**callback**就实现了，相对好理解。\n\n### MyPromise.all\n\n业务场景中，我们经常会遇到不止一个**promie**的场景，因此需要合并一次执行多个**promise**，统一返回结果，**Promise.all**就是为了解决此问题。\n\n#### Promise A+规范场景\n\n```javascript\n{% raw %}\n    // Promise A+\n    // 创建三个promise\n    const promise1 = Promise.resolve(1)\n    const promise2 = Promise.resolve(2)\n    const promise3 = Promise.resolve(3)\n\n    Promise.all([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // [1,2,3]\n\n    // 添加一个reject\n    const promise4 = Promise.resolve(1)\n    const promise5 = Promise.reject('reject')\n    const promise6 = Promise.resolve(3)\n\n    Promise.all([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n    // reject\n{% endraw %}\n```\n\n> 根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。\n\n#### 实现 Promise.all\n\n我们来实现一下：\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      // all是静态方法\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    // 创建三个MyPromise\n    const promise1 = MyPromise.resolve(1)\n    const promise2 = MyPromise.resolve(2)\n    const promise3 = MyPromise.resolve(3)\n\n    MyPromise.all([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // [1,2,3]\n\n    // 添加一个reject\n    const promise4 = MyPromise.resolve(1)\n    const promise5 = MyPromise.reject('reject')\n    const promise6 = MyPromise.resolve(3)\n\n    MyPromise.all([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n    // reject\n{% endraw %}\n```\n\n#### 小结\n\n**Promise.all**作为一个批量处理的函数，让我们在使用时可以同时多个处理**promise**，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个**promise**后再去执行下一个**promise**，处理完这个逻辑也就基本完成了**Promise.all**的全功能了。\n\n### MyPromise.resolve\n\n静态方法**resolve**的实现就相对简单了，返回一个**promise**，传入对应参数即可。\n\n#### 实现 MyPromise.resolve\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n      // ...\n    }\n\n    // 测试\n    MyPromise.resolve('static resolve').then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // static resolve\n{% endraw %}\n```\n\n### MyPromise.reject\n\n静态方法**reject**的实现跟**resolve**是类似，返回一个**promise**，传入对应参数即可。\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n      // ...\n    }\n\n    // 测试\n    MyPromise.reject('static reject').catch(e => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // static reject\n{% endraw %}\n```\n\n### 什么是 allSettled？\n\nECMA 官网最新更新了**Promise**的新的静态方法**Promise.allSettled**，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理**Promise**的函数，但是我们已经有了**Promise.all**，为什么还需要**allSettled**。要解开这个问题，我们得回顾一下**Promise.all**。现有的**Promise.all**我们说过，如果**Promise**队列里有一个**reject**，那么他就只会返回**reject**，所以**Promise.all**不一定会返回所有结果，很显然**Promise.allSettled**能够解决这个问题。\n\n#### Promise A+测试场景\n\n```javascript\n{% raw %}\n    // Promise A+\n    // 创建三个promise\n    const promise1 = Promise.resolve(1)\n    const promise2 = Promise.resolve(2)\n    const promise3 = Promise.resolve(3)\n\n    Promise.allSettled([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n\n    // 添加一个reject\n    const promise4 = Promise.resolve(1)\n    const promise5 = Promise.reject('reject')\n    const promise6 = Promise.resolve(3)\n\n    Promise.allSettled([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n      /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n{% endraw %}\n```\n\n可以看出来**allSettled**和 all 最大的区别就是，**allSettled**不管是**resolve**，还是**reject**都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，**status**描述状态，**value**接收返回值。\n\n#### 实现 MyPromise.allSettled\n\n**allSettled**的整体逻辑跟**all**是一样的，只不过返回值的处理稍微有所不同\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n        }\n    // ...\n    }\n\n    // 测试\n    // 创建三个promise\n    const promise1 = MyPromise.resolve(1)\n    const promise2 = MyPromise.resolve(2)\n    const promise3 = MyPromise.resolve(3)\n\n    MyPromise.allSettled([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n\n    // 添加一个reject\n    const promise4 = MyPromise.resolve(1)\n    const promise5 = MyPromise.reject('reject')\n    const promise6 = MyPromise.resolve(3)\n\n    Promise.allSettled([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n      /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n{% endraw %}\n```\n\n## 完整代码\n\n```javascript\n{% raw %}\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.statue = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n\n      // then\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n\n      // resolve\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n\n        // reject\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n\n      // all\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n\n      // allSettled\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n    }\n{% endraw %}\n```\n\n## 总结\n\n至此**Promise A+**的完整的方法和实现就完成了，个人觉得实现**promise**的难点在于理解**then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然\n\n## 关于转载\n\n转载自[掘金](https://juejin.cn/post/6866372840451473415#heading-0) 作者[MichaelHong](https://juejin.cn/user/448256474885159)\n","source":"_posts/彻底理解Promise原理及全功能实现.md","raw":"---\ntitle: 彻底理解Promise原理及全功能实现\ndate: 2020-11-20 12:26:22\nauthor: heyXiao\n# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d\nsummary: Promise 作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影\ncategories: 技术\ntags:\n  - JavaScript\n  - 转载\n---\n\n# 彻底理解 Promise 原理及全功能实现\n\n## 开篇\n\n**Promise**作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如**Vue**的批量处理等。今天我们就按照**Promise A+** 规范来完整实现**Promise**全功能，话不多说，上代码。\n\n## Promise 实现\n\n### status 状态定义\n\n**Promise**的设定是一个不可逆的状态机，包含：\n\n```javascript\n{% raw %}\n    const PENDDING = \"PENDDING\"; // 初始化pendding状态\n    const RESOLVED = \"RESOLVED\"; // 正确完成resolve状态\n    const REJECTED = \"REJECTED\"; // 错误完成reject状态\n{% endraw %}\n```\n\n### MyPromise\n\n创建**MyPromise**类函数和初始化相对应的值和状态\n\n```javascript\n{% raw %}\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.status = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n          executor(resolve,reject)\n        }catch(e){\n          reject(e)\n        }\n      }\n    }\n{% endraw %}\n```\n\n### MyPromise.then\n\n#### 同步和异步\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 完成状态，推入完成队列\n        if (this.status === RESOLVED) {\n          resolve(this.value);\n        }\n\n        // 拒绝状态，推入拒绝队列\n        if (this.status === REJECTED) {\n          reject(this.reason);\n        }\n\n        // 异步情况\n        if (this.status === PENDDING) {\n          this.resolves.push(resolve);\n          this.rejects.push(reject);\n        }\n      }\n      // ...\n    }\n\n    // 测试同步任务\n\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('promise sync')\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise sync\n\n    // 测试异步任务\n    const promise = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('promise async)\n        }, 500)\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise async\n{% endraw %}\n```\n\n#### Promise A+规范场景\n\n> 根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。\n\n```javascript\n{% raw %}\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      resolve(\"first\");\n    });\n\n    // 第一种场景：返回常规值\n    promise\n      .then((res) => {\n        console.log(res);\n\n        return \"second\";\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // second\n\n    // 第二种场景：返回promise\n    promise\n      .then((res) => {\n        console.log(res);\n        return new Promise((resolve) => {\n          resolve(\"promise\");\n        });\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // promise\n\n    // 第三种场景：值穿透\n    promise\n      .then((res) => {\n        console.log(res);\n        return res;\n      })\n      .then()\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // first\n{% endraw %}\n```\n\n#### 实现 then\n\n根据以上规范定义，我们来改造一下**then**方法：\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason )\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('first')\n    })\n\n    promise.then(res => {\n        console.log(res)\n        return new MyPromise((resolve, reject) => {\n            resolve('promise second')\n        })\n    }).then().then(res => {\n        console.log(res)\n        return 'third'\n    }).then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // first\n    // promise second\n    // third\n{% endraw %}\n```\n\n#### 小结\n\n测试成功，**promise**的改造就算符合规范了。这个难点在于**then**内函数的返回值如果是**promise**，那么我们会先让他执行注册一次**then**，让**promise**接着往下执行。\n\n### MyPromise.catch\n\n**catch**方法相对比较简单，将拒绝的值放到**reject**方法里执行就可以。\n\n#### Promise A+规范场景\n\n```javascript\n{% raw %}\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      reject(\"promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // promise reject\n{% endraw %}\n```\n\n#### 实现 catch\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n      reject(\"my promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // my promise reject\n{% endraw %}\n```\n\n#### 小结\n\n**catch**方法在于执行回调去获取**reject**的结果，所以只需执行一下**then**并传入**callback**就实现了，相对好理解。\n\n### MyPromise.all\n\n业务场景中，我们经常会遇到不止一个**promie**的场景，因此需要合并一次执行多个**promise**，统一返回结果，**Promise.all**就是为了解决此问题。\n\n#### Promise A+规范场景\n\n```javascript\n{% raw %}\n    // Promise A+\n    // 创建三个promise\n    const promise1 = Promise.resolve(1)\n    const promise2 = Promise.resolve(2)\n    const promise3 = Promise.resolve(3)\n\n    Promise.all([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // [1,2,3]\n\n    // 添加一个reject\n    const promise4 = Promise.resolve(1)\n    const promise5 = Promise.reject('reject')\n    const promise6 = Promise.resolve(3)\n\n    Promise.all([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n    // reject\n{% endraw %}\n```\n\n> 根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。\n\n#### 实现 Promise.all\n\n我们来实现一下：\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      // all是静态方法\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    // 创建三个MyPromise\n    const promise1 = MyPromise.resolve(1)\n    const promise2 = MyPromise.resolve(2)\n    const promise3 = MyPromise.resolve(3)\n\n    MyPromise.all([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // [1,2,3]\n\n    // 添加一个reject\n    const promise4 = MyPromise.resolve(1)\n    const promise5 = MyPromise.reject('reject')\n    const promise6 = MyPromise.resolve(3)\n\n    MyPromise.all([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n    // reject\n{% endraw %}\n```\n\n#### 小结\n\n**Promise.all**作为一个批量处理的函数，让我们在使用时可以同时多个处理**promise**，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个**promise**后再去执行下一个**promise**，处理完这个逻辑也就基本完成了**Promise.all**的全功能了。\n\n### MyPromise.resolve\n\n静态方法**resolve**的实现就相对简单了，返回一个**promise**，传入对应参数即可。\n\n#### 实现 MyPromise.resolve\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n      // ...\n    }\n\n    // 测试\n    MyPromise.resolve('static resolve').then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // static resolve\n{% endraw %}\n```\n\n### MyPromise.reject\n\n静态方法**reject**的实现跟**resolve**是类似，返回一个**promise**，传入对应参数即可。\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n      // ...\n    }\n\n    // 测试\n    MyPromise.reject('static reject').catch(e => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // static reject\n{% endraw %}\n```\n\n### 什么是 allSettled？\n\nECMA 官网最新更新了**Promise**的新的静态方法**Promise.allSettled**，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理**Promise**的函数，但是我们已经有了**Promise.all**，为什么还需要**allSettled**。要解开这个问题，我们得回顾一下**Promise.all**。现有的**Promise.all**我们说过，如果**Promise**队列里有一个**reject**，那么他就只会返回**reject**，所以**Promise.all**不一定会返回所有结果，很显然**Promise.allSettled**能够解决这个问题。\n\n#### Promise A+测试场景\n\n```javascript\n{% raw %}\n    // Promise A+\n    // 创建三个promise\n    const promise1 = Promise.resolve(1)\n    const promise2 = Promise.resolve(2)\n    const promise3 = Promise.resolve(3)\n\n    Promise.allSettled([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n\n    // 添加一个reject\n    const promise4 = Promise.resolve(1)\n    const promise5 = Promise.reject('reject')\n    const promise6 = Promise.resolve(3)\n\n    Promise.allSettled([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n      /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n{% endraw %}\n```\n\n可以看出来**allSettled**和 all 最大的区别就是，**allSettled**不管是**resolve**，还是**reject**都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，**status**描述状态，**value**接收返回值。\n\n#### 实现 MyPromise.allSettled\n\n**allSettled**的整体逻辑跟**all**是一样的，只不过返回值的处理稍微有所不同\n\n```javascript\n{% raw %}\n    class MyPromise {\n      // ...\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n        }\n    // ...\n    }\n\n    // 测试\n    // 创建三个promise\n    const promise1 = MyPromise.resolve(1)\n    const promise2 = MyPromise.resolve(2)\n    const promise3 = MyPromise.resolve(3)\n\n    MyPromise.allSettled([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n\n    // 添加一个reject\n    const promise4 = MyPromise.resolve(1)\n    const promise5 = MyPromise.reject('reject')\n    const promise6 = MyPromise.resolve(3)\n\n    Promise.allSettled([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n      /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n{% endraw %}\n```\n\n## 完整代码\n\n```javascript\n{% raw %}\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.statue = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n\n      // then\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n\n      // resolve\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n\n        // reject\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n\n      // all\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n\n      // allSettled\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n    }\n{% endraw %}\n```\n\n## 总结\n\n至此**Promise A+**的完整的方法和实现就完成了，个人觉得实现**promise**的难点在于理解**then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然\n\n## 关于转载\n\n转载自[掘金](https://juejin.cn/post/6866372840451473415#heading-0) 作者[MichaelHong](https://juejin.cn/user/448256474885159)\n","slug":"彻底理解Promise原理及全功能实现","published":1,"updated":"2021-02-26T06:08:21.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckn5cb0dt002tksupc5su1nj6","content":"<h1 id=\"彻底理解-Promise-原理及全功能实现\"><a href=\"#彻底理解-Promise-原理及全功能实现\" class=\"headerlink\" title=\"彻底理解 Promise 原理及全功能实现\"></a>彻底理解 Promise 原理及全功能实现</h1><h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p><strong>Promise</strong>作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如<strong>Vue</strong>的批量处理等。今天我们就按照<strong>Promise A+</strong> 规范来完整实现<strong>Promise</strong>全功能，话不多说，上代码。</p>\n<h2 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h2><h3 id=\"status-状态定义\"><a href=\"#status-状态定义\" class=\"headerlink\" title=\"status 状态定义\"></a>status 状态定义</h3><p><strong>Promise</strong>的设定是一个不可逆的状态机，包含：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">const</span> PENDDING <span class=\"token operator\">=</span> <span class=\"token string\">\"PENDDING\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 初始化pendding状态</span>\n    <span class=\"token keyword\">const</span> RESOLVED <span class=\"token operator\">=</span> <span class=\"token string\">\"RESOLVED\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 正确完成resolve状态</span>\n    <span class=\"token keyword\">const</span> REJECTED <span class=\"token operator\">=</span> <span class=\"token string\">\"REJECTED\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 错误完成reject状态</span>\n</code></pre>\n<h3 id=\"MyPromise\"><a href=\"#MyPromise\" class=\"headerlink\" title=\"MyPromise\"></a>MyPromise</h3><p>创建<strong>MyPromise</strong>类函数和初始化相对应的值和状态</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>executor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 初始化状态status</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 返回值value</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 错误原因reason</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> PENDDING<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 返回值回调队列和错误回调队列</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 声明resolve函数</span>\n        <span class=\"token keyword\">const</span> resolve <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> PENDDING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> RESOLVED<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 变更状态为完成状态</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 赋值</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 执行resolves队列</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 声明reject函数</span>\n        <span class=\"token keyword\">const</span> reject <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statue <span class=\"token operator\">===</span> PENDDING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> REJECTED<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 变更状态为拒绝状态</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason <span class=\"token operator\">=</span> reason<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 赋值</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 执行rejects队列</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n          <span class=\"token function\">executor</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"MyPromise-then\"><a href=\"#MyPromise-then\" class=\"headerlink\" title=\"MyPromise.then\"></a>MyPromise.then</h3><h4 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h4><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 完成状态，推入完成队列</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> RESOLVED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 拒绝状态，推入拒绝队列</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> REJECTED<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 异步情况</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> PENDDING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>reject<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试同步任务</span>\n\n    <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise sync'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// promise sync</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试异步任务</span>\n    <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>'promise <span class=\"token keyword\">async</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// promise async</span>\n</code></pre>\n<h4 id=\"Promise-A-规范场景\"><a href=\"#Promise-A-规范场景\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><blockquote>\n<p>根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。</p>\n</blockquote>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// Promise A+</span>\n    <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"first\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 第一种场景：返回常规值</span>\n    promise\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"second\"</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// first</span>\n    <span class=\"token comment\" spellcheck=\"true\">// second</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 第二种场景：返回promise</span>\n    promise\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// first</span>\n    <span class=\"token comment\" spellcheck=\"true\">// promise</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 第三种场景：值穿透</span>\n    promise\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> res<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// first</span>\n    <span class=\"token comment\" spellcheck=\"true\">// first</span>\n</code></pre>\n<h4 id=\"实现-then\"><a href=\"#实现-then\" class=\"headerlink\" title=\"实现 then\"></a>实现 then</h4><p>根据以上规范定义，我们来改造一下<strong>then</strong>方法：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 判断resolve和reject未传入的情况，解决空值透传问题</span>\n        <span class=\"token comment\" spellcheck=\"true\">// then()情况</span>\n        <span class=\"token keyword\">typeof</span> resolve <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span> resolve <span class=\"token operator\">=</span> value <span class=\"token operator\">=</span><span class=\"token operator\">></span> value <span class=\"token punctuation\">:</span> resolve\n        <span class=\"token keyword\">typeof</span> reject <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span> reject <span class=\"token operator\">=</span> reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>reason <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span> <span class=\"token operator\">?</span> reason<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">:</span> reason <span class=\"token punctuation\">)</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">//根据规范，then会返回一个全新的promise</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span> rejectFn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 重写传入的resolve方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 判断返回值</span>\n            <span class=\"token keyword\">const</span> fulfilished <span class=\"token operator\">=</span> value <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 接收返回值</span>\n                    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">// 判断返回值类型：promise或普通类型</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是promise，则往下执行一次then</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是普通类型，则直接执行resolveFn，保证value是最新值</span>\n                    res <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token operator\">?</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span>rejectFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolveFn</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 重写传入的reject方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 判断返回值</span>\n            <span class=\"token keyword\">const</span> rejected <span class=\"token operator\">=</span> reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 接收返回值</span>\n                    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">// 判断返回值类型：promise或普通类型</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是promise，则往下执行一次then</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是普通类型，则直接执行rejectFn，保证value是最新值</span>\n                    res <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token operator\">?</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span>rejectFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span> <span class=\"token operator\">?</span> e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">:</span> e<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 判断同步异步任务</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 执行相对应的方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 这里用switch方法改进</span>\n            <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">case</span> RESOLVED<span class=\"token punctuation\">:</span>\n                    <span class=\"token function\">fulfilished</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">case</span> REJECTED<span class=\"token punctuation\">:</span>\n                    <span class=\"token function\">rejected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">case</span> PENDDING<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>fulfilished<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>rejected<span class=\"token punctuation\">)</span>\n                  <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试</span>\n    <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'first'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise second'</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">'third'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// first</span>\n    <span class=\"token comment\" spellcheck=\"true\">// promise second</span>\n    <span class=\"token comment\" spellcheck=\"true\">// third</span>\n</code></pre>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>测试成功，<strong>promise</strong>的改造就算符合规范了。这个难点在于<strong>then</strong>内函数的返回值如果是<strong>promise</strong>，那么我们会先让他执行注册一次<strong>then</strong>，让<strong>promise</strong>接着往下执行。</p>\n<h3 id=\"MyPromise-catch\"><a href=\"#MyPromise-catch\" class=\"headerlink\" title=\"MyPromise.catch\"></a>MyPromise.catch</h3><p><strong>catch</strong>方法相对比较简单，将拒绝的值放到<strong>reject</strong>方法里执行就可以。</p>\n<h4 id=\"Promise-A-规范场景-1\"><a href=\"#Promise-A-规范场景-1\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// Promise A+</span>\n    <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"promise reject\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    promise<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// promise reject</span>\n</code></pre>\n<h4 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch\"></a>实现 catch</h4><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>errorFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 这里只需注册执行下then，传入callback就能实现</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorFn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试</span>\n    <span class=\"token keyword\">const</span> promise <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"my promise reject\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    promise<span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// my promise reject</span>\n</code></pre>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>catch</strong>方法在于执行回调去获取<strong>reject</strong>的结果，所以只需执行一下<strong>then</strong>并传入<strong>callback</strong>就实现了，相对好理解。</p>\n<h3 id=\"MyPromise-all\"><a href=\"#MyPromise-all\" class=\"headerlink\" title=\"MyPromise.all\"></a>MyPromise.all</h3><p>业务场景中，我们经常会遇到不止一个<strong>promie</strong>的场景，因此需要合并一次执行多个<strong>promise</strong>，统一返回结果，<strong>Promise.all</strong>就是为了解决此问题。</p>\n<h4 id=\"Promise-A-规范场景-2\"><a href=\"#Promise-A-规范场景-2\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// Promise A+</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 创建三个promise</span>\n    <span class=\"token keyword\">const</span> promise1 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise2 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise3 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise1<span class=\"token punctuation\">,</span>promise12<span class=\"token punctuation\">,</span>promise3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// [1,2,3]</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 添加一个reject</span>\n    <span class=\"token keyword\">const</span> promise4 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise5 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'reject'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise6 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise4<span class=\"token punctuation\">,</span> promise5<span class=\"token punctuation\">,</span>promise6<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token string\">'resolve'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// reject</span>\n</code></pre>\n<blockquote>\n<p>根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。</p>\n</blockquote>\n<h4 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h4><p>我们来实现一下：</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token comment\" spellcheck=\"true\">// all是静态方法</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">all</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 已然是返回一个promise</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 创建一个收集返回值的数组</span>\n          <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 执行</span>\n          <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 返回结果</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 这里我们用递归来实现</span>\n          <span class=\"token comment\" spellcheck=\"true\">// @param {MyPromise} promise 每一个promise方法</span>\n          <span class=\"token comment\" spellcheck=\"true\">// @param {number} index 索引</span>\n          <span class=\"token comment\" spellcheck=\"true\">// @param {string[]} result 收集返回结果的数组</span>\n          <span class=\"token keyword\">function</span> <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 边界判断</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 所有执行完之后返回收集数组</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> promises<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">return</span> result\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> promise<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 如果是promise</span>\n              promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                index<span class=\"token operator\">++</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// reject直接返回</span>\n                <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span> <span class=\"token operator\">?</span> e<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">:</span> e<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 如果是普通值</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 这里我们只做简单判断，非promise则直接当返回值处理</span>\n              index<span class=\"token operator\">++</span>\n              result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">)</span>\n              <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 创建三个MyPromise</span>\n    <span class=\"token keyword\">const</span> promise1 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise2 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise3 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise1<span class=\"token punctuation\">,</span>promise12<span class=\"token punctuation\">,</span>promise3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// [1,2,3]</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 添加一个reject</span>\n    <span class=\"token keyword\">const</span> promise4 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise5 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'reject'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise6 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">all</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise4<span class=\"token punctuation\">,</span> promise5<span class=\"token punctuation\">,</span>promise6<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token string\">'resolve'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// reject</span>\n</code></pre>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>Promise.all</strong>作为一个批量处理的函数，让我们在使用时可以同时多个处理<strong>promise</strong>，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个<strong>promise</strong>后再去执行下一个<strong>promise</strong>，处理完这个逻辑也就基本完成了<strong>Promise.all</strong>的全功能了。</p>\n<h3 id=\"MyPromise-resolve\"><a href=\"#MyPromise-resolve\" class=\"headerlink\" title=\"MyPromise.resolve\"></a>MyPromise.resolve</h3><p>静态方法<strong>resolve</strong>的实现就相对简单了，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<h4 id=\"实现-MyPromise-resolve\"><a href=\"#实现-MyPromise-resolve\" class=\"headerlink\" title=\"实现 MyPromise.resolve\"></a>实现 MyPromise.resolve</h4><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span> rejectFn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolveFn</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试</span>\n    MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'static resolve'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// static resolve</span>\n</code></pre>\n<h3 id=\"MyPromise-reject\"><a href=\"#MyPromise-reject\" class=\"headerlink\" title=\"MyPromise.reject\"></a>MyPromise.reject</h3><p>静态方法<strong>reject</strong>的实现跟<strong>resolve</strong>是类似，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span> rejectFn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试</span>\n    MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'static reject'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">// static reject</span>\n</code></pre>\n<h3 id=\"什么是-allSettled？\"><a href=\"#什么是-allSettled？\" class=\"headerlink\" title=\"什么是 allSettled？\"></a>什么是 allSettled？</h3><p>ECMA 官网最新更新了<strong>Promise</strong>的新的静态方法<strong>Promise.allSettled</strong>，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理<strong>Promise</strong>的函数，但是我们已经有了<strong>Promise.all</strong>，为什么还需要<strong>allSettled</strong>。要解开这个问题，我们得回顾一下<strong>Promise.all</strong>。现有的<strong>Promise.all</strong>我们说过，如果<strong>Promise</strong>队列里有一个<strong>reject</strong>，那么他就只会返回<strong>reject</strong>，所以<strong>Promise.all</strong>不一定会返回所有结果，很显然<strong>Promise.allSettled</strong>能够解决这个问题。</p>\n<h4 id=\"Promise-A-测试场景\"><a href=\"#Promise-A-测试场景\" class=\"headerlink\" title=\"Promise A+测试场景\"></a>Promise A+测试场景</h4><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token comment\" spellcheck=\"true\">// Promise A+</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 创建三个promise</span>\n    <span class=\"token keyword\">const</span> promise1 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise2 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise3 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise1<span class=\"token punctuation\">,</span>promise12<span class=\"token punctuation\">,</span>promise3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 添加一个reject</span>\n    <span class=\"token keyword\">const</span> promise4 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise5 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'reject'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise6 <span class=\"token operator\">=</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise4<span class=\"token punctuation\">,</span> promise5<span class=\"token punctuation\">,</span>promise6<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token string\">'resolve'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n      <span class=\"token comment\" spellcheck=\"true\">/*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */</span>\n</code></pre>\n<p>可以看出来<strong>allSettled</strong>和 all 最大的区别就是，<strong>allSettled</strong>不管是<strong>resolve</strong>，还是<strong>reject</strong>都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，<strong>status</strong>描述状态，<strong>value</strong>接收返回值。</p>\n<h4 id=\"实现-MyPromise-allSettled\"><a href=\"#实现-MyPromise-allSettled\" class=\"headerlink\" title=\"实现 MyPromise.allSettled\"></a>实现 MyPromise.allSettled</h4><p><strong>allSettled</strong>的整体逻辑跟<strong>all</strong>是一样的，只不过返回值的处理稍微有所不同</p>\n<pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 已然是返回一个promise</span>\n          <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 创建一个收集返回值的数组</span>\n            <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 执行</span>\n            <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 返回结果</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 这里我们用递归来实现</span>\n            <span class=\"token comment\" spellcheck=\"true\">// @param {MyPromise} promise 每一个promise方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// @param {number} index 索引</span>\n            <span class=\"token comment\" spellcheck=\"true\">// @param {string[]} result 收集返回结果的数组</span>\n            <span class=\"token keyword\">function</span> <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 边界判断</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 所有执行完之后返回收集数组</span>\n              <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> promises<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> result\n              <span class=\"token punctuation\">}</span>\n\n              <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> promise<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果是promise</span>\n                promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                  index<span class=\"token operator\">++</span>\n                  result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token string\">'fulfilished'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> res<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这里推入的是对象</span>\n                  <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token comment\" spellcheck=\"true\">// reject直接返回</span>\n                  index <span class=\"token operator\">++</span>\n                  result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token string\">'rejected'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> res<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这里推入的是对象</span>\n                  <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果是普通值</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 这里我们只做简单判断，非promise则直接当返回值处理</span>\n                index<span class=\"token operator\">++</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token string\">'fulfilished'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> res<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这里推入的是对象</span>\n                <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\" spellcheck=\"true\">// ...</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 测试</span>\n    <span class=\"token comment\" spellcheck=\"true\">// 创建三个promise</span>\n    <span class=\"token keyword\">const</span> promise1 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise2 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise3 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise1<span class=\"token punctuation\">,</span>promise12<span class=\"token punctuation\">,</span>promise3<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n    <span class=\"token comment\" spellcheck=\"true\">/*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 添加一个reject</span>\n    <span class=\"token keyword\">const</span> promise4 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise5 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'reject'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> promise6 <span class=\"token operator\">=</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span>\n\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>promise4<span class=\"token punctuation\">,</span> promise5<span class=\"token punctuation\">,</span>promise6<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">,</span> <span class=\"token string\">'resolve'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">// 打印结果</span>\n      <span class=\"token comment\" spellcheck=\"true\">/*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */</span>\n</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre class=\" language-javascript\"><code class=\"language-javascript\">\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>executor<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 初始化状态status</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 返回值value</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 错误原因reason</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statue <span class=\"token operator\">=</span> PENDDING<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason <span class=\"token operator\">=</span> undefined<span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 返回值回调队列和错误回调队列</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 声明resolve函数</span>\n        <span class=\"token keyword\">const</span> resolve <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">===</span> PENDDING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> RESOLVED<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 变更状态为完成状态</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value <span class=\"token operator\">=</span> value<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 赋值</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 执行resolves队列</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// 声明reject函数</span>\n        <span class=\"token keyword\">const</span> reject <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>statue <span class=\"token operator\">===</span> PENDDING<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status <span class=\"token operator\">=</span> REJECTED<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 变更状态为拒绝状态</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason <span class=\"token operator\">=</span> reason<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">// 赋值</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 执行rejects队列</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span><span class=\"token function\">shift</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n        \t<span class=\"token function\">executor</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span>reject<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        \t<span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// then</span>\n      <span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 判断resolve和reject未传入的情况，解决空值透传问题</span>\n        <span class=\"token comment\" spellcheck=\"true\">// then()情况</span>\n        <span class=\"token keyword\">typeof</span> resolve <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span> resolve <span class=\"token operator\">=</span> value <span class=\"token operator\">=</span><span class=\"token operator\">></span> value <span class=\"token punctuation\">:</span> resolve\n        <span class=\"token keyword\">typeof</span> reject <span class=\"token operator\">!==</span> <span class=\"token string\">'function'</span> <span class=\"token operator\">?</span> reject <span class=\"token operator\">=</span> reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span>reason <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span> <span class=\"token operator\">?</span> reason<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">:</span> reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span> reject\n\n        <span class=\"token comment\" spellcheck=\"true\">//根据规范，then会返回一个全新的promise</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span> rejectFn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 重写传入的resolve方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 判断返回值</span>\n            <span class=\"token keyword\">const</span> fulfilished <span class=\"token operator\">=</span> value <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 接收返回值</span>\n                    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">// 判断返回值类型：promise或普通类型</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是promise，则往下执行一次then</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是普通类型，则直接执行resolveFn，保证value是最新值</span>\n                    res <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token operator\">?</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span>rejectFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">resolveFn</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 重写传入的reject方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 判断返回值</span>\n            <span class=\"token keyword\">const</span> rejected <span class=\"token operator\">=</span> reason <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 接收返回值</span>\n                    <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span>\n\n                    <span class=\"token comment\" spellcheck=\"true\">// 判断返回值类型：promise或普通类型</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是promise，则往下执行一次then</span>\n                    <span class=\"token comment\" spellcheck=\"true\">// 如果是普通类型，则直接执行rejectFn，保证value是最新值</span>\n                    res <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">MyPromise</span> <span class=\"token operator\">?</span> MyPromise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span>rejectFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                    <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span> <span class=\"token operator\">?</span> e<span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">:</span> e<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span>\n\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 判断同步异步任务</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 执行相对应的方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 这里用switch方法改进</span>\n            <span class=\"token keyword\">switch</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>status<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">case</span> RESOLVED<span class=\"token punctuation\">:</span>\n                    <span class=\"token function\">fulfilished</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">case</span> REJECTED<span class=\"token punctuation\">:</span>\n                    <span class=\"token function\">rejected</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>reason<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token keyword\">case</span> PENDDING<span class=\"token punctuation\">:</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>resolves<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>fulfilished<span class=\"token punctuation\">)</span>\n                    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>rejects<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>rejected<span class=\"token punctuation\">)</span>\n                  <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>errorFn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 这里只需注册执行下then，传入callback就能实现</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> errorFn<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// resolve</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span> rejectFn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">resolveFn</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\" spellcheck=\"true\">// reject</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolveFn<span class=\"token punctuation\">,</span> rejectFn<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">rejectFn</span><span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// all</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">all</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\" spellcheck=\"true\">// 已然是返回一个promise</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 创建一个收集返回值的数组</span>\n          <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 执行</span>\n          <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 返回结果</span>\n          <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n\n          <span class=\"token comment\" spellcheck=\"true\">// 这里我们用递归来实现</span>\n          <span class=\"token comment\" spellcheck=\"true\">// @param {MyPromise} promise 每一个promise方法</span>\n          <span class=\"token comment\" spellcheck=\"true\">// @param {number} index 索引</span>\n          <span class=\"token comment\" spellcheck=\"true\">// @param {string[]} result 收集返回结果的数组</span>\n          <span class=\"token keyword\">function</span> <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 边界判断</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 所有执行完之后返回收集数组</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> promises<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">return</span> result\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> promise<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 如果是promise</span>\n              promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                index<span class=\"token operator\">++</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span>\n                <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// reject直接返回</span>\n                <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span>e <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Error</span> <span class=\"token operator\">?</span> e<span class=\"token punctuation\">.</span>message <span class=\"token punctuation\">:</span> e<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 如果是普通值</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 这里我们只做简单判断，非promise则直接当返回值处理</span>\n              index<span class=\"token operator\">++</span>\n              result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">)</span>\n              <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">// allSettled</span>\n      <span class=\"token keyword\">static</span> <span class=\"token function\">allSettled</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\" spellcheck=\"true\">// 已然是返回一个promise</span>\n          <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\" spellcheck=\"true\">// 创建一个收集返回值的数组</span>\n            <span class=\"token keyword\">const</span> result <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 执行</span>\n            <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 返回结果</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span>\n\n            <span class=\"token comment\" spellcheck=\"true\">// 这里我们用递归来实现</span>\n            <span class=\"token comment\" spellcheck=\"true\">// @param {MyPromise} promise 每一个promise方法</span>\n            <span class=\"token comment\" spellcheck=\"true\">// @param {number} index 索引</span>\n            <span class=\"token comment\" spellcheck=\"true\">// @param {string[]} result 收集返回结果的数组</span>\n            <span class=\"token keyword\">function</span> <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promise<span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 边界判断</span>\n              <span class=\"token comment\" spellcheck=\"true\">// 所有执行完之后返回收集数组</span>\n              <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>index <span class=\"token operator\">></span> promises<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">return</span> result\n              <span class=\"token punctuation\">}</span>\n\n              <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> promise<span class=\"token punctuation\">.</span>then <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果是promise</span>\n                promise<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>res <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                  index<span class=\"token operator\">++</span>\n                  result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token string\">'fulfilished'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> res<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这里推入的是对象</span>\n                  <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token comment\" spellcheck=\"true\">// reject直接返回</span>\n                  index <span class=\"token operator\">++</span>\n                  result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token string\">'rejected'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> res<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这里推入的是对象</span>\n                  <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 如果是普通值</span>\n                <span class=\"token comment\" spellcheck=\"true\">// 这里我们只做简单判断，非promise则直接当返回值处理</span>\n                index<span class=\"token operator\">++</span>\n                result<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>status<span class=\"token punctuation\">:</span> <span class=\"token string\">'fulfilished'</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">:</span> res<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">// 这里推入的是对象</span>\n                <span class=\"token function\">deepPromise</span><span class=\"token punctuation\">(</span>promises<span class=\"token punctuation\">[</span>index<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> index<span class=\"token punctuation\">,</span> res<span class=\"token punctuation\">)</span>\n              <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此<strong>Promise A+**的完整的方法和实现就完成了，个人觉得实现</strong>promise<strong>的难点在于理解</strong>then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然</p>\n<h2 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h2><p>转载自<a href=\"https://juejin.cn/post/6866372840451473415#heading-0\">掘金</a> 作者<a href=\"https://juejin.cn/user/448256474885159\">MichaelHong</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"彻底理解-Promise-原理及全功能实现\"><a href=\"#彻底理解-Promise-原理及全功能实现\" class=\"headerlink\" title=\"彻底理解 Promise 原理及全功能实现\"></a>彻底理解 Promise 原理及全功能实现</h1><h2 id=\"开篇\"><a href=\"#开篇\" class=\"headerlink\" title=\"开篇\"></a>开篇</h2><p><strong>Promise</strong>作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如<strong>Vue</strong>的批量处理等。今天我们就按照<strong>Promise A+</strong> 规范来完整实现<strong>Promise</strong>全功能，话不多说，上代码。</p>\n<h2 id=\"Promise-实现\"><a href=\"#Promise-实现\" class=\"headerlink\" title=\"Promise 实现\"></a>Promise 实现</h2><h3 id=\"status-状态定义\"><a href=\"#status-状态定义\" class=\"headerlink\" title=\"status 状态定义\"></a>status 状态定义</h3><p><strong>Promise</strong>的设定是一个不可逆的状态机，包含：</p>\n<pre><code class=\"javascript\">\n    const PENDDING = \"PENDDING\"; // 初始化pendding状态\n    const RESOLVED = \"RESOLVED\"; // 正确完成resolve状态\n    const REJECTED = \"REJECTED\"; // 错误完成reject状态\n</code></pre>\n<h3 id=\"MyPromise\"><a href=\"#MyPromise\" class=\"headerlink\" title=\"MyPromise\"></a>MyPromise</h3><p>创建<strong>MyPromise</strong>类函数和初始化相对应的值和状态</p>\n<pre><code class=\"javascript\">\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.status = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n          executor(resolve,reject)\n        }catch(e){\n          reject(e)\n        }\n      }\n    }\n</code></pre>\n<h3 id=\"MyPromise-then\"><a href=\"#MyPromise-then\" class=\"headerlink\" title=\"MyPromise.then\"></a>MyPromise.then</h3><h4 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h4><pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 完成状态，推入完成队列\n        if (this.status === RESOLVED) {\n          resolve(this.value);\n        }\n\n        // 拒绝状态，推入拒绝队列\n        if (this.status === REJECTED) {\n          reject(this.reason);\n        }\n\n        // 异步情况\n        if (this.status === PENDDING) {\n          this.resolves.push(resolve);\n          this.rejects.push(reject);\n        }\n      }\n      // ...\n    }\n\n    // 测试同步任务\n\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('promise sync')\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise sync\n\n    // 测试异步任务\n    const promise = new MyPromise((resolve, reject) => {\n        setTimeout(() => {\n            resolve('promise async)\n        }, 500)\n    })\n\n    promise.then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // promise async\n</code></pre>\n<h4 id=\"Promise-A-规范场景\"><a href=\"#Promise-A-规范场景\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><blockquote>\n<p>根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。</p>\n</blockquote>\n<pre><code class=\"javascript\">\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      resolve(\"first\");\n    });\n\n    // 第一种场景：返回常规值\n    promise\n      .then((res) => {\n        console.log(res);\n\n        return \"second\";\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // second\n\n    // 第二种场景：返回promise\n    promise\n      .then((res) => {\n        console.log(res);\n        return new Promise((resolve) => {\n          resolve(\"promise\");\n        });\n      })\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // promise\n\n    // 第三种场景：值穿透\n    promise\n      .then((res) => {\n        console.log(res);\n        return res;\n      })\n      .then()\n      .then((res) => {\n        console.log(res);\n      });\n\n    // 打印结果\n    // first\n    // first\n</code></pre>\n<h4 id=\"实现-then\"><a href=\"#实现-then\" class=\"headerlink\" title=\"实现 then\"></a>实现 then</h4><p>根据以上规范定义，我们来改造一下<strong>then</strong>方法：</p>\n<pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason )\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n        resolve('first')\n    })\n\n    promise.then(res => {\n        console.log(res)\n        return new MyPromise((resolve, reject) => {\n            resolve('promise second')\n        })\n    }).then().then(res => {\n        console.log(res)\n        return 'third'\n    }).then(res => {\n        console.log(res)\n    })\n\n    // 打印结果\n    // first\n    // promise second\n    // third\n</code></pre>\n<h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>测试成功，<strong>promise</strong>的改造就算符合规范了。这个难点在于<strong>then</strong>内函数的返回值如果是<strong>promise</strong>，那么我们会先让他执行注册一次<strong>then</strong>，让<strong>promise</strong>接着往下执行。</p>\n<h3 id=\"MyPromise-catch\"><a href=\"#MyPromise-catch\" class=\"headerlink\" title=\"MyPromise.catch\"></a>MyPromise.catch</h3><p><strong>catch</strong>方法相对比较简单，将拒绝的值放到<strong>reject</strong>方法里执行就可以。</p>\n<h4 id=\"Promise-A-规范场景-1\"><a href=\"#Promise-A-规范场景-1\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre><code class=\"javascript\">\n    // Promise A+\n    const promise = new Promise((resolve, reject) => {\n      reject(\"promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // promise reject\n</code></pre>\n<h4 id=\"实现-catch\"><a href=\"#实现-catch\" class=\"headerlink\" title=\"实现 catch\"></a>实现 catch</h4><pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n      // ...\n    }\n\n    // 测试\n    const promise = new MyPromise((resolve, reject) => {\n      reject(\"my promise reject\");\n    });\n\n    promise.catch((e) => {\n      console.log(e);\n    });\n\n    // 打印结果\n    // my promise reject\n</code></pre>\n<h4 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>catch</strong>方法在于执行回调去获取<strong>reject</strong>的结果，所以只需执行一下<strong>then</strong>并传入<strong>callback</strong>就实现了，相对好理解。</p>\n<h3 id=\"MyPromise-all\"><a href=\"#MyPromise-all\" class=\"headerlink\" title=\"MyPromise.all\"></a>MyPromise.all</h3><p>业务场景中，我们经常会遇到不止一个<strong>promie</strong>的场景，因此需要合并一次执行多个<strong>promise</strong>，统一返回结果，<strong>Promise.all</strong>就是为了解决此问题。</p>\n<h4 id=\"Promise-A-规范场景-2\"><a href=\"#Promise-A-规范场景-2\" class=\"headerlink\" title=\"Promise A+规范场景\"></a>Promise A+规范场景</h4><pre><code class=\"javascript\">\n    // Promise A+\n    // 创建三个promise\n    const promise1 = Promise.resolve(1)\n    const promise2 = Promise.resolve(2)\n    const promise3 = Promise.resolve(3)\n\n    Promise.all([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // [1,2,3]\n\n    // 添加一个reject\n    const promise4 = Promise.resolve(1)\n    const promise5 = Promise.reject('reject')\n    const promise6 = Promise.resolve(3)\n\n    Promise.all([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n    // reject\n</code></pre>\n<blockquote>\n<p>根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。</p>\n</blockquote>\n<h4 id=\"实现-Promise-all\"><a href=\"#实现-Promise-all\" class=\"headerlink\" title=\"实现 Promise.all\"></a>实现 Promise.all</h4><p>我们来实现一下：</p>\n<pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      // all是静态方法\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n      // ...\n    }\n\n    // 测试\n    // 创建三个MyPromise\n    const promise1 = MyPromise.resolve(1)\n    const promise2 = MyPromise.resolve(2)\n    const promise3 = MyPromise.resolve(3)\n\n    MyPromise.all([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // [1,2,3]\n\n    // 添加一个reject\n    const promise4 = MyPromise.resolve(1)\n    const promise5 = MyPromise.reject('reject')\n    const promise6 = MyPromise.resolve(3)\n\n    MyPromise.all([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n    // reject\n</code></pre>\n<h4 id=\"小结-2\"><a href=\"#小结-2\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p><strong>Promise.all</strong>作为一个批量处理的函数，让我们在使用时可以同时多个处理<strong>promise</strong>，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个<strong>promise</strong>后再去执行下一个<strong>promise</strong>，处理完这个逻辑也就基本完成了<strong>Promise.all</strong>的全功能了。</p>\n<h3 id=\"MyPromise-resolve\"><a href=\"#MyPromise-resolve\" class=\"headerlink\" title=\"MyPromise.resolve\"></a>MyPromise.resolve</h3><p>静态方法<strong>resolve</strong>的实现就相对简单了，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<h4 id=\"实现-MyPromise-resolve\"><a href=\"#实现-MyPromise-resolve\" class=\"headerlink\" title=\"实现 MyPromise.resolve\"></a>实现 MyPromise.resolve</h4><pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n      // ...\n    }\n\n    // 测试\n    MyPromise.resolve('static resolve').then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // static resolve\n</code></pre>\n<h3 id=\"MyPromise-reject\"><a href=\"#MyPromise-reject\" class=\"headerlink\" title=\"MyPromise.reject\"></a>MyPromise.reject</h3><p>静态方法<strong>reject</strong>的实现跟<strong>resolve</strong>是类似，返回一个<strong>promise</strong>，传入对应参数即可。</p>\n<pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n      // ...\n    }\n\n    // 测试\n    MyPromise.reject('static reject').catch(e => {\n      console.log(res)\n    })\n\n    // 打印结果\n    // static reject\n</code></pre>\n<h3 id=\"什么是-allSettled？\"><a href=\"#什么是-allSettled？\" class=\"headerlink\" title=\"什么是 allSettled？\"></a>什么是 allSettled？</h3><p>ECMA 官网最新更新了<strong>Promise</strong>的新的静态方法<strong>Promise.allSettled</strong>，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理<strong>Promise</strong>的函数，但是我们已经有了<strong>Promise.all</strong>，为什么还需要<strong>allSettled</strong>。要解开这个问题，我们得回顾一下<strong>Promise.all</strong>。现有的<strong>Promise.all</strong>我们说过，如果<strong>Promise</strong>队列里有一个<strong>reject</strong>，那么他就只会返回<strong>reject</strong>，所以<strong>Promise.all</strong>不一定会返回所有结果，很显然<strong>Promise.allSettled</strong>能够解决这个问题。</p>\n<h4 id=\"Promise-A-测试场景\"><a href=\"#Promise-A-测试场景\" class=\"headerlink\" title=\"Promise A+测试场景\"></a>Promise A+测试场景</h4><pre><code class=\"javascript\">\n    // Promise A+\n    // 创建三个promise\n    const promise1 = Promise.resolve(1)\n    const promise2 = Promise.resolve(2)\n    const promise3 = Promise.resolve(3)\n\n    Promise.allSettled([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n\n    // 添加一个reject\n    const promise4 = Promise.resolve(1)\n    const promise5 = Promise.reject('reject')\n    const promise6 = Promise.resolve(3)\n\n    Promise.allSettled([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n      /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n</code></pre>\n<p>可以看出来<strong>allSettled</strong>和 all 最大的区别就是，<strong>allSettled</strong>不管是<strong>resolve</strong>，还是<strong>reject</strong>都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，<strong>status</strong>描述状态，<strong>value</strong>接收返回值。</p>\n<h4 id=\"实现-MyPromise-allSettled\"><a href=\"#实现-MyPromise-allSettled\" class=\"headerlink\" title=\"实现 MyPromise.allSettled\"></a>实现 MyPromise.allSettled</h4><p><strong>allSettled</strong>的整体逻辑跟<strong>all</strong>是一样的，只不过返回值的处理稍微有所不同</p>\n<pre><code class=\"javascript\">\n    class MyPromise {\n      // ...\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n        }\n    // ...\n    }\n\n    // 测试\n    // 创建三个promise\n    const promise1 = MyPromise.resolve(1)\n    const promise2 = MyPromise.resolve(2)\n    const promise3 = MyPromise.resolve(3)\n\n    MyPromise.allSettled([promise1,promise12,promise3]).then(res => {\n      console.log(res)\n    })\n\n    // 打印结果\n    /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'fulfilished', value: 2},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n\n    // 添加一个reject\n    const promise4 = MyPromise.resolve(1)\n    const promise5 = MyPromise.reject('reject')\n    const promise6 = MyPromise.resolve(3)\n\n    Promise.allSettled([promise4, promise5,promise6]).then(res => {\n      console.log(res, 'resolve')\n    }).catch(e => {\n      console.log(e)\n    })\n\n    // 打印结果\n      /*\n    [\n      {status: 'fulfilished', value: 1},\n      {status: 'rejected', value: 'reject'},\n      {status: 'fulfilished', value: 3}\n    ]\n    */\n</code></pre>\n<h2 id=\"完整代码\"><a href=\"#完整代码\" class=\"headerlink\" title=\"完整代码\"></a>完整代码</h2><pre><code class=\"javascript\">\n    class MyPromise {\n      constructor(executor) {\n        // 初始化状态status\n        // 返回值value\n        // 错误原因reason\n        this.statue = PENDDING;\n        this.value = undefined;\n        this.reason = undefined;\n\n        // 返回值回调队列和错误回调队列\n        this.resolves = [];\n        this.rejects = [];\n\n        // 声明resolve函数\n        const resolve = (value) => {\n          if (this.status === PENDDING) {\n            this.status = RESOLVED; // 变更状态为完成状态\n            this.value = value; // 赋值\n\n            // 执行resolves队列\n            while (this.resolves.length) {\n              const callback = this.resolves.shift();\n              callback(value);\n            }\n          }\n        };\n\n        // 声明reject函数\n        const reject = (reason) => {\n          if (this.statue === PENDDING) {\n            this.status = REJECTED; // 变更状态为拒绝状态\n            this.reason = reason; // 赋值\n\n            // 执行rejects队列\n            while (this.rejects.length) {\n              const callback = this.rejects.shift();\n              callback(reason);\n            }\n          }\n        };\n\n        try{\n        \texecutor(resolve,reject)\n        }catch(e){\n        \treject(e)\n        }\n      }\n\n      // then\n      then(resolve, reject) {\n        // 判断resolve和reject未传入的情况，解决空值透传问题\n        // then()情况\n        typeof resolve !== 'function' ? resolve = value => value : resolve\n        typeof reject !== 'function' ? reject = reason => throw new Error(reason instanceof Error ? reason.message : reason): reject\n\n        //根据规范，then会返回一个全新的promise\n        return new MyPromise((resolveFn, rejectFn) => {\n            // 重写传入的resolve方法\n            // 判断返回值\n            const fulfilished = value => {\n                try{\n                    // 接收返回值\n                    const res = resolve(value)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行resolveFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)\n                }catch(e) {\n                    rejectFn(e)\n                }\n            }\n\n            // 重写传入的reject方法\n            // 判断返回值\n            const rejected = reason => {\n                try{\n            // 接收返回值\n                    const res = reject(reason)\n\n                    // 判断返回值类型：promise或普通类型\n                    // 如果是promise，则往下执行一次then\n                    // 如果是普通类型，则直接执行rejectFn，保证value是最新值\n                    res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)\n                }catch(e){\n                    rejectFn(e instanceof Error ? e.message: e)\n                }\n\n            }\n\n            // 判断同步异步任务\n            // 执行相对应的方法\n            // 这里用switch方法改进\n            switch(this.status) {\n                case RESOLVED:\n                    fulfilished(this.value)\n                break;\n\n                case REJECTED:\n                    rejected(this.reason)\n                break;\n\n                case PENDDING:\n                    this.resolves.push(fulfilished)\n                    this.rejects.push(rejected)\n                  break;\n            }\n        })\n\n      }\n\n      catch(errorFn) {\n        // 这里只需注册执行下then，传入callback就能实现\n        this.then(null, errorFn);\n      }\n\n      // resolve\n      static resolve(value) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          resolveFn(value)\n        })\n      }\n\n        // reject\n      static reject(reason) {\n        return new MyPromise((resolveFn, rejectFn) => {\n          rejectFn(reason)\n        })\n      }\n\n      // all\n      static all(promises) {\n        // 已然是返回一个promise\n        return new MyPromise((resolve, reject) => {\n          // 创建一个收集返回值的数组\n          const result = []\n\n          // 执行\n          deepPromise(promises[0], 0 , result)\n\n          // 返回结果\n          resolve(result)\n\n          // 这里我们用递归来实现\n          // @param {MyPromise} promise 每一个promise方法\n          // @param {number} index 索引\n          // @param {string[]} result 收集返回结果的数组\n          function deepPromise(promise, index, result) {\n            // 边界判断\n            // 所有执行完之后返回收集数组\n            if(index > promises.length - 1) {\n              return result\n            }\n\n            if(typeof promise.then === 'function') {\n              // 如果是promise\n              promise.then(res => {\n                index++\n                result.push(res)\n                deepPromise(promises[index], index, result)\n              }).catch(e => {\n                // reject直接返回\n                reject(e instanceof Error ? e.message : e)\n              })\n            }else {\n              // 如果是普通值\n              // 这里我们只做简单判断，非promise则直接当返回值处理\n              index++\n              result.push(promise)\n              deepPromise(promises[index], index, res)\n            }\n          }\n        })\n\n      }\n\n      // allSettled\n      static allSettled(promises) {\n          // 已然是返回一个promise\n          return new MyPromise((resolve, reject) => {\n            // 创建一个收集返回值的数组\n            const result = []\n\n            // 执行\n            deepPromise(promises[0], 0 , result)\n\n            // 返回结果\n            resolve(result)\n\n            // 这里我们用递归来实现\n            // @param {MyPromise} promise 每一个promise方法\n            // @param {number} index 索引\n            // @param {string[]} result 收集返回结果的数组\n            function deepPromise(promise, index, result) {\n              // 边界判断\n              // 所有执行完之后返回收集数组\n              if(index > promises.length - 1) {\n                return result\n              }\n\n              if(typeof promise.then === 'function') {\n                // 如果是promise\n                promise.then(res => {\n                  index++\n                  result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                }).catch(e => {\n                  // reject直接返回\n                  index ++\n                  result.push({status: 'rejected', value: res}) // 这里推入的是对象\n                  deepPromise(promises[index], index, result)\n                })\n              }else {\n                // 如果是普通值\n                // 这里我们只做简单判断，非promise则直接当返回值处理\n                index++\n                result.push({status: 'fulfilished', value: res}) // 这里推入的是对象\n                deepPromise(promises[index], index, res)\n              }\n            }\n          })\n\n        }\n    }\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此<strong>Promise A+**的完整的方法和实现就完成了，个人觉得实现</strong>promise<strong>的难点在于理解</strong>then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然</p>\n<h2 id=\"关于转载\"><a href=\"#关于转载\" class=\"headerlink\" title=\"关于转载\"></a>关于转载</h2><p>转载自<a href=\"https://juejin.cn/post/6866372840451473415#heading-0\">掘金</a> 作者<a href=\"https://juejin.cn/user/448256474885159\">MichaelHong</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckn5cb0ci0009ksup6us9e2rl","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0cm000iksup7zpo0wba"},{"post_id":"ckn5cb0c80001ksuph2ejb99f","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0co000nksup12yb64oo"},{"post_id":"ckn5cb0cj000bksupf5279fe6","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0cp000qksupd8r91n7f"},{"post_id":"ckn5cb0cd0003ksup23nq8bcs","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0cr000vksupf3bw5eto"},{"post_id":"ckn5cb0ch0007ksup6mvha8d4","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0cs000xksup7n35a2s2"},{"post_id":"ckn5cb0cq000uksup3r9z2cj8","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0cu0012ksupb9a056pf"},{"post_id":"ckn5cb0cl000fksupfllo7sa2","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0cw0016ksupb6my96mr"},{"post_id":"ckn5cb0cr000wksup67me2q2w","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0cx0018ksup9p1mc4jm"},{"post_id":"ckn5cb0cs0010ksupe0x884tx","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0cz001dksup4dyk9zi5"},{"post_id":"ckn5cb0cm000hksuphjr56fk0","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0d0001gksup5da60dhu"},{"post_id":"ckn5cb0cv0015ksup93qu3cpy","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0d1001lksup8ofq1voi"},{"post_id":"ckn5cb0cn000mksup9hyjch4y","category_id":"ckn5cb0cu0013ksup31ao0hmc","_id":"ckn5cb0d2001nksup6g3s5ndw"},{"post_id":"ckn5cb0cw0017ksup3jihdert","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0d2001qksup28sjdu1n"},{"post_id":"ckn5cb0cy001cksup21lw6l3v","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0d2001sksupfo9q62d1"},{"post_id":"ckn5cb0cp000pksup17j1alsf","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0d3001vksup8ozg0441"},{"post_id":"ckn5cb0cz001fksupcn8t4xm1","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0d3001xksupdyxr5szc"},{"post_id":"ckn5cb0d1001kksuphc7s30sz","category_id":"ckn5cb0cf0004ksup6iqvex7z","_id":"ckn5cb0d3001zksupdp1u8b40"},{"post_id":"ckn5cb0ct0011ksupdxx1bpxn","category_id":"ckn5cb0d0001hksuphsep1dnv","_id":"ckn5cb0d40022ksup6evpa2o9"},{"post_id":"ckn5cb0dr002qksup54z4dcbo","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0dv002wksupgrtt61um"},{"post_id":"ckn5cb0dt002tksupc5su1nj6","category_id":"ckn5cb0cp000rksup15ae138r","_id":"ckn5cb0dv002zksup44anewlh"},{"post_id":"ckn5cb0do002pksuphnsjco56","category_id":"ckn5cb0ds002rksupf9npfb21","_id":"ckn5cb0dv0031ksupe6l409gg"}],"PostTag":[{"post_id":"ckn5cb0ci0009ksup6us9e2rl","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0cl000eksup2err4yq0"},{"post_id":"ckn5cb0c80001ksuph2ejb99f","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0cm000gksupc8e599zn"},{"post_id":"ckn5cb0cj000bksupf5279fe6","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0cn000lksupfobt5c4f"},{"post_id":"ckn5cb0cd0003ksup23nq8bcs","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0cp000oksup2g2lagg0"},{"post_id":"ckn5cb0ch0007ksup6mvha8d4","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0cq000tksupaxdz234c"},{"post_id":"ckn5cb0cv0015ksup93qu3cpy","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0cy001aksupfeycb8u7"},{"post_id":"ckn5cb0cv0015ksup93qu3cpy","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0cz001eksupf3pr5ke7"},{"post_id":"ckn5cb0cl000fksupfllo7sa2","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d0001iksup3ejf508i"},{"post_id":"ckn5cb0cl000fksupfllo7sa2","tag_id":"ckn5cb0cs000zksup16n67ttb","_id":"ckn5cb0d1001mksupa3qh1j54"},{"post_id":"ckn5cb0cl000fksupfllo7sa2","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d2001oksupfi9xdn1k"},{"post_id":"ckn5cb0cw0017ksup3jihdert","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0d2001rksup6zq4d3mi"},{"post_id":"ckn5cb0cy001cksup21lw6l3v","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d3001tksupbg2xbz17"},{"post_id":"ckn5cb0cy001cksup21lw6l3v","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d3001wksupa36vgle4"},{"post_id":"ckn5cb0d1001kksuphc7s30sz","tag_id":"ckn5cb0cg0005ksupeboccinm","_id":"ckn5cb0d3001yksup5idchjtj"},{"post_id":"ckn5cb0cm000hksuphjr56fk0","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d40021ksuph54768vh"},{"post_id":"ckn5cb0cm000hksuphjr56fk0","tag_id":"ckn5cb0cs000zksup16n67ttb","_id":"ckn5cb0d40023ksup31l2av1u"},{"post_id":"ckn5cb0cm000hksuphjr56fk0","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d50025ksup6u0eh38r"},{"post_id":"ckn5cb0cn000mksup9hyjch4y","tag_id":"ckn5cb0d3001uksup8elpe7ot","_id":"ckn5cb0d50026ksupa5rtedz8"},{"post_id":"ckn5cb0cp000pksup17j1alsf","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d50028ksuper0ldffp"},{"post_id":"ckn5cb0cp000pksup17j1alsf","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d50029ksup1sfo1yiq"},{"post_id":"ckn5cb0cq000uksup3r9z2cj8","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d6002bksup4imxe9fc"},{"post_id":"ckn5cb0cq000uksup3r9z2cj8","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d6002cksup8qf1chbk"},{"post_id":"ckn5cb0cr000wksup67me2q2w","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d6002eksupbs4p0k5s"},{"post_id":"ckn5cb0cr000wksup67me2q2w","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d7002fksupbtlv4ru2"},{"post_id":"ckn5cb0cs0010ksupe0x884tx","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d7002hksupayu468nn"},{"post_id":"ckn5cb0cs0010ksupe0x884tx","tag_id":"ckn5cb0cv0014ksup265vhfpj","_id":"ckn5cb0d7002iksupgy9400yr"},{"post_id":"ckn5cb0ct0011ksupdxx1bpxn","tag_id":"ckn5cb0d7002gksup5ebbc2kr","_id":"ckn5cb0d8002lksupdvaq33vv"},{"post_id":"ckn5cb0ct0011ksupdxx1bpxn","tag_id":"ckn5cb0d7002jksup1wkz1ya3","_id":"ckn5cb0d8002mksup6oiz74gb"},{"post_id":"ckn5cb0cz001fksupcn8t4xm1","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0d8002nksup5so7558j"},{"post_id":"ckn5cb0cz001fksupcn8t4xm1","tag_id":"ckn5cb0d8002kksup8wcfhte0","_id":"ckn5cb0d8002oksupbkjabpsl"},{"post_id":"ckn5cb0dr002qksup54z4dcbo","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0du002uksup8bgrdjfd"},{"post_id":"ckn5cb0dr002qksup54z4dcbo","tag_id":"ckn5cb0d8002kksup8wcfhte0","_id":"ckn5cb0dv002vksupbk79bhlh"},{"post_id":"ckn5cb0dt002tksupc5su1nj6","tag_id":"ckn5cb0cp000sksupf3mrbdnw","_id":"ckn5cb0dv002yksupc5smbxub"},{"post_id":"ckn5cb0dt002tksupc5su1nj6","tag_id":"ckn5cb0d8002kksup8wcfhte0","_id":"ckn5cb0dv0030ksupa6l11ldx"},{"post_id":"ckn5cb0do002pksuphnsjco56","tag_id":"ckn5cb0dt002sksup0m49ffc9","_id":"ckn5cb0dw0032ksup9gpq9jio"},{"post_id":"ckn5cb0do002pksuphnsjco56","tag_id":"ckn5cb0dv002xksupew8k5mee","_id":"ckn5cb0dw0033ksupbbld8wyj"}],"Tag":[{"name":"随笔","_id":"ckn5cb0cg0005ksupeboccinm"},{"name":"JavaScript","_id":"ckn5cb0cp000sksupf3mrbdnw"},{"name":"LeetCode","_id":"ckn5cb0cs000zksup16n67ttb"},{"name":"学习总结","_id":"ckn5cb0cv0014ksup265vhfpj"},{"name":"Git","_id":"ckn5cb0d3001uksup8elpe7ot"},{"name":"Typora","_id":"ckn5cb0d7002gksup5ebbc2kr"},{"name":"Markdown","_id":"ckn5cb0d7002jksup1wkz1ya3"},{"name":"转载","_id":"ckn5cb0d8002kksup8wcfhte0"},{"name":"个人简介","_id":"ckn5cb0dt002sksup0m49ffc9"},{"name":"博客简介","_id":"ckn5cb0dv002xksupew8k5mee"}]}}