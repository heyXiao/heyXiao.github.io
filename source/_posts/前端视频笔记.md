---
title: 前端视频笔记(21.07.06)
date: 2021-07-07 21:53:27
author: heyXiao
summary: 为了加深视频理解做的总结
# password: 35482c55c9fcbe4ff1b6023476c7acd59c011b9e8870376a45b3416ba8092d3d
categories: 技术
tags:
  - JavaScript
  - 学习总结
---

# 前端视频笔记 #

## 前端知识培训-营销2.0 ##

### HTML标签 ###

`<meta>` 标签：提供了元数据.元数据也不显示在页面上，但会被浏览器解析.

为搜索引擎定义关键词：

``` html
    <meta name="keywords" content="HTML,CSS,XML,XHTML,JavaScript">
```

为网页定义描述内容：

``` html
    <meta name="description" content="前端开发">
```

``` html
    <meta name="author" content="heyXiao">
```

每30秒钟刷新当前页面：

``` html
    <meta http-equi="refresh" content="30">
```

### HTML5 新特性 ###

* Canvas 画图  
* 新增视频 `<video>` 和音频 `<audio>` 标签  
* SVG 绘图标签  
* HTML5提供语义化标签，比如 `<article>`、`<footer>`、`<header>`、`<nav>`、`<section>` 等.
    > 语义化的好处：  
    > 1.HTML结构清晰  
    > 2.代码可读性较好  
    > 3.无障碍阅读  
    > 4.搜索引擎可以根据标签的语言确定上下文和权重问题  
    > 5.移动设备能够更完美的展现网页（对css支持较弱的设备）  
    > 6.便于团队维护和开发  

* 新增表单属性，比如 placeholder 属性,required 属性,min 和 max 属性等

### HTML5---响应式（自适应网页设计） ###  

在网页代码的头部，加入一行 viewport 元标签

``` html

    <meta name="viewport" content="width=device-widthminitial-scale=1.0,maximum-scale=1.0,user-scalable=no">

```

在网页的 `<head>` 中增加以上代码，可以让网页的宽度自动适应手机屏幕的宽度，下面是这些属性的解释：  
> width=device-width: 表示宽度是设备屏幕的宽度  
> initial-scale=1.0: 表示初始的缩放比例,1.0 就是占网页的 100%  
> minimum-scale=1.0: 表示最小的缩放比例  
> maximum-scale=1.0: 表示最大的缩放比例
> user-scalable=no: 表示用户是否可以调整缩放比例

如果要兼容 IE6/7/8 的话,就要用 css3-mediaqueries.js

### 前端开发基础语言---CSS ###

* CSS选择器  
  **子元素选择器** 只能选择作为某元素子元素的元素。  
  div > p {} 选择了 `<div>` 元素中所有直接子元素 `<p>`  
  **相邻兄弟选择器** 可选择紧接在另一元素后的元素，且二者有相同父元素。  
  div + p {} 选择了所有位于 `<div>` 元素后的第一个 `<p>` 元素  
  **后续兄弟选择器** 后续兄弟选择器选取所有指定元素之后的相邻兄弟元素。  
  div ~ p {} 选取了所有 `<div>` 元素之后的所有相邻兄弟元素 `<p>`  
  **伪类**
    > :last-child p:last-child 选择所有 p 元素的最后一个子元素  
    > :first-child p:first-child 选择器匹配属于任意元素的第一个子元素的 p 元素  
    > a:link 未访问的链接  
    > a:visited 已访问的链接  
    > a:hover 鼠标划过链接  
    > a:active 已选中的链接  
    **注意:** 在 CSS 定义中, a:hover 必须被置于 a:link 和 a:visited 之后,才是有效的; a:active 必须被置于 a:hover 之后,才是有效的。  
* Flex 布局  
    **flex-direction 属性：** 决定主轴的方向（即排列方向）。  
    > row（默认值）：主轴为水平方向，起点在左端。  
    > row-reverse: 主轴为水平方向，起点在右端。  
    > column: 主轴为垂直方向，起点在上沿。  
    > column-reverse: 主轴为垂直方向，起点在下沿。  

    **flex-wrap 属性：**  定义，如果一条轴线排不下，如何换行。
    > nowrap（默认）: 不换行。  
    > wrap: 换行，第一行在上方。  
    > wrap-reverse: 换行，第一行在下方。  

    **align-items 属性：** 定义项目在交叉轴上如何对齐。
    > flex-start: 交叉轴的起点对齐。  
    > flex-end: 交叉轴的终点对齐。  
    > center: 交叉轴的中点对齐。  
    > baseline: 项目的第一行文字的基线对齐。  
    > stretch（默认值）: 如果项目未设置高度或设为 auto，将占满整个容器的高度。  

    **justify-content 属性：** 定义项目在主轴上的对齐方式。
    > flex-start（默认值）: 左对齐。  
    > flex-end: 右对齐。  
    > center: 居中。  
    > space-between: 两端对齐，每组标签之间的间隔相等。  
    > space-around: 每组标签两侧的间隔相等。所以，标签组之间的间隔比标签组与边框的间隔大一倍。  
* BFC 规范  
  块级格式化上下文: Block Formatting Contexts,BFC 规定了内部的 Block Box 如何布局。具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  
    **BFC 布局规则：**  
  
    > 内部的 Box 会在垂直方向，一个接一个地放置。  
    > Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（按照最大 margin 值设置）。  
    > 每个元素的 margin box 的左边，与包含块 border box 的左边相接触。  
    > BFC 的区域不会与 float box 重叠。  
    > BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。  
    > 计算 BFC 的高度时，浮动元素也会参与计算。
  
    **满足下列条件之一就可触发BFC：**  
    > 根元素，即 html  
    > float 的值不为 none（默认）  
    > overflow 的值不为 visible（默认）  
    > display 的值为 table-cell、tabble-caption、inline-block  
    > position 的值为 absolute 或 fixed  

### 前端开发基础语言---JavaScript ###

* 继承的方式  
  > 原型链继承  
  > 构造函数继承（对象冒充继承）  
  > 组合继承 （原型链继承 + 构造函数继承）  
  > 原型式继承  
  > 寄生组合式继承  
  [https://www.cnblogs.com/hongsusu/p/9057580.html]  
* 继承的实现  
  > 第一种使用 prototype  

  ``` JavaScript
    var obj = {name:'seven'};
    var a = function(){};
    a.prototype = obj;
    var aa = new a();
    alert(aa.name);//seven
  ```

  > 第二种使用 apply 或者 call  

  ``` JavaScript
    function people(name,age){
        //属性
        this.name = name;
        this.age = age;
    }
    function student(name,age,school){
        people.apply(this,arguments);
        this.school = school;
        this.showYourself = function(){
            console.log("my name is "+this.name+" and I am "+this.age+" years old "+" my school is "+this.school);
        };
    }
    var tom = new student('tom','19','aftvc');
    tom.showYourself();
  ```

* 闭包  
  **变量作用域：**  
  要理解闭包，首先要理解 JavaScript 的特殊的变量作用域。  
  变量的作用域：全局变量和局部变量。  
  函数内部可以直接读取全局变量，但那是在函数外部无法读取函数内部的局部变量。  

  **注意点：**
  在函数内部声明变量的时候，一定要使用 var 命令，否则实际上声明的是一个全局变量。  

  **定义：**  
  > 闭包是指有权访问另外一个函数作用域中的变量的函数。可以理解为 "能够读取其他函数内部变量的函数"  
  > 在本质上，闭包是将函数内部和函数外部连接起来的桥梁。  

  **优点：**
  > 变量长期驻扎在内存中
  > 避免变量的全局污染
  > 私有成员

  **作用：**
  > 可以读取函数内部的变量
  > 让这些变量的值始终保持在内存中，不会在 f1 调用后被自动清除
  
  ``` JavaScript
    function f1(){
        var n = 999;
        function f2(){
            alert(n); // 999
  ```

  > f2 函数就是闭包。  
  f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1,因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制回收。

  **缺陷：**
  > 闭包会导致内存占用过高，因为变量都没有释放内存。所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。所以在退出函数之前，将不使用的局部变量全部删除。（var 声明的全局变量无法 delete）。  
  > 闭包能够在父函数外面，改变父函数内部变量的值。所以，如果把父级函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时候要注意不要随便改动父函数内部变量的值.  

* call 函数和 apply 函数  
**相同点：**
都是改变 this 的指向。事实上 apply 和 call 的用法几乎相同。  
唯一的差别在于：当函数需要传递多个变量时，apply 可以接受一个数组作为参数输入，call 则是接受一系列的单独变量。  
**不同点：**
接受参数的方式不同。
    > apply() 方法接受两个参数，第一个参数是要绑定给 this 的值，第二个参数是一个参数数组。当第一个参数为 null、undefined 的时候，默认指向 window。
    > call() 方法一个参数是要绑定给 this 的值，后面传入的是一个参数列表。当第一个参数为 null、undefined 的时候，默认指向 window。  
    .call(window,3,4); .apply(window,[3,4]);  

* 事件轮询 event Loop
    1. JS会首先判断代码是同步还是异步，同步进入主线程，异步进入任务队列；
    2. 同步任务进入主线程后一直执行，直到主线程空闲后，才会去任务队列中查看是否有可执行的异步任务，如果有就推入主线程中执行；
    3. 事件循环是一个先进先出（FIFO）队列，这说明回调是按照它们被加入队列的顺序执行的。  

    宏任务(macrotask)和微任务(microtask)  
    宏任务: 代码块，setTimeout，setInterval 等，宏任务是放到事件触发队列里面的。  
    微任务: Promise，proces.nextTick 等，是放到微任务队列里面的，由 js 线程掌管。  

    ``` JavaScript
        setTimeout(function(){
            console.log('setTimeout()执行了')
        },0)
        setInterval(function(){
            console.log('setInterval()执行了')
        })
        process.nextTick(function(){
            console.log('process.nextTick()执行了')
        })
        // 执行顺序
        // process.nextTick();
        // setTimeout();
        // setInterval();
    ```  

* var let const 的区别  

    **var：**
    > var 定义的变量在之后可以修改，如果不初始化会输出undefined，不会报错。  
    > var 定义的变量，可以跨块访问，不能跨函数访问。  
    > var 的作用域是函数作用域，var 可以用来声明全局变量，也可以声明局部变量。在一个函数内利用 var 声明一个变量，则这个变量只在这个函数内有效。  

    **let：**  
    > let 是块级作用域，函数内部使用 let 定义后，对函数外部无影响。
    > 不存在变量声明提前，否则会报错。
    > let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。
    > 不能重复定义，否则会报错。

    ``` JavaScript
        var c = 11;
        {
            let c = 12;
            console.log(c);// 12
        }
        console.log(c);// 11
    ```

    **const:**
    > const 定义的变量不可以修改，而且必须初始化。  
    > const 一般用来声明常量，且声明的常量是不允许改变的，为只读属性，因此就要在声明的同时赋值。  
    > const 与 let 一样，都是块级作用域，只能在块作用域里访问，存在暂时性死区，不存在变量声明提前，不允许重复定义。  
    > ES6新增的let、const关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建之前被创建出来，由于此时还未完成语法绑定，如果我们访问或使用该变量，就会产生暂时性死区的问题，由此我们可以得知，从变量的创建到语法绑定之间这一段空间，我们就可以理解为‘暂时性死区’  

<p style="text-indent:2em">大概本周末会写一篇最近的说明</p>
