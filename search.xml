<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>无博客无心情</title>
      <link href="2021/01/28/%E6%97%A0%E5%8D%9A%E5%AE%A2%E6%97%A0%E5%BF%83%E6%83%85/"/>
      <url>2021/01/28/%E6%97%A0%E5%8D%9A%E5%AE%A2%E6%97%A0%E5%BF%83%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>三无博客可以查到了，虽然要打全拼。小小的鼓励。</p><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p>最近比较忙，可以划水做题，但是总结就费劲了，希望可以缓一缓。</p><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>Courtship but friendship at least.</p><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><p>在考虑要不要换个马甲行走江湖23333，暂定平安柯基(PeaceCorgi)。</p><h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p>如果明日(21.02.03)仍无事，开始写LeetCode总结。拖延症中期患者。</p><h3 id="六"><a href="#六" class="headerlink" title="六"></a>六</h3><p>不用拖延了，因为本周又有事情做。</p><h3 id="七"><a href="#七" class="headerlink" title="七"></a>七</h3><p>惊闻小伙伴已放假，使我大口恰柠檬。 21.02.06</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 70 Climb Stairs</title>
      <link href="2021/01/08/LeetCode%2070%20Climb%20Stairs/"/>
      <url>2021/01/08/LeetCode%2070%20Climb%20Stairs/</url>
      
        <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="LeetCode-70"><a href="#LeetCode-70" class="headerlink" title="LeetCode 70"></a><a href="https://leetcode.com/problems/climbing-stairs/">LeetCode 70</a></h3><pre><code>var climbStairs = function(n) &#123;    if (n &gt;= 1 &amp;&amp; n &lt;= 3) &#123;        return n    &#125;    // 第一种 递归    let arr = [0, 1, 2, 3]    for (let i = 4; i &lt;= n; i++) &#123;        arr.push(arr[i - 1] + arr[i - 2])    &#125;    return arr[n]    // 第二种 斐波那契优化    var a = 1,        b = 1;    while (--n &gt; 0) &#123;        b = b + a;        a = b - a;    &#125;    return b;    // 第三种 不知道为什么...    var sqrt5 = Math.sqrt(5);    var fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);    return (fibn / sqrt5);&#125;climbStairs(10)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 学习总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 64 Minimum Path Sum</title>
      <link href="2021/01/08/LeetCode%2064%20Minimum%20Path%20Sum/"/>
      <url>2021/01/08/LeetCode%2064%20Minimum%20Path%20Sum/</url>
      
        <content type="html"><![CDATA[<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="LeetCode-64"><a href="#LeetCode-64" class="headerlink" title="LeetCode 64"></a><a href="https://leetcode.com/problems/minimum-path-sum/">LeetCode 64</a></h3><pre><code>var minPathSum = function(grid) &#123;    // 如果阵列长度为0    if (!grid.length) &#123;        return 0    &#125;    // grid 为    // [1, 3, 1],    // [1, 5, 6],    // [4, 2, 1],    // 初始化一个二维数组,存储路径和    let dp = [[]];    // dp[0] 赋值 grid[0] 路径和 (第一行)    // grid[0] == [1, 3, 1];    // dp[0][0] = 1, dp[0][1] = 1 + 3, dp[0][2] = 1 + 3 + 1;    // dp[0] == [1, 4, 5];    let sum = 0;    for (let i = 0; i &lt; grid[0].length; i++) &#123;        sum += grid[0][i]        dp[0].push(sum)    &#125;    // dp[i][0] 赋值 grid[i][0] 路径和 (第一列)    // 赋值过后 dp 为     // [1, 4, 5],    // [2, A, B],    // [6, C, D]    // 偏右下的位置为当前终点的最小路径和 比如说 A 点两个值 1 + 4 与 1 + 2, 取最小值3    let sum2 = dp[0][0];    for (let i = 1; i &lt; grid.length; i++) &#123;        sum2 += grid[i][0];        dp[i] = [];        dp[i].push(sum2);    &#125;    // dp                //grid    // [1, 4, 5],        // [1, 3, 1],    // [2, A, B],        // [1, 5, 6],    // [6, C, D]        // [4, 2, 1]    // 计算 A, B, C, D 四个点的路径和    for (let i = 1; i &lt; grid.length; i++) &#123;        for (let j = 1; j &lt; grid[0].length; j++) &#123;            // 比较右和下两个方向路径和的值,取最小            // 例 i == 1, j == 1, dp[0][1] == 4, dp[1][0] == 2,             // 则 dp[1][1] = dp[1][0] + grid[1][1] == 2 + 5 == 7            dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]        &#125;    &#125;    // 最终结果    // [1, 4, 5],    // [2, 7, 11],    // [6, 8, 9]    // 取右下角值 结果为 9    return dp[dp.length - 1][dp[0].length - 1]&#125;minPathSum([    [1, 3, 1],    [1, 5, 6],    [4, 2, 1],])</code></pre><h3 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h3><p>一开始只是写LeetCode，后来有了总结学习的想法，慢慢做吧，题目不按顺序，不刻意最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 学习总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Promise V8 源码分析(二)</title>
      <link href="2020/12/14/Promise%20V8%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)/"/>
      <url>2020/12/14/Promise%20V8%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>基于 node 版本 14.13.0，V8 版本 8.4.371。本文介绍的内容是 reject、catch 和 then 的链式调用。</p><h2 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h2><pre><code>new Promise((resolve, reject) =&gt; &#123;  setTimeout(_ =&gt; reject(&#39;rejected&#39;), 5000)&#125;).then(_ =&gt; &#123;  console.log(&#39;fulfilled&#39;)&#125;, reason =&gt; &#123;  console.log(reason)&#125;)</code></pre><p>上述代码 5s 后执行 reject 函数，控制台打印 rejected。reject 函数调用了 V8 的 <a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#210">RejectPromise</a> 函数，源码如下：</p><pre><code>transitioning builtinRejectPromise(implicit context: Context)(    promise: JSPromise, reason: JSAny, debugEvent: Boolean): JSAny &#123;  // 取出 Promise 的处理对象 PromiseReaction  const reactions =      UnsafeCast&lt;(Zero | PromiseReaction)&gt;(promise.reactions_or_result);  // 这里的 reason 就是 reject 函数的参数  promise.reactions_or_result = reason;  // 设置 Promise 的状态为 rejected  promise.SetStatus(PromiseState::kRejected);  TriggerPromiseReactions(reactions, reason, kPromiseReactionReject);  return Undefined;&#125;</code></pre><p><a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#140">TriggerPromiseReactions</a> 函数在上一篇文章分析过，功能是将 Promise 处理函数相关的 PromiseReaction 链表，反转后依次插入 V8 的 microtask 队列，TriggerPromiseReactions 源码继续删减如下：</p><pre><code>// https://tc39.es/ecma262/#sec-triggerpromisereactionstransitioning macro TriggerPromiseReactions(implicit context: Context)(    reactions: Zero|PromiseReaction, argument: JSAny,    reactionType: constexpr PromiseReactionType): void &#123;  // 删减了链表反转的代码  let current = reactions;  // reactions 是一个链表，下面的 while 循环遍历链表  while (true) &#123;    typeswitch (current) &#123;      case (Zero): &#123;        break;      &#125;      case (currentReaction: PromiseReaction): &#123;        // 取出链表下一个结点        current = currentReaction.next;        // 调用 MorphAndEnqueuePromiseReaction，将当前节点插入 microtask 队列        MorphAndEnqueuePromiseReaction(currentReaction, argument, reactionType);      &#125;    &#125;  &#125;&#125;</code></pre><p><a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-abstract-operations.tq#84">MorphAndEnqueuePromiseReaction</a> 将 PromiseReaction 转为 microtask，最终插入 microtask 队列，morph 本身有转变/转化的意思，比如 Polymorphism (多态)。</p><p>MorphAndEnqueuePromiseReaction 接收 3 个参数，PromiseReaction 是前面提到的包装了 Promise 处理函数的链表对象，argument 是 resolve/reject 的参数，reactionType 表示 Promise 最终的状态，fulfilled 状态对应的值是 kPromiseReactionFulfill，rejected 状态对应的值是 kPromiseReactionReject。MorphAndEnqueuePromiseReaction 的逻辑很简单，因为此时已经知道了 Promise 的最终状态，所以可以从 promiseReaction 对象得到 promiseReactionJobTask 对象，promiseReactionJobTask 的变量命名与 ECMA 规范相关描述一脉相承，其实就是传说中的 microtask。MorphAndEnqueuePromiseReaction 源码如下，仅保留了和本小节相关的内容。</p><pre><code>transitioning macro MorphAndEnqueuePromiseReaction(implicit context: Context)(    promiseReaction: PromiseReaction, argument: JSAny,    reactionType: constexpr PromiseReactionType): void &#123;  let primaryHandler: Callable|Undefined;  let secondaryHandler: Callable|Undefined;  if constexpr (reactionType == kPromiseReactionFulfill) &#123;    primaryHandler = promiseReaction.fulfill_handler;    secondaryHandler = promiseReaction.reject_handler;  &#125; else &#123;    primaryHandler = promiseReaction.reject_handler;    secondaryHandler = promiseReaction.fulfill_handler;  &#125;  const handlerContext: Context =      ExtractHandlerContext(primaryHandler, secondaryHandler);  if constexpr (reactionType == kPromiseReactionFulfill) &#123;    // 删  &#125; else &#123;    * UnsafeConstCast(&amp; promiseReaction.map) =        PromiseRejectReactionJobTaskMapConstant();    const promiseReactionJobTask =        UnsafeCast&lt;PromiseRejectReactionJobTask&gt;(promiseReaction);    // argument 是 reject 的参数    promiseReactionJobTask.argument = argument;    promiseReactionJobTask.context = handlerContext;    // handler 是 JS 层面 then 方法的第二个参数，或 catch 方法的参数    promiseReactionJobTask.handler = primaryHandler;    // promiseReactionJobTask 就是那个工作中经常被反复提起的 microtask    // EnqueueMicrotask 将 microtask 插入 microtask 队列    EnqueueMicrotask(handlerContext, promiseReactionJobTask);  &#125;&#125;</code></pre><p>reject 和 resolve 的逻辑基本相同，分为 3 步：</p><ul><li>设置 Promise 的 value/reason，也就是 resolve/reject 的参数</li><li>设置 Promise 的状态：fulfilled/rejected</li><li>从之前调用 then/catch 方法时收集到的依赖，也就是 promiseReaction 对象，得到一个个 microtask，最后将 microtask 插入 microtask 队列</li></ul><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><pre><code>new Promise((resolve, reject) =&gt; &#123;    setTimeout(reject, 2000)&#125;).catch(_ =&gt; &#123;    console.log(&#39;rejected&#39;)&#125;)</code></pre><p>以上面代码为例，当 catch 方法执行时，调用了 V8 的 <a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-constructor.tq#100">PromisePrototypeCatch</a> 方法，源码如下：</p><pre><code>transitioning javascript builtinPromisePrototypeCatch(    js-implicit context: Context, receiver: JSAny)(onRejected: JSAny): JSAny &#123;  const nativeContext = LoadNativeContext(context);  return UnsafeCast&lt;JSAny&gt;(      InvokeThen(nativeContext, receiver, Undefined, onRejected));&#125;</code></pre><p>PromisePrototypeCatch 的源码确实只有就这几行，除了调用 InvokeThen 方法再无其它 。从名字可以推测出，InvokeThen 调用的是 Promise 的 then 方法，<a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-misc.tq#199">InvokeThen</a> 源码如下：</p><pre><code>transitioningmacro InvokeThen&lt;F: type&gt;(implicit context: Context)(    nativeContext: NativeContext, receiver: JSAny, arg1: JSAny, arg2: JSAny,    callFunctor: F): JSAny &#123;  if (!Is&lt;Smi&gt;(receiver) &amp;&amp;      IsPromiseThenLookupChainIntact(          nativeContext, UnsafeCast&lt;HeapObject&gt;(receiver).map)) &#123;    const then =        UnsafeCast&lt;JSAny&gt;(nativeContext[NativeContextSlot::PROMISE_THEN_INDEX]);    // 重点在下面一行，调用 then 方法并返回，两个分支都一样    return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);  &#125; else    deferred &#123;      const then = UnsafeCast&lt;JSAny&gt;(GetProperty(receiver, kThenString));      // 重点在下面一行，调用 then 方法并返回，两个分支都一样      return callFunctor.Call(nativeContext, then, receiver, arg1, arg2);    &#125;&#125;</code></pre><p>InvokeThen 方法有 if/else 两个分支，两个分支的逻辑差不多，本小节的 JS 示例代码走的是 if 分支。先是拿到 V8 原生的 then 方法，然后通过 callFunctor.Call(nativeContext, then, receiver, arg1, arg2) 调用 then 方法。then 方法上一篇文章有提及，这里不再赘述。</p><p>既然 catch 方法底层调用了 then 方法，那么 catch 方法也有和 then 方法一样的返回值，catch 方法可以继续抛出异常，可以继续链式调用。</p><pre><code>new Promise((resolve, reject) =&gt; &#123;    setTimeout(reject, 2000)&#125;).catch(_ =&gt; &#123;    throw &#39;rejected&#39;&#125;).catch(_ =&gt; &#123;    console.log(&#39;last catch&#39;)&#125;)</code></pre><p>上面的代码第 2 个 catch 捕获第 1 个 catch 抛出的异常，最后打印 last catch。</p><blockquote><p>catch 方法通过底层调用 then 方法来实现<br>假如 obj 是一个 Promise 对象，JS 层面 obj.catch(onRejected) 等价于 obj.then(undefined, onRejected)</p></blockquote><h2 id="then-的链式调用与-microtask-队列"><a href="#then-的链式调用与-microtask-队列" class="headerlink" title="then 的链式调用与 microtask 队列"></a>then 的链式调用与 microtask 队列</h2><pre><code>Promise.resolve(&#39;123&#39;)    .then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)    .then(_ =&gt; &#123;        console.log(&#39;shouldnot be here&#39;)    &#125;)    .catch((e) =&gt; console.log(e))    .then((data) =&gt; console.log(data));</code></pre><p>以上代码运行后，打印 Error: 456 和 undefined。为了便于叙述，将 then 的链式调用写法改为啰嗦写法。</p><pre><code>const p0 = Promise.resolve(&#39;123&#39;)const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)const p2 = p1.then(_ =&gt; &#123;    console.log(&#39;shouldnot be here&#39;)&#125;)const p3 = p2.catch((e) =&gt; console.log(e))const p4 = p3.then((data) =&gt; console.log(data));</code></pre><p>then 方法返回新的 Promise，所以 p0、p1、p2、p3 和 p4 这 5 个 Promise 互不相等。</p><p>p0 开始便处于 fulfilled 状态，当执行</p><pre><code>const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)</code></pre><p>时，由于 p0 已是 fulfilled 状态，直接将 p0 的 fulfilled 处理函数插入 microtask 队列，此时 microtask 队列简略示意图如下，绿色区域表示 microtask，蓝色区域表示 microtask 队列。</p><p><img src="https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg"></p><p>跑完余下所有的代码。</p><pre><code>const p1 = p0.then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)const p2 = p1.then(_ =&gt; &#123;    console.log(&#39;shouldnot be here&#39;)&#125;)const p3 = p2.catch((e) =&gt; console.log(e))const p4 = p3.then((data) =&gt; console.log(data));</code></pre><p>p1、p2、p3 和 p4 这 4 个 Promise 都处于 pending 状态，microtask 队列还是</p><p><img src="https://pic1.zhimg.com/v2-b76765948999a1a9792f5caee63e9f20_b.jpg"></p><p><img src="https://pic1.zhimg.com/80/v2-b76765948999a1a9792f5caee63e9f20_720w.jpg"></p><p>开始执行 microtask 队列，核心方法是 <a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/builtins-microtask-queue-gen.cc#114">MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask</a>，代码是用 CodeStubAssembler 写的，代码很长，逻辑简单，评论区经常有提看不懂 CodeStubAssembler 这种类汇编语言，这里就不再贴代码了，预计之后的版本 V8 会用 Torque 重写。</p><p>在执行 microtask 的过程中，MicrotaskQueueBuiltinsAssembler::RunSingleMicrotask 会调用 <a href="https://chromium.googlesource.com/v8/v8.git/+/refs/heads/8.4-lkgr/src/builtins/promise-reaction-job.tq#43">PromiseReactionJob</a>，源码如下：</p><pre><code>transitioningmacro PromiseReactionJob(    context: Context, argument: JSAny, handler: Callable|Undefined,    promiseOrCapability: JSPromise|PromiseCapability|Undefined,    reactionType: constexpr PromiseReactionType): JSAny &#123;  if (handler == Undefined) &#123;    // 没有处理函数的 case，透传上一个 Promise 的 argument 和状态    if constexpr (reactionType == kPromiseReactionFulfill) &#123;      // 基本类同 JS 层的 resolve      return FuflfillPromiseReactionJob(          context, promiseOrCapability, argument, reactionType);    &#125; else &#123;      // 基本类同 JS 层的 reject      return RejectPromiseReactionJob(          context, promiseOrCapability, argument, reactionType);    &#125;  &#125; else &#123;    try &#123;      // 试图调用 Promise 处理函数，相当于 handler(argument)      const result =          Call(context, UnsafeCast&lt;Callable&gt;(handler), Undefined, argument);        // 基本类同 JS 层的 resolve        return FuflfillPromiseReactionJob(            context, promiseOrCapability, result, reactionType);    &#125; catch (e) &#123;      // 基本类同 JS 层的 reject      return RejectPromiseReactionJob(          context, promiseOrCapability, e, reactionType);    &#125;  &#125;&#125;</code></pre><p>PromiseReactionJob 接收的参数和 microtask 密切相关，当下 argument 参数是 ‘123’，handler 是函数 () =&gt; {throw new Error(‘456’)}，promiseOrCapability 是 p1，reactionType 是 kPromiseReactionFulfill。</p><p>handler 有值，进入 else 分支，在 try…catch 包裹下，试图调用 handler。handler 里 throw new Error(‘456’) 抛出异常，被 catch 捕捉，调用 RejectPromiseReactionJob 方法，从函数名字也可以看出，p1 最终状态为 rejected。后面的代码和 JS 层面直接调用 reject 代码差不多，向 microtask 队列插入一个 microtask，这里不再赘述。当前 microtask 执行完毕后，会从 microtask 队列移除。</p><p>新增一个新 microtask，移除一个旧 microtask 后，microtask 队列简略示意图如下：</p><p><img src="https://pic3.zhimg.com/v2-8e7fbe19cb37343a03863586d5010392_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-8e7fbe19cb37343a03863586d5010392_720w.jpg"></p><p>handler 为 undefined 的原因是 p1 的最终状态是 rejected，但却没有 rejected 状态的处理函数。</p><p>开始执行下一个 microtask，还是调用上文提到的 PromiseReactionJob，argument 参数为 Error(‘456’)，handler 是 undefined，promiseOrCapability 是 p2，reactionType 是 kPromiseReactionReject。由于 handler 是 undefined，这一次走的是 if 分支，最终调用了 RejectPromiseReactionJob，将 p2 状态置为 rejected。p1 相当于一个中转站，收到了 Error(‘456’)，自己没有相应状态的处理函数，把从 p0 收到的 Error(‘456’) 和 rejected 状态继续向下传给了 p2。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p><p><img src="https://pic2.zhimg.com/v2-7bd35a3021afe3a62d96da69bfa51991_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-7bd35a3021afe3a62d96da69bfa51991_720w.jpg"></p><p>还是执行下一个 microtask，还是调用 PromiseReactionJob，argument 是 Error(‘456’)，handler 是 (e) =&gt; console.log(e)，promiseOrCapability 是 p3，reactionType 是 kPromiseReactionReject。在 try…catch 中试图 handler，handler 不再抛异常，打印 Error(‘456’)，返回 undefined。最后调用 FuflfillPromiseReactionJob，使 p3 最终状态是 fulfilled。执行完当前 microtask 后，microtask 队列的简略示意图如下：</p><p><img src="https://pic2.zhimg.com/v2-52b0effde7fe63bbcf2859084bfdf549_b.jpg"></p><p><img src="https://pic2.zhimg.com/80/v2-52b0effde7fe63bbcf2859084bfdf549_720w.jpg"></p><p>后面的流程和之前一样，就不解释了，上一个 microtask 的 handler (e) =&gt; console.log(e) 的返回值是 undefined，所以 (data) =&gt; console.log(data) 打印 undefined。</p><p>执行完所有 microtask 后，p0、p1、p2、p3 和 p4 状态如下，图是从浏览器控制台截的。</p><p><img src="https://pic3.zhimg.com/v2-0ac8534809d172ba5c83909e762adfb6_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-0ac8534809d172ba5c83909e762adfb6_720w.jpg"></p><p>回头再看这段代码，catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路，恢复成 fulfilled 状态，使后面的处理函数 (data)=&gt; console.log(data) 得到执行的机会。</p><pre><code>// 链式调用，每一级接收上一级的 argument 和状态(fulfilled/rejected)// 调用本级的 handler，将本级的 argument 和状态传给下一级// 有点类似数组的 reduce 方法Promise.resolve(&#39;123&#39;)    .then(() =&gt; &#123;throw new Error(&#39;456&#39;)&#125;)    .then(_ =&gt; &#123;        console.log(&#39;shouldnot be here&#39;)    &#125;)    // catch 在这里的作用相当于是把一个 rejected 状态的 Promise 链路    // 恢复成 fulfilled 状态    .catch((e) =&gt; console.log(e))    .then((data) =&gt; console.log(data));</code></pre><h2 id="总结与感想"><a href="#总结与感想" class="headerlink" title="总结与感想"></a>总结与感想</h2><p>本文看似篇幅略长，其实大部分内容是 <a href="https://promisesaplus.com/#notes">Promise A+</a> 规范的 2.2.7 节，规范简直字字珠玑，膜拜。</p><p><img src="https://pic3.zhimg.com/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_b.jpg"></p><p><img src="https://pic3.zhimg.com/80/v2-92c6a4febebd1aa1fc024b29ebaf2f3e_720w.jpg"></p><h2 id="转载说明"><a href="#转载说明" class="headerlink" title="转载说明"></a>转载说明</h2><p>本文经由作者同意，转载自知乎用户<a href="https://www.zhihu.com/people/kan-a-79">徐鹏跃</a><br><a href="https://sm.ms/image/Xvb1CJr7QTI26ei" target="_blank"><img src="https://i.loli.net/2020/12/14/Xvb1CJr7QTI26ei.png" ></a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底理解Promise原理及全功能实现</title>
      <link href="2020/11/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Promise%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>2020/11/20/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3Promise%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="彻底理解-Promise-原理及全功能实现"><a href="#彻底理解-Promise-原理及全功能实现" class="headerlink" title="彻底理解 Promise 原理及全功能实现"></a>彻底理解 Promise 原理及全功能实现</h1><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p><strong>Promise</strong>作为前端异步解决方案的出现，可以说是火遍全网，几乎所有的异步场景甚至框架都会有它的身影，比如<strong>Vue</strong>的批量处理等。今天我们就按照<strong>Promise A+</strong> 规范来完整实现<strong>Promise</strong>全功能，话不多说，上代码。</p><h2 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h2><h3 id="status-状态定义"><a href="#status-状态定义" class="headerlink" title="status 状态定义"></a>status 状态定义</h3><p><strong>Promise</strong>的设定是一个不可逆的状态机，包含：</p><pre><code>const PENDDING = &quot;PENDDING&quot;; // 初始化pendding状态const RESOLVED = &quot;RESOLVED&quot;; // 正确完成resolve状态const REJECTED = &quot;REJECTED&quot;; // 错误完成reject状态</code></pre><h3 id="MyPromise"><a href="#MyPromise" class="headerlink" title="MyPromise"></a>MyPromise</h3><p>创建<strong>MyPromise</strong>类函数和初始化相对应的值和状态</p><pre><code>class MyPromise &#123;  constructor(executor) &#123;    // 初始化状态status    // 返回值value    // 错误原因reason    this.status = PENDDING;    this.value = undefined;    this.reason = undefined;    // 返回值回调队列和错误回调队列    this.resolves = [];    this.rejects = [];    // 声明resolve函数    const resolve = (value) =&gt; &#123;      if (this.status === PENDDING) &#123;        this.status = RESOLVED; // 变更状态为完成状态        this.value = value; // 赋值        // 执行resolves队列        while (this.resolves.length) &#123;          const callback = this.resolves.shift();          callback(value);        &#125;      &#125;    &#125;;    // 声明reject函数    const reject = (reason) =&gt; &#123;      if (this.statue === PENDDING) &#123;        this.status = REJECTED; // 变更状态为拒绝状态        this.reason = reason; // 赋值        // 执行rejects队列        while (this.rejects.length) &#123;          const callback = this.rejects.shift();          callback(reason);        &#125;      &#125;    &#125;;    try&#123;        executor(resolve,reject)    &#125;catch(e)&#123;        reject(e)    &#125;  &#125;&#125;</code></pre><h3 id="MyPromise-then"><a href="#MyPromise-then" class="headerlink" title="MyPromise.then"></a>MyPromise.then</h3><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><pre><code>class MyPromise &#123;  // ...  then(resolve, reject) &#123;    // 完成状态，推入完成队列    if (this.status === RESOLVED) &#123;      resolve(this.value);    &#125;    // 拒绝状态，推入拒绝队列    if (this.status === REJECTED) &#123;      reject(this.reason);    &#125;    // 异步情况    if (this.status === PENDDING) &#123;      this.resolves.push(resolve);      this.rejects.push(reject);    &#125;  &#125;  // ...&#125;// 测试同步任务const promise = new MyPromise((resolve, reject) =&gt; &#123;    resolve(&#39;promise sync&#39;)&#125;)promise.then(res =&gt; &#123;    console.log(res)&#125;)// 打印结果// promise sync// 测试异步任务const promise = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;        resolve(&#39;promise async)    &#125;, 500)&#125;)promise.then(res =&gt; &#123;    console.log(res)&#125;)// 打印结果// promise async</code></pre><h4 id="Promise-A-规范场景"><a href="#Promise-A-规范场景" class="headerlink" title="Promise A+规范场景"></a>Promise A+规范场景</h4><blockquote><p>根据 Promise A+ 规范，then 方法会返回一个 promise，从而支持向下链式调用。同时可以根据上一个 then 的返回值，透传给下一个 then 方法。</p></blockquote><pre><code>// Promise A+const promise = new Promise((resolve, reject) =&gt; &#123;  resolve(&quot;first&quot;);&#125;);// 第一种场景：返回常规值promise  .then((res) =&gt; &#123;    console.log(res);    return &quot;second&quot;;  &#125;)  .then((res) =&gt; &#123;    console.log(res);  &#125;);// 打印结果// first// second// 第二种场景：返回promisepromise  .then((res) =&gt; &#123;    console.log(res);    return new Promise((resolve) =&gt; &#123;      resolve(&quot;promise&quot;);    &#125;);  &#125;)  .then((res) =&gt; &#123;    console.log(res);  &#125;);// 打印结果// first// promise// 第三种场景：值穿透promise  .then((res) =&gt; &#123;    console.log(res);    return res;  &#125;)  .then()  .then((res) =&gt; &#123;    console.log(res);  &#125;);// 打印结果// first// first</code></pre><h4 id="实现-then"><a href="#实现-then" class="headerlink" title="实现 then"></a>实现 then</h4><p>根据以上规范定义，我们来改造一下<strong>then</strong>方法：</p><pre><code>class MyPromise &#123;  // ...  then(resolve, reject) &#123;    // 判断resolve和reject未传入的情况，解决空值透传问题    // then()情况    typeof resolve !== &#39;function&#39; ? resolve = value =&gt; value : resolve    typeof reject !== &#39;function&#39; ? reject = reason =&gt; throw new Error(reason instanceof Error ? reason.message : reason )    //根据规范，then会返回一个全新的promise    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;        // 重写传入的resolve方法        // 判断返回值        const fulfilished = value =&gt; &#123;            try&#123;                // 接收返回值                const res = resolve(value)                // 判断返回值类型：promise或普通类型                // 如果是promise，则往下执行一次then                // 如果是普通类型，则直接执行resolveFn，保证value是最新值                res instanceof MyPromise ? res.then(resolveFn,rejectFn) : resolveFn(res)            &#125;catch(e) &#123;                rejectFn(e)            &#125;        &#125;        // 重写传入的reject方法        // 判断返回值        const rejected = reason =&gt; &#123;            try&#123;        // 接收返回值                const res = reject(reason)                // 判断返回值类型：promise或普通类型                // 如果是promise，则往下执行一次then                // 如果是普通类型，则直接执行rejectFn，保证value是最新值                res instanceof MyPromise ? res.then(resolveFn,rejectFn) : rejectFn(res)            &#125;catch(e)&#123;                rejectFn(e instanceof Error ? e.message: e)            &#125;        &#125;        // 判断同步异步任务        // 执行相对应的方法        // 这里用switch方法改进        switch(this.status) &#123;            case RESOLVED:                fulfilished(this.value)            break;            case REJECTED:                rejected(this.reason)            break;            case PENDDING:                this.resolves.push(fulfilished)                this.rejects.push(rejected)              break;        &#125;    &#125;)  &#125;  // ...&#125;// 测试const promise = new MyPromise((resolve, reject) =&gt; &#123;    resolve(&#39;first&#39;)&#125;)promise.then(res =&gt; &#123;    console.log(res)    return new MyPromise((resolve, reject) =&gt; &#123;        resolve(&#39;promise second&#39;)    &#125;)&#125;).then().then(res =&gt; &#123;    console.log(res)    return &#39;third&#39;&#125;).then(res =&gt; &#123;    console.log(res)&#125;)// 打印结果// first// promise second// third</code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>测试成功，<strong>promise</strong>的改造就算符合规范了。这个难点在于<strong>then</strong>内函数的返回值如果是<strong>promise</strong>，那么我们会先让他执行注册一次<strong>then</strong>，让<strong>promise</strong>接着往下执行。</p><h3 id="MyPromise-catch"><a href="#MyPromise-catch" class="headerlink" title="MyPromise.catch"></a>MyPromise.catch</h3><p><strong>catch</strong>方法相对比较简单，将拒绝的值放到<strong>reject</strong>方法里执行就可以。</p><h4 id="Promise-A-规范场景-1"><a href="#Promise-A-规范场景-1" class="headerlink" title="Promise A+规范场景"></a>Promise A+规范场景</h4><pre><code>// Promise A+const promise = new Promise((resolve, reject) =&gt; &#123;  reject(&quot;promise reject&quot;);&#125;);promise.catch((e) =&gt; &#123;  console.log(e);&#125;);// 打印结果// promise reject</code></pre><h4 id="实现-catch"><a href="#实现-catch" class="headerlink" title="实现 catch"></a>实现 catch</h4><pre><code>class MyPromise &#123;  // ...  catch(errorFn) &#123;    // 这里只需注册执行下then，传入callback就能实现    this.then(null, errorFn);  &#125;  // ...&#125;// 测试const promise = new MyPromise((resolve, reject) =&gt; &#123;  reject(&quot;my promise reject&quot;);&#125;);promise.catch((e) =&gt; &#123;  console.log(e);&#125;);// 打印结果// my promise reject</code></pre><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p><strong>catch</strong>方法在于执行回调去获取<strong>reject</strong>的结果，所以只需执行一下<strong>then</strong>并传入<strong>callback</strong>就实现了，相对好理解。</p><h3 id="MyPromise-all"><a href="#MyPromise-all" class="headerlink" title="MyPromise.all"></a>MyPromise.all</h3><p>业务场景中，我们经常会遇到不止一个<strong>promie</strong>的场景，因此需要合并一次执行多个<strong>promise</strong>，统一返回结果，<strong>Promise.all</strong>就是为了解决此问题。</p><h4 id="Promise-A-规范场景-2"><a href="#Promise-A-规范场景-2" class="headerlink" title="Promise A+规范场景"></a>Promise A+规范场景</h4><pre><code>  // Promise A+  // 创建三个promise  const promise1 = Promise.resolve(1)  const promise2 = Promise.resolve(2)  const promise3 = Promise.resolve(3)  Promise.all([promise1,promise12,promise3]).then(res =&gt; &#123;    console.log(res)  &#125;)  // 打印结果  // [1,2,3]  // 添加一个reject  const promise4 = Promise.resolve(1)  const promise5 = Promise.reject(&#39;reject&#39;)  const promise6 = Promise.resolve(3)  Promise.all([promise4, promise5,promise6]).then(res =&gt; &#123;    console.log(res, &#39;resolve&#39;)  &#125;).catch(e =&gt; &#123;    console.log(e)  &#125;)  // 打印结果  // reject</code></pre><blockquote><p>根据 Promise A+规范，Promise.all 可以同时执行多个 Promise，并且在所有的 Promise 方法都返回完成之后才返回一个数组返回值。当有其中一个 Promise reject 的时候，则返回 reject 的结果。</p></blockquote><h4 id="实现-Promise-all"><a href="#实现-Promise-all" class="headerlink" title="实现 Promise.all"></a>实现 Promise.all</h4><p>我们来实现一下：</p><pre><code>  class MyPromise &#123;    // ...    // all是静态方法    static all(promises) &#123;      // 已然是返回一个promise      return new MyPromise((resolve, reject) =&gt; &#123;        // 创建一个收集返回值的数组        const result = []        // 执行        deepPromise(promises[0], 0 , result)        // 返回结果        resolve(result)        // 这里我们用递归来实现        // @param &#123;MyPromise&#125; promise 每一个promise方法        // @param &#123;number&#125; index 索引        // @param &#123;string[]&#125; result 收集返回结果的数组        function deepPromise(promise, index, result) &#123;          // 边界判断          // 所有执行完之后返回收集数组          if(index &gt; promises.length - 1) &#123;            return result          &#125;          if(typeof promise.then === &#39;function&#39;) &#123;            // 如果是promise            promise.then(res =&gt; &#123;              index++              result.push(res)              deepPromise(promises[index], index, result)            &#125;).catch(e =&gt; &#123;              // reject直接返回              reject(e instanceof Error ? e.message : e)            &#125;)          &#125;else &#123;            // 如果是普通值            // 这里我们只做简单判断，非promise则直接当返回值处理            index++            result.push(promise)            deepPromise(promises[index], index, res)          &#125;        &#125;      &#125;)    &#125;    // ...  &#125;  // 测试  // 创建三个MyPromise  const promise1 = MyPromise.resolve(1)  const promise2 = MyPromise.resolve(2)  const promise3 = MyPromise.resolve(3)  MyPromise.all([promise1,promise12,promise3]).then(res =&gt; &#123;    console.log(res)  &#125;)  // 打印结果  // [1,2,3]  // 添加一个reject  const promise4 = MyPromise.resolve(1)  const promise5 = MyPromise.reject(&#39;reject&#39;)  const promise6 = MyPromise.resolve(3)  MyPromise.all([promise4, promise5,promise6]).then(res =&gt; &#123;    console.log(res, &#39;resolve&#39;)  &#125;).catch(e =&gt; &#123;    console.log(e)  &#125;)  // 打印结果  // reject</code></pre><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p><strong>Promise.all</strong>作为一个批量处理的函数，让我们在使用时可以同时多个处理<strong>promise</strong>，简化了逐个执行的劣势。核心逻辑也相对比较简单，最重要的点在于执行完一个<strong>promise</strong>后再去执行下一个<strong>promise</strong>，处理完这个逻辑也就基本完成了<strong>Promise.all</strong>的全功能了。</p><h3 id="MyPromise-resolve"><a href="#MyPromise-resolve" class="headerlink" title="MyPromise.resolve"></a>MyPromise.resolve</h3><p>静态方法<strong>resolve</strong>的实现就相对简单了，返回一个<strong>promise</strong>，传入对应参数即可。</p><h4 id="实现-MyPromise-resolve"><a href="#实现-MyPromise-resolve" class="headerlink" title="实现 MyPromise.resolve"></a>实现 MyPromise.resolve</h4><pre><code>  class MyPromise &#123;    // ...    static resolve(value) &#123;      return new MyPromise((resolveFn, rejectFn) =&gt; &#123;        resolveFn(value)      &#125;)    &#125;    // ...  &#125;  // 测试  MyPromise.resolve(&#39;static resolve&#39;).then(res =&gt; &#123;    console.log(res)  &#125;)  // 打印结果  // static resolve</code></pre><h3 id="MyPromise-reject"><a href="#MyPromise-reject" class="headerlink" title="MyPromise.reject"></a>MyPromise.reject</h3><p>静态方法<strong>reject</strong>的实现跟<strong>resolve</strong>是类似，返回一个<strong>promise</strong>，传入对应参数即可。</p><pre><code>  class MyPromise &#123;    // ...    static reject(reason) &#123;      return new MyPromise((resolveFn, rejectFn) =&gt; &#123;        rejectFn(reason)      &#125;)    &#125;    // ...  &#125;  // 测试  MyPromise.reject(&#39;static reject&#39;).catch(e =&gt; &#123;    console.log(res)  &#125;)  // 打印结果  // static reject</code></pre><h3 id="什么是-allSettled？"><a href="#什么是-allSettled？" class="headerlink" title="什么是 allSettled？"></a>什么是 allSettled？</h3><p>ECMA 官网最新更新了<strong>Promise</strong>的新的静态方法<strong>Promise.allSettled</strong>，那么这是一个怎样的方法呢？总体来讲他也是一个批量处理<strong>Promise</strong>的函数，但是我们已经有了<strong>Promise.all</strong>，为什么还需要<strong>allSettled</strong>。要解开这个问题，我们得回顾一下<strong>Promise.all</strong>。现有的<strong>Promise.all</strong>我们说过，如果<strong>Promise</strong>队列里有一个<strong>reject</strong>，那么他就只会返回<strong>reject</strong>，所以<strong>Promise.all</strong>不一定会返回所有结果，很显然<strong>Promise.allSettled</strong>能够解决这个问题。</p><h4 id="Promise-A-测试场景"><a href="#Promise-A-测试场景" class="headerlink" title="Promise A+测试场景"></a>Promise A+测试场景</h4><pre><code>   // Promise A+  // 创建三个promise  const promise1 = Promise.resolve(1)  const promise2 = Promise.resolve(2)  const promise3 = Promise.resolve(3)  Promise.allSettled([promise1,promise12,promise3]).then(res =&gt; &#123;    console.log(res)  &#125;)  // 打印结果  /*  [    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,    &#123;status: &#39;fulfilished&#39;, value: 2&#125;,    &#123;status: &#39;fulfilished&#39;, value: 3&#125;  ]  */  // 添加一个reject  const promise4 = Promise.resolve(1)  const promise5 = Promise.reject(&#39;reject&#39;)  const promise6 = Promise.resolve(3)  Promise.allSettled([promise4, promise5,promise6]).then(res =&gt; &#123;    console.log(res, &#39;resolve&#39;)  &#125;).catch(e =&gt; &#123;    console.log(e)  &#125;)  // 打印结果   /*  [    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,    &#123;status: &#39;rejected&#39;, value: &#39;reject&#39;&#125;,    &#123;status: &#39;fulfilished&#39;, value: 3&#125;  ]  */</code></pre><p>可以看出来<strong>allSettled</strong>和 all 最大的区别就是，<strong>allSettled</strong>不管是<strong>resolve</strong>，还是<strong>reject</strong>都能完整返回结果数组，只不过每个数组项都是以对象的形式输出，<strong>status</strong>描述状态，<strong>value</strong>接收返回值。</p><h4 id="实现-MyPromise-allSettled"><a href="#实现-MyPromise-allSettled" class="headerlink" title="实现 MyPromise.allSettled"></a>实现 MyPromise.allSettled</h4><p><strong>allSettled</strong>的整体逻辑跟<strong>all</strong>是一样的，只不过返回值的处理稍微有所不同</p><pre><code>  class MyPromise &#123;// ...  static allSettled(promises) &#123;      // 已然是返回一个promise      return new MyPromise((resolve, reject) =&gt; &#123;        // 创建一个收集返回值的数组        const result = []        // 执行        deepPromise(promises[0], 0 , result)        // 返回结果        resolve(result)        // 这里我们用递归来实现        // @param &#123;MyPromise&#125; promise 每一个promise方法        // @param &#123;number&#125; index 索引        // @param &#123;string[]&#125; result 收集返回结果的数组        function deepPromise(promise, index, result) &#123;          // 边界判断          // 所有执行完之后返回收集数组          if(index &gt; promises.length - 1) &#123;            return result          &#125;          if(typeof promise.then === &#39;function&#39;) &#123;            // 如果是promise            promise.then(res =&gt; &#123;              index++              result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象              deepPromise(promises[index], index, result)            &#125;).catch(e =&gt; &#123;              // reject直接返回              index ++              result.push(&#123;status: &#39;rejected&#39;, value: res&#125;) // 这里推入的是对象              deepPromise(promises[index], index, result)            &#125;)          &#125;else &#123;            // 如果是普通值            // 这里我们只做简单判断，非promise则直接当返回值处理            index++            result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象            deepPromise(promises[index], index, res)          &#125;        &#125;      &#125;)    &#125;  // ...  &#125;  // 测试  // 创建三个promise  const promise1 = MyPromise.resolve(1)  const promise2 = MyPromise.resolve(2)  const promise3 = MyPromise.resolve(3)  MyPromise.allSettled([promise1,promise12,promise3]).then(res =&gt; &#123;    console.log(res)  &#125;)  // 打印结果  /*  [    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,    &#123;status: &#39;fulfilished&#39;, value: 2&#125;,    &#123;status: &#39;fulfilished&#39;, value: 3&#125;  ]  */  // 添加一个reject  const promise4 = MyPromise.resolve(1)  const promise5 = MyPromise.reject(&#39;reject&#39;)  const promise6 = MyPromise.resolve(3)  Promise.allSettled([promise4, promise5,promise6]).then(res =&gt; &#123;    console.log(res, &#39;resolve&#39;)  &#125;).catch(e =&gt; &#123;    console.log(e)  &#125;)  // 打印结果   /*  [    &#123;status: &#39;fulfilished&#39;, value: 1&#125;,    &#123;status: &#39;rejected&#39;, value: &#39;reject&#39;&#125;,    &#123;status: &#39;fulfilished&#39;, value: 3&#125;  ]  */</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code>class MyPromise &#123;  constructor(executor) &#123;    // 初始化状态status    // 返回值value    // 错误原因reason    this.statue = PENDDING;    this.value = undefined;    this.reason = undefined;    // 返回值回调队列和错误回调队列    this.resolves = [];    this.rejects = [];    // 声明resolve函数    const resolve = (value) =&gt; &#123;      if (this.status === PENDDING) &#123;        this.status = RESOLVED; // 变更状态为完成状态        this.value = value; // 赋值        // 执行resolves队列        while (this.resolves.length) &#123;          const callback = this.resolves.shift();          callback(value);        &#125;      &#125;    &#125;;    // 声明reject函数    const reject = (reason) =&gt; &#123;      if (this.statue === PENDDING) &#123;        this.status = REJECTED; // 变更状态为拒绝状态        this.reason = reason; // 赋值        // 执行rejects队列        while (this.rejects.length) &#123;          const callback = this.rejects.shift();          callback(reason);        &#125;      &#125;    &#125;;    try&#123;        executor(resolve,reject)    &#125;catch(e)&#123;        reject(e)    &#125;  &#125;  // then  then(resolve, reject) &#123;    // 判断resolve和reject未传入的情况，解决空值透传问题    // then()情况    typeof resolve !== &#39;function&#39; ? resolve = value =&gt; value : resolve    typeof reject !== &#39;function&#39; ? reject = reason =&gt; throw new Error(reason instanceof Error ? reason.message : reason): reject    //根据规范，then会返回一个全新的promise    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;        // 重写传入的resolve方法        // 判断返回值        const fulfilished = value =&gt; &#123;            try&#123;                // 接收返回值                const res = resolve(value)                // 判断返回值类型：promise或普通类型                // 如果是promise，则往下执行一次then                // 如果是普通类型，则直接执行resolveFn，保证value是最新值                res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : resolveFn(res)            &#125;catch(e) &#123;                rejectFn(e)            &#125;        &#125;        // 重写传入的reject方法        // 判断返回值        const rejected = reason =&gt; &#123;            try&#123;        // 接收返回值                const res = reject(reason)                // 判断返回值类型：promise或普通类型                // 如果是promise，则往下执行一次then                // 如果是普通类型，则直接执行rejectFn，保证value是最新值                res instanceof MyPromise ? MyPromise.then(resolveFn,rejectFn) : rejectFn(res)            &#125;catch(e)&#123;                rejectFn(e instanceof Error ? e.message: e)            &#125;        &#125;        // 判断同步异步任务        // 执行相对应的方法        // 这里用switch方法改进        switch(this.status) &#123;            case RESOLVED:                fulfilished(this.value)            break;            case REJECTED:                rejected(this.reason)            break;            case PENDDING:                this.resolves.push(fulfilished)                this.rejects.push(rejected)              break;        &#125;    &#125;)  &#125;  catch(errorFn) &#123;    // 这里只需注册执行下then，传入callback就能实现    this.then(null, errorFn);  &#125;  // resolve  static resolve(value) &#123;    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;      resolveFn(value)    &#125;)  &#125;    // reject  static reject(reason) &#123;    return new MyPromise((resolveFn, rejectFn) =&gt; &#123;      rejectFn(reason)    &#125;)  &#125;  // all  static all(promises) &#123;    // 已然是返回一个promise    return new MyPromise((resolve, reject) =&gt; &#123;      // 创建一个收集返回值的数组      const result = []      // 执行      deepPromise(promises[0], 0 , result)      // 返回结果      resolve(result)      // 这里我们用递归来实现      // @param &#123;MyPromise&#125; promise 每一个promise方法      // @param &#123;number&#125; index 索引      // @param &#123;string[]&#125; result 收集返回结果的数组      function deepPromise(promise, index, result) &#123;        // 边界判断        // 所有执行完之后返回收集数组        if(index &gt; promises.length - 1) &#123;          return result        &#125;        if(typeof promise.then === &#39;function&#39;) &#123;          // 如果是promise          promise.then(res =&gt; &#123;            index++            result.push(res)            deepPromise(promises[index], index, result)          &#125;).catch(e =&gt; &#123;            // reject直接返回            reject(e instanceof Error ? e.message : e)          &#125;)        &#125;else &#123;          // 如果是普通值          // 这里我们只做简单判断，非promise则直接当返回值处理          index++          result.push(promise)          deepPromise(promises[index], index, res)        &#125;      &#125;    &#125;)  &#125;  // allSettled  static allSettled(promises) &#123;      // 已然是返回一个promise      return new MyPromise((resolve, reject) =&gt; &#123;        // 创建一个收集返回值的数组        const result = []        // 执行        deepPromise(promises[0], 0 , result)        // 返回结果        resolve(result)        // 这里我们用递归来实现        // @param &#123;MyPromise&#125; promise 每一个promise方法        // @param &#123;number&#125; index 索引        // @param &#123;string[]&#125; result 收集返回结果的数组        function deepPromise(promise, index, result) &#123;          // 边界判断          // 所有执行完之后返回收集数组          if(index &gt; promises.length - 1) &#123;            return result          &#125;          if(typeof promise.then === &#39;function&#39;) &#123;            // 如果是promise            promise.then(res =&gt; &#123;              index++              result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象              deepPromise(promises[index], index, result)            &#125;).catch(e =&gt; &#123;              // reject直接返回              index ++              result.push(&#123;status: &#39;rejected&#39;, value: res&#125;) // 这里推入的是对象              deepPromise(promises[index], index, result)            &#125;)          &#125;else &#123;            // 如果是普通值            // 这里我们只做简单判断，非promise则直接当返回值处理            index++            result.push(&#123;status: &#39;fulfilished&#39;, value: res&#125;) // 这里推入的是对象            deepPromise(promises[index], index, res)          &#125;        &#125;      &#125;)    &#125;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此<strong>Promise A+**的完整的方法和实现就完成了，个人觉得实现</strong>promise<strong>的难点在于理解</strong>then**的值如何处理透传，这一个点能够理解的话，其它方法和逻辑都会比较顺其自然</p><h2 id="关于转载"><a href="#关于转载" class="headerlink" title="关于转载"></a>关于转载</h2><p>转载自<a href="https://juejin.cn/post/6866372840451473415#heading-0">掘金</a> 作者<a href="https://juejin.cn/user/448256474885159">MichaelHong</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    
    
    <entry>
      <title>理解 JavaScript 的 async/await</title>
      <link href="2020/11/13/%E7%90%86%E8%A7%A3%20JavaScript%20%E7%9A%84%20async&amp;await/"/>
      <url>2020/11/13/%E7%90%86%E8%A7%A3%20JavaScript%20%E7%9A%84%20async&amp;await/</url>
      
        <content type="html"><![CDATA[<h1 id="理解-JavaScript-的-async-await"><a href="#理解-JavaScript-的-async-await" class="headerlink" title="理解 JavaScript 的 async/await"></a><a href="">理解 JavaScript 的 async/await</a></h1><p>JavaScript 中的 async/await 是 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction">AsyncFunction 特性</a> 中的关键字。目前为止，除了 IE 之外，常用浏览器和 Node (v7.6+) 都已经支持该特性。具体支持情况可以在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction#Browser_compatibility">这里</a> 查看。</p><hr><p>我第一次看到 async/await 这组关键字并不是在 JavaScript 语言里，而是在 C# 5.0 的语法中。C# 的 async/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。</p><p>我之前在<a href="https://segmentfault.com/a/1190000003742890">《闲谈异步调用“扁平”化》</a> 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async/await 实现离不开 <a href="https://msdn.microsoft.com/library/dd321424.aspx">Task 或 Task<Result></a> 类，而 JavaScript 的 async/await 实现，也离不开 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>。</p><p>现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async/await。</p><h2 id="1-async-和-await-在干什么"><a href="#1-async-和-await-在干什么" class="headerlink" title="1. async 和 await 在干什么"></a>1. async 和 await 在干什么</h2><p>任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><p>另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？</p><p>如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……</p><p>如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？</p><h3 id="1-1-async-起什么作用"><a href="#1-1-async-起什么作用" class="headerlink" title="1.1. async 起什么作用"></a>1.1. async 起什么作用</h3><p>这个问题的关键在于，async 函数是怎么处理它的返回值的！</p><p>我们当然希望它能直接通过 <code>return</code> 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：</p><pre><code>async function testAsync() &#123;    return &quot;hello async&quot;;&#125;const result = testAsync();console.log(result);</code></pre><p>看到输出就恍然大悟了——输出的是一个 Promise 对象。</p><pre><code>c:\var\test&gt; node --harmony_async_await .Promise &#123; &#39;hello async&#39; &#125;</code></pre><p>所以，async 函数返回的是一个 Promise 对象。从<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/async_function">文档</a>中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda 表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p><blockquote><p>补充知识点 <em>[2020-06-04]</em></p><p><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p></blockquote><p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样</p><pre><code>testAsync().then(v =&gt; &#123;    console.log(v);    // 输出 hello async&#125;);</code></pre><p>现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p><p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p><p>那么下一个关键点就在于 await 关键字了。</p><h3 id="1-2-await-到底在等啥"><a href="#1-2-await-到底在等啥" class="headerlink" title="1.2. await 到底在等啥"></a>1.2. await 到底在等啥</h3><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/await">语法说明</a>，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p><p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行</p><pre><code>function getSomething() &#123;    return &quot;something&quot;;&#125;async function testAsync() &#123;    return Promise.resolve(&quot;hello async&quot;);&#125;async function test() &#123;    const v1 = await getSomething();    const v2 = await testAsync();    console.log(v1, v2);&#125;test();</code></pre><h3 id="1-3-await-等到了要等的，然后呢"><a href="#1-3-await-等到了要等的，然后呢" class="headerlink" title="1.3. await 等到了要等的，然后呢"></a>1.3. await 等到了要等的，然后呢</h3><p>await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，<code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</p><p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p><p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p><blockquote><p>看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p></blockquote><h2 id="2-async-await-帮我们干了啥"><a href="#2-async-await-帮我们干了啥" class="headerlink" title="2. async/await 帮我们干了啥"></a>2. async/await 帮我们干了啥</h2><h3 id="2-1-作个简单的比较"><a href="#2-1-作个简单的比较" class="headerlink" title="2.1. 作个简单的比较"></a>2.1. 作个简单的比较</h3><p>上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p><p>现在举例，用 <code>setTimeout</code> 模拟耗时的异步操作，先来看看不用 async/await 会怎么写</p><pre><code>function takeLongTime() &#123;    return new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);    &#125;);&#125;takeLongTime().then(v =&gt; &#123;    console.log(&quot;got&quot;, v);&#125;);</code></pre><p>如果改用 async/await 呢，会是这样</p><pre><code>function takeLongTime() &#123;    return new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000);    &#125;);&#125;async function test() &#123;    const v = await takeLongTime();    console.log(v);&#125;test();</code></pre><p>眼尖的同学已经发现 <code>takeLongTime()</code> 没有申明为 <code>async</code>。实际上，<code>takeLongTime()</code> 本身就是返回的 Promise 对象，加不加 <code>async</code> 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。</p><p>又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？</p><h3 id="2-2-async-await-的优势在于处理-then-链"><a href="#2-2-async-await-的优势在于处理-then-链" class="headerlink" title="2.2. async/await 的优势在于处理 then 链"></a>2.2. async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。</p><p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 <code>setTimeout</code> 来模拟异步操作：</p><pre><code>/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123;    return new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; resolve(n + 200), n);    &#125;);&#125;function step1(n) &#123;    console.log(`step1 with $&#123;n&#125;`);    return takeLongTime(n);&#125;function step2(n) &#123;    console.log(`step2 with $&#123;n&#125;`);    return takeLongTime(n);&#125;function step3(n) &#123;    console.log(`step3 with $&#123;n&#125;`);    return takeLongTime(n);&#125;</code></pre><p>现在用 Promise 方式来实现这三个步骤的处理</p><pre><code>function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; step2(time2))        .then(time3 =&gt; step3(time3))        .then(result =&gt; &#123;            console.log(`result is $&#123;result&#125;`);            console.timeEnd(&quot;doIt&quot;);        &#125;);&#125;doIt();// c:\var\test&gt;node --harmony_async_await .// step1 with 300// step2 with 500// step3 with 700// result is 900// doIt: 1507.251ms</code></pre><p>输出结果 <code>result</code> 是 <code>step3()</code> 的参数 <code>700 + 200</code> = <code>900</code>。<code>doIt()</code> 顺序执行了三个步骤，一共用了 <code>300 + 500 + 700 = 1500</code> 毫秒，和 <code>console.time()/console.timeEnd()</code> 计算的结果一致。</p><p>如果用 async/await 来实现呢，会是这样</p><pre><code>async function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time2);    const result = await step3(time3);    console.log(`result is $&#123;result&#125;`);    console.timeEnd(&quot;doIt&quot;);&#125;doIt();</code></pre><p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p><h3 id="2-3-还有更酷的"><a href="#2-3-还有更酷的" class="headerlink" title="2.3. 还有更酷的"></a>2.3. 还有更酷的</h3><p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。</p><pre><code>function step1(n) &#123;    console.log(`step1 with $&#123;n&#125;`);    return takeLongTime(n);&#125;function step2(m, n) &#123;    console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`);    return takeLongTime(m + n);&#125;function step3(k, m, n) &#123;    console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`);    return takeLongTime(k + m + n);&#125;</code></pre><p>这回先用 async/await 来写：</p><pre><code>async function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time1, time2);    const result = await step3(time1, time2, time3);    console.log(`result is $&#123;result&#125;`);    console.timeEnd(&quot;doIt&quot;);&#125;doIt();// c:\var\test&gt;node --harmony_async_await .// step1 with 300// step2 with 800 = 300 + 500// step3 with 1800 = 300 + 500 + 1000// result is 2000// doIt: 2907.387ms</code></pre><p>除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？</p><pre><code>function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; &#123;            return step2(time1, time2)                .then(time3 =&gt; [time1, time2, time3]);        &#125;)        .then(times =&gt; &#123;            const [time1, time2, time3] = times;            return step3(time1, time2, time3);        &#125;)        .then(result =&gt; &#123;            console.log(`result is $&#123;result&#125;`);            console.timeEnd(&quot;doIt&quot;);        &#125;);&#125;doIt();</code></pre><p>有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！</p><h2 id="3-洗洗睡吧"><a href="#3-洗洗睡吧" class="headerlink" title="3. 洗洗睡吧"></a>3. 洗洗睡吧</h2><p>就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？</p><p><a href="http://www.ruanyifeng.com/blog/2015/05/async.html">阮一峰老师已经说过了</a>，我就懒得说了。</p><h2 id="4-推荐相关文章"><a href="#4-推荐相关文章" class="headerlink" title="4. 推荐相关文章"></a>4. 推荐相关文章</h2><ul><li><a href="https://segmentfault.com/a/1190000021966277">在微信小程序中使用 async/await</a> 2020-03-10</li><li><a href="https://segmentfault.com/a/1190000022349639">代码审查，异步调用的常见问题剖析</a> 2020-04-12</li><li><a href="https://segmentfault.com/a/1190000022315137">Proxy 封装微信小程序的异步调用</a> 2020-04-9</li><li><a href="https://segmentfault.com/a/1190000022467002">改进异步封装：处理带返回值的异步调用</a> 2020-04-25</li><li><a href="https://segmentfault.com/a/1190000007987187">从地狱到天堂，Node 回调向 async/await 转变</a> 2017-01-02</li><li><a href="https://segmentfault.com/a/1190000013337421">异步编程需要“意识”</a> 2018-02-23</li><li><a href="https://segmentfault.com/a/1190000011802045">从不用 try-catch 实现的 async/await 语法说错误处理</a> 2017-10-31</li></ul><h2 id="5-关于转载"><a href="#5-关于转载" class="headerlink" title="5. 关于转载"></a>5. 关于转载</h2><p>转载自<a href="https://segmentfault.com/a/1190000007535316">思否</a> 作者<a href="https://segmentfault.com/u/jamesfancy">边城</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一篇来自2018年4月17日的Git笔记</title>
      <link href="2020/11/09/%E4%B8%80%E7%AF%87%E6%9D%A5%E8%87%AA2018%E5%B9%B44%E6%9C%8817%E6%97%A5%E7%9A%84Git%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/09/%E4%B8%80%E7%AF%87%E6%9D%A5%E8%87%AA2018%E5%B9%B44%E6%9C%8817%E6%97%A5%E7%9A%84Git%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h2><h3 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h3><ul><li>我们平时使用计算机都是通过可视化的界面来对电脑发送命令<ul><li>鼠标右键-&gt;新建-&gt;新建文件夹</li></ul></li><li>命令行窗口也是一种可以向计算机发送命令的途径<ul><li>通过命令的形式告诉计算机我们要做什么</li><li>mkdir 文件夹的名字</li></ul></li><li>开启命令行<ul><li>win + R -&gt; cmd -&gt; enter</li></ul></li><li>常用命令行工具<ul><li>cmd</li><li>powershell</li><li>git bash</li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>pwd (print working directory) 查看当前所在的目录</li><li>cd (change directory) 切换目录</li><li>ls (list) 查看当前目录下的内容(有兼容问题 可以用dir)</li><li>clear 清屏（有兼容问题  可以用cls）</li><li>mkdir (make directory) 创建目录</li><li>touch 创建文件（有兼容问题 可以用 type nul&gt;文件名）</li><li>cat 查看文件内容 一次性将所有内容输出</li><li>less 查看文件内容 每一次查看部分文件内容<ul><li>回车 一次向下走一行</li><li>空格 一次向下走一页</li><li>b（back）    一次向上走一页</li><li>q（quit）    退出</li></ul></li><li>rm (remove) 删除文件 如 rm index.html、rm -rf blog（删除有内容的文件夹）</li><li>rmdir (remove directory) 删除文件夹 只能删除空文件夹 不常用</li><li>mv (move) 移动文件或重命名</li><li>cp (copy) 复制文件</li><li>echo ‘内容’ &gt; 文件 输出内容到文件 每次输出都是覆盖原有文件内容</li><li>ehco ‘内容’ &gt;&gt; 文件 输出内容到文件 每次输出都是追新内容</li><li>命令的基本组成部分<ul><li>rm(删除命令) -rf(选项)</li></ul></li></ul><h3 id="GIT是什么"><a href="#GIT是什么" class="headerlink" title="GIT是什么"></a>GIT是什么</h3><ul><li>版本控制工具<ul><li>例子：<ul><li>人事专员管理职工信息</li><li>项目功能变更导致的问题</li><li>多人开发一个项目 代码共享时的问题</li></ul></li></ul></li></ul><h3 id="GIT三大区域"><a href="#GIT三大区域" class="headerlink" title="GIT三大区域"></a>GIT三大区域</h3><ul><li>工作目录<ul><li>存放项目代码的目录</li></ul></li><li>暂存区<ul><li>临时存放更改的了文件</li><li>防止工作目录中的代码丢失</li></ul></li><li>代码仓库<ul><li>当开发的功能足以形成一个版本的时候 可以将代码形成版本提交到仓库</li><li>相当于复制了一份当前的代码存储到了仓库中</li></ul></li></ul><h3 id="GIT常用命令"><a href="#GIT常用命令" class="headerlink" title="GIT常用命令"></a>GIT常用命令</h3><ul><li>配置git用户名和邮箱<ul><li>git config –global user.name zhangsan</li><li>git config –global user.email <a href="mailto:&#100;&#101;&#109;&#x6f;&#116;&#x65;&#115;&#x74;&#49;&#50;&#x33;&#64;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;">&#100;&#101;&#109;&#x6f;&#116;&#x65;&#115;&#x74;&#49;&#50;&#x33;&#64;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></li></ul></li><li>查看当前的git配置<ul><li>git config –list</li></ul></li><li>初始化git仓库<ul><li>git init</li></ul></li><li>查看当前仓库的状态 <ul><li>git status</li></ul></li><li>将工作目录中的文件添加到暂存区<ul><li>git add</li></ul></li><li>将暂存区中的代码提交到本地仓库 形成一个版本<ul><li>git commit -m 备注 </li></ul></li><li>查看本地仓库中的历史提交版本<ul><li>git log </li></ul></li><li>将暂存区中的文件恢复到工作目录<ul><li>git rm –cached 文件列表 </li><li>说明:<ul><li>必须保证工作目录中的代码和暂存区中的代码一致</li><li>此时工作目录中有此文件 暂存区中没有此文件 这个文件不被git管理</li></ul></li></ul></li><li>用暂存区中的文件覆盖工作目录中的文件<ul><li>git checkout – 文件列表</li><li>说明：暂存区和工作目录都有此文件 这个文件依然被git管理</li></ul></li><li>回滚到本地仓库中的特定版本并覆盖暂存区和工作目录<ul><li>git reset –hard commitID</li></ul></li><li>查看分支<ul><li>git branch</li></ul></li><li>创建分支<ul><li>git branch 分支名称</li></ul></li><li>切换分支<ul><li>git checkout 分支名称</li></ul></li><li>创建并切换分支<ul><li>git checkout -b 分支名称 </li></ul></li><li>删除分支(如果分支没有被合并不允许删除)<ul><li>git branch -d 分支名称</li></ul></li><li>删除分支(强制删除分支)<ul><li>git branch -D 分支名称</li></ul></li><li>合并分支<ul><li>git merge 来源分支</li></ul></li><li>初始化一个裸露仓库(公共代码仓库)<ul><li>git init –bare </li></ul></li><li>向远程仓库推送代码<ul><li>git push 远程仓库地址 本地分支名称:远程分支名称</li></ul></li><li>从远程仓库中拉取代码(拉取最新版本到本地 开发过程中使用)<ul><li>git pull 远程仓库地址 远程分支名称:本地分支名称</li></ul></li><li>为远程仓库地址创建别名<ul><li>git remote add 别名 远程仓库地址</li></ul></li><li>查看远程地址的详情信息<ul><li>git remote -v</li></ul></li><li>查看当前别名所对应的远程仓库地址<ul><li>git remote show 别名 </li></ul></li><li>删除当前别名及所对应的远程仓库地址<ul><li>git remote remove 别名 </li></ul></li><li>从远程仓库获取代码(拉取所有版本到本地)<ul><li>git clone 远程仓库地址 项目名称</li><li>使用场景：加入到已有项目的开发中 需要先拉取所有版本到本地 再进行开发</li></ul></li><li>冲突修复<ul><li>模拟冲突<ul><li>张三和李四分别克隆代码到本地</li><li>张三改了demo文件并提交到远端仓库</li><li>李四也改了同一个文件</li><li>这时因为张三已经提交了一版代码到远程仓库</li><li>远程仓库的代码要比李四本地的代码新</li><li>所以李四不能直接向远程仓库推送代码</li><li>要先拉去再推送</li><li>此时因为张三和李四改了同一个文件所以产生了冲突</li><li>李四解决冲突并再次提交代码到远程仓库</li></ul></li></ul></li><li>多人协作开发免登录操作<ul><li>ssh-keygen</li></ul></li></ul><h3 id="git使用流程"><a href="#git使用流程" class="headerlink" title="git使用流程"></a>git使用流程</h3><ul><li>1.配置账户信息<ul><li>git config –global user.name 用户名</li><li>git config –global user.email 邮箱地址</li><li>git config –list 查看当前的git配置</li></ul></li><li>2.初始化本地仓库<ul><li>git init</li></ul></li><li>3.查看本地仓库的状态<ul><li>git status</li></ul></li><li>4.将工作目录中的文件提交到暂存区<ul><li>git add 文件列表</li><li>git add . 添加工作目录中所有的文件到暂存区</li></ul></li><li><ol><li>将暂存区中的代码提交到本地仓库<ul><li>git commit -m 备注</li><li>git commit -m “first commit”</li></ul></li></ol></li></ul><h3 id="git-忽略清单"><a href="#git-忽略清单" class="headerlink" title="git 忽略清单"></a>git 忽略清单</h3><ul><li>.gitignore文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这个Blog还有我</title>
      <link href="2020/11/07/%E8%BF%99%E4%B8%AABlog%E8%BF%98%E6%9C%89%E6%88%91/"/>
      <url>2020/11/07/%E8%BF%99%E4%B8%AABlog%E8%BF%98%E6%9C%89%E6%88%91/</url>
      
        <content type="html"><![CDATA[<h1 id="这个Blog还有我"><a href="#这个Blog还有我" class="headerlink" title="这个Blog还有我"></a>这个Blog还有我</h1><hr><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p><strong>我</strong> 是一名前端工程师，性别男，97年，老家安徽。在校专业软工，15年下半年左右开始前端工作，目前在合肥市。<br><strong>兴趣爱好：</strong> 听音乐，排球，羽毛球，骑车<br><strong>Favor：</strong> 周末、月末、发薪日、节日会犒劳一下自己，某天加班久了大概率也会，应该是一种代偿心理，现在打算改为每两周一次；馥郁多汁的肉类，比较喜欢；不是耳机发烧友，只是为了更好的听自己喜欢的歌；天文望远镜，一直想买但是没买，主要是不在家。<br><strong>联系方式：</strong> 手机：18856980690 邮箱：<a href="mailto:&#104;&#101;&#121;&#108;&#x68;&#x65;&#x79;&#x7a;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;">&#104;&#101;&#121;&#108;&#x68;&#x65;&#x79;&#x7a;&#64;&#49;&#54;&#x33;&#46;&#x63;&#111;&#x6d;</a></p><h5 id="技能简介"><a href="#技能简介" class="headerlink" title="技能简介"></a>技能简介</h5><p><strong>技术栈</strong> H5、C3、JS、Vue、uni-app，以上熟练，不敢说精通。React、RN、Flutter、Taro，只是涉猎。<br><strong>PC端</strong> 企业站及后台管理系统，自适应及兼容基本没问题，因为兼容低版本IE很少遇到了，比较炫酷的CSS会费劲。<br><strong>移动端</strong> 现在比较依赖uni-app来开发，之前用京东的Taro做过微信小程序，支付宝小程序也做过。移动端兼容适配熟练。<br><strong>业务能力</strong> 10分给7分，各种情况自己能考虑到绝大部分。框架修改组件开发无压力，但是有现成的就偏向于用轮子。</p><h5 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h5><p>待人友好，对社交关系比较重视。熟练的前端开发工程师，上手能力强，正在积极突破技术，看薪资及氛围接受长期加班及非双休。</p><h2 id="博客简介"><a href="#博客简介" class="headerlink" title="博客简介"></a>博客简介</h2><p><strong>这里是我技术的总结，是我工作经历的记录，是我日常生活的描述。</strong></p><h2 id="其他的事情"><a href="#其他的事情" class="headerlink" title="其他的事情"></a>其他的事情</h2><p>很惭愧，接触IT行业5年左右了，才想起来做自己的博客，也没打算说做的多么好，只要还在工作，就会一直记录。<br>感谢 <a href="https://github.com/blinkfox">blinkfox</a>和<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，Ta的文章与Hexo主题帮助我建立了这个博客。</p>]]></content>
      
      
      <categories>
          
          <category> 致来访者 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人简介 </tag>
            
            <tag> 博客简介 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这是我的第一篇博客</title>
      <link href="2020/10/22/%E4%BD%BF%E7%94%A8CSDN-markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>2020/10/22/%E4%BD%BF%E7%94%A8CSDN-markdown%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="这是我的第一篇博客"><a href="#这是我的第一篇博客" class="headerlink" title="这是我的第一篇博客"></a>这是我的第一篇博客</h1><ul><li><strong>Markdown和扩展Markdown简洁的语法</strong></li><li><strong>代码块高亮</strong></li><li><strong>图片链接和图片上传</strong></li><li><strong><em>LaTex</em>数学公式</strong></li><li><strong>UML序列图和流程图</strong></li><li><strong>离线写博客</strong></li><li><strong>导入导出Markdown文件</strong></li><li><strong>丰富的快捷键</strong></li></ul><hr><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>加粗    <code>Ctrl + B</code> </li><li>斜体    <code>Ctrl + I</code> </li><li>引用    <code>Ctrl + Q</code></li><li>插入链接    <code>Ctrl + L</code></li><li>插入代码    <code>Ctrl + K</code></li><li>插入图片    <code>Ctrl + G</code></li><li>提升标题    <code>Ctrl + H</code></li><li>有序列表    <code>Ctrl + O</code></li><li>无序列表    <code>Ctrl + U</code></li><li>横线    <code>Ctrl + R</code></li><li>撤销    <code>Ctrl + Z</code></li><li>重做    <code>Ctrl + Y</code></li></ul><h2 id="Markdown及扩展"><a href="#Markdown及扩展" class="headerlink" title="Markdown及扩展"></a>Markdown及扩展</h2><blockquote><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank"> [ 维基百科 ]</p></blockquote><p>使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.csdn.net/">链接</a>等，详细语法参考帮助？。</p><p>本编辑器支持 <strong>Markdown Extra</strong> , 　扩展了很多好用的功能。具体请参考<a href="https://github.com/jmcmanus/pagedown-extra" title="Pagedown Extra">Github</a>.  </p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown　Extra</strong>　表格语法：</p><table><thead><tr><th>项目</th><th>价格</th></tr></thead><tbody><tr><td>Computer</td><td>$1600</td></tr><tr><td>Phone</td><td>$12</td></tr><tr><td>Pipe</td><td>$1</td></tr></tbody></table><p>可以使用冒号来定义对齐方式：</p><table><thead><tr><th align="left">项目</th><th align="right">价格</th><th align="center">数量</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">1600 元</td><td align="center">5</td></tr><tr><td align="left">Phone</td><td align="right">12 元</td><td align="center">12</td></tr><tr><td align="left">Pipe</td><td align="right">1 元</td><td align="center">234</td></tr></tbody></table><p>###定义列表</p><dl><dt><strong>Markdown　Extra</strong>　定义列表语法：<br>项目１<br>项目２<br>:   定义 A</dt><dd>定义 B</dd></dl><dl><dt>项目３</dt><dd>定义 C</dd></dl><p>:   定义 D</p><pre><code>&gt; 定义D内容</code></pre><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块语法遵循标准markdown代码，例如：</p><pre class=" language-python"><code class="language-python">@requires_authorization<span class="token keyword">def</span> <span class="token function">somefunc</span><span class="token punctuation">(</span>param1<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">,</span> param2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''A docstring'''</span>    <span class="token keyword">if</span> param1 <span class="token operator">></span> param2<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># interesting</span>        <span class="token keyword">print</span> <span class="token string">'Greater'</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>param2 <span class="token operator">-</span> param1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">or</span> None<span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token operator">>></span><span class="token operator">></span> message <span class="token operator">=</span> <span class="token triple-quoted-string string">'''interpreter... prompt'''</span></code></pre><p>###脚注<br>生成一个脚注[^footnote].<br>  [^footnote]: 这里是 <strong>脚注</strong> 的 <em>内容</em>.</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>用 <code>[TOC]</code>来生成目录：</p><p>@[toc]</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><p>使用MathJax渲染<em>LaTex</em> 数学公式，详见<a href="http://math.stackexchange.com/">math.stackexchange.com</a>.</p><ul><li>行内公式，数学公式为：$\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。</li><li>块级公式：</li></ul><p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p><p>更多LaTex语法请参考 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">这儿</a>.</p><h3 id="UML-图"><a href="#UML-图" class="headerlink" title="UML 图:"></a>UML 图:</h3><p>可以渲染序列图：</p><pre class=" language-mermaid"><code class="language-mermaid">sequenceDiagram张三->>李四: 嘿，小四儿, 写博客了没?Note right of 李四: 李四愣了一下，说：李四-->>张三: 忙得吐血，哪有时间写。</code></pre><p>或者流程图：</p><pre class=" language-mermaid"><code class="language-mermaid">flowchatst=>start: 开始e=>end: 结束op=>operation: 我的操作cond=>condition: 确认？st->op->condcond(yes)->econd(no)->op</code></pre><ul><li>关于 <strong>序列图</strong> 语法，参考 <a href="http://bramp.github.io/js-sequence-diagrams/">这儿</a>,</li><li>关于 <strong>流程图</strong> 语法，参考 <a href="http://adrai.github.io/flowchart.js/">这儿</a>.</li></ul><h2 id="离线写博客"><a href="#离线写博客" class="headerlink" title="离线写博客"></a>离线写博客</h2><p>即使用户在没有网络的情况下，也可以通过本编辑器离线写博客（直接在曾经使用过的浏览器中输入<a href="http://write.blog.csdn.net/mdeditor">write.blog.csdn.net/mdeditor</a>即可。<strong>Markdown编辑器</strong>使用浏览器离线存储将内容保存在本地。</p><p>用户写博客的过程中，内容实时保存在浏览器缓存中，在用户关闭浏览器或者其它异常情况下，内容不会丢失。用户再次打开浏览器时，会显示上次用户正在编辑的没有发表的内容。</p><p>博客发表后，本地缓存将被删除。　</p><p>用户可以选择 <i class="icon-disk"></i> 把正在写的博客保存到服务器草稿箱，即使换浏览器或者清除缓存，内容也不会丢失。</p><blockquote><p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但为了您的数据安全，在联网后，<strong>请务必及时发表或者保存到服务器草稿箱</strong>。</p></blockquote><p>##浏览器兼容</p><ol><li>目前，本编辑器对Chrome浏览器支持最为完整。建议大家使用较新版本的Chrome。</li><li>IE９以下不支持</li><li>IE９，１０，１１存在以下问题<ol><li>不支持离线功能</li><li>IE9不支持文件导入导出</li><li>IE10不支持拖拽文件导入</li></ol></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
